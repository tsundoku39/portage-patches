diff -urN a/src/addressbook/gui/contact-editor/e-contact-editor.c b/src/addressbook/gui/contact-editor/e-contact-editor.c
--- a/src/addressbook/gui/contact-editor/e-contact-editor.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/addressbook/gui/contact-editor/e-contact-editor.c	2022-01-08 18:47:17.601546307 -0800
@@ -260,14 +260,14 @@
 	{ "undo",
 	  "edit-undo",
 	  N_("_Undo"),
-	  "<Control>z",
+	  "<Super>z",
 	  N_("Undo"),
 	  NULL }, /* Handled by EFocusTracker */
 
 	{ "redo",
 	  "edit-redo",
 	  N_("_Redo"),
-	  "<Control>y",
+	  "<Super>y",
 	  N_("Redo"),
 	  NULL } /* Handled by EFocusTracker */
 
diff -urN a/src/addressbook/gui/contact-editor/e-contact-editor.c.orig b/src/addressbook/gui/contact-editor/e-contact-editor.c.orig
--- a/src/addressbook/gui/contact-editor/e-contact-editor.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/addressbook/gui/contact-editor/e-contact-editor.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,5631 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Authors:
+ *		Chris Lahey <clahey@ximian.com>
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ */
+
+#include "evolution-config.h"
+
+#include "eab-editor.h"
+#include "e-contact-editor.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <gtk/gtk.h>
+#include <glib/gi18n.h>
+#include <gdk/gdkkeysyms.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+#define GCR_API_SUBJECT_TO_CHANGE
+#include <gcr/gcr.h>
+#undef GCR_API_SUBJECT_TO_CHANGE
+
+#include "shell/e-shell.h"
+#include "e-util/e-util.h"
+
+#include "addressbook/printing/e-contact-print.h"
+#include "addressbook/gui/widgets/eab-gui-util.h"
+#include "addressbook/util/eab-book-util.h"
+
+#include "eab-contact-merging.h"
+
+#include "e-contact-editor-fullname.h"
+#include "e-contact-editor-dyntable.h"
+
+#define SLOTS_PER_LINE 2
+#define SLOTS_IN_COLLAPSED_STATE SLOTS_PER_LINE
+#define EMAIL_SLOTS   50
+#define PHONE_SLOTS   50
+#define SIP_SLOTS     4
+#define IM_SLOTS      50
+#define ADDRESS_SLOTS 3
+
+/* represents index in address_name */
+#define ADDRESS_SLOT_HOME  1
+#define ADDRESS_SLOT_WORK  0
+#define ADDRESS_SLOT_OTHER 2
+
+#define EVOLUTION_UI_SLOT_PARAM "X-EVOLUTION-UI-SLOT"
+
+#define CHECK_PHONE 	1
+#define CHECK_SIP 	2
+#define CHECK_IM	3
+#define CHECK_HOME	4
+#define CHECK_WORK	5
+#define CHECK_OTHER	6
+#define CHECK_WEB	7
+#define CHECK_JOB	8
+#define CHECK_MISC	9
+#define CHECK_NOTE	10
+#define CHECK_CERTS	11
+
+/* IM columns */
+enum {
+	COLUMN_IM_ICON,
+	COLUMN_IM_SERVICE,
+	COLUMN_IM_SCREENNAME,
+	COLUMN_IM_LOCATION,
+	COLUMN_IM_LOCATION_TYPE,
+	COLUMN_IM_SERVICE_FIELD,
+	NUM_IM_COLUMNS
+};
+
+typedef struct {
+	EContactEditor *editor;
+	ESource *source;
+} ConnectClosure;
+
+static void	e_contact_editor_set_property	(GObject *object,
+						 guint property_id,
+						 const GValue *value,
+						 GParamSpec *pspec);
+static void	e_contact_editor_get_property	(GObject *object,
+						 guint property_id,
+						 GValue *value,
+						 GParamSpec *pspec);
+static void	e_contact_editor_constructed	(GObject *object);
+static void	e_contact_editor_dispose	(GObject *object);
+static void	e_contact_editor_raise		(EABEditor *editor);
+static void	e_contact_editor_show		(EABEditor *editor);
+static void	e_contact_editor_save_contact	(EABEditor *editor,
+						 gboolean should_close);
+static void	e_contact_editor_close		(EABEditor *editor);
+static gboolean	e_contact_editor_is_valid	(EABEditor *editor);
+static gboolean	e_contact_editor_is_changed	(EABEditor *editor);
+static GtkWindow *
+		e_contact_editor_get_window	(EABEditor *editor);
+static void	save_contact			(EContactEditor *ce,
+						 gboolean should_close);
+static void	entry_activated			(EContactEditor *editor);
+
+static void	set_entry_text			(EContactEditor *editor,
+						 GtkEntry *entry,
+						 const gchar *string);
+static void	sensitize_ok			(EContactEditor *ce);
+
+static EABEditorClass *parent_class = NULL;
+
+enum {
+	PROP_0,
+	PROP_SOURCE_CLIENT,
+	PROP_TARGET_CLIENT,
+	PROP_CONTACT,
+	PROP_IS_NEW_CONTACT,
+	PROP_EDITABLE,
+	PROP_CHANGED,
+	PROP_WRITABLE_FIELDS,
+	PROP_REQUIRED_FIELDS
+};
+
+enum {
+	DYNAMIC_LIST_EMAIL,
+	DYNAMIC_LIST_PHONE,
+	DYNAMIC_LIST_ADDRESS
+};
+
+/* Defaults selected from eab_phone_types */
+static const gint phones_default[] = { 1, 6, 9, 2, 7, 12, 10, 10 };
+
+static EContactField addresses[] = {
+	E_CONTACT_ADDRESS_WORK,
+	E_CONTACT_ADDRESS_HOME,
+	E_CONTACT_ADDRESS_OTHER
+};
+
+static EContactField address_labels[] = {
+	E_CONTACT_ADDRESS_LABEL_WORK,
+	E_CONTACT_ADDRESS_LABEL_HOME,
+	E_CONTACT_ADDRESS_LABEL_OTHER
+};
+
+static const gchar *address_name[] = {
+	"work",
+	"home",
+	"other"
+};
+
+/*
+ * keep fetch_set in sync with labels from eab_im_service
+ */
+static EContactField
+im_service_fetch_set[] =
+{
+	E_CONTACT_IM_AIM,
+	E_CONTACT_IM_JABBER,
+	E_CONTACT_IM_YAHOO,
+	E_CONTACT_IM_GADUGADU,
+	E_CONTACT_IM_MSN,
+	E_CONTACT_IM_ICQ,
+	E_CONTACT_IM_GROUPWISE,
+	E_CONTACT_IM_SKYPE,
+	E_CONTACT_IM_TWITTER,
+	E_CONTACT_IM_GOOGLE_TALK,
+	E_CONTACT_IM_MATRIX
+};
+
+/* Defaults selected from eab_get_im_type_labels */
+static const gint im_service_default[] = { 0, 2, 4, 5 };
+
+
+/* Default from the table above */
+static const gint email_default[] = { 0, 1, 2, 2 };
+static const gint sips_default[] = { 0, 1, 2, 2 };
+
+#define STRING_IS_EMPTY(x)      (!(x) || !(*(x)))
+#define STRING_MAKE_NON_NULL(x) ((x) ? (x) : "")
+
+struct _EContactEditorPrivate
+{
+	/* item specific fields */
+	EBookClient *source_client;
+	EBookClient *target_client;
+	EContact *contact;
+
+	GtkBuilder *builder;
+	GtkWidget *app;
+
+	GtkWidget *image_selector;
+	GtkFileChooserNative *image_selector_native;
+
+	EContactName *name;
+
+	/* Whether we are editing a new contact or an existing one */
+	guint is_new_contact : 1;
+
+	/* Whether an image is associated with a contact. */
+	guint image_set : 1;
+
+	/* Whether the contact has been changed since bringing up the contact editor */
+	guint changed : 1;
+
+	/* Wheter should check for contact to merge. Only when name or email are changed */
+	guint check_merge : 1;
+
+	/* Whether the contact editor will accept modifications, save */
+	guint target_editable : 1;
+
+	/* Whether an async wombat call is in progress */
+	guint in_async_call : 1;
+
+	/* Whether an image is changed */
+	guint image_changed : 1;
+
+	/* Whether to try to reduce space used */
+	guint compress_ui : 1;
+
+	GSList *writable_fields;
+
+	GSList *required_fields;
+
+	GCancellable *cancellable;
+
+	/* signal ids for "writable_status" */
+	gint target_editable_id;
+
+	GtkWidget *fullname_dialog;
+	GtkWidget *categories_dialog;
+
+	GtkUIManager *ui_manager;
+	EFocusTracker *focus_tracker;
+};
+
+G_DEFINE_TYPE (EContactEditor, e_contact_editor, EAB_TYPE_EDITOR)
+
+static GtkActionEntry undo_entries[] = {
+
+	{ "undo-menu",
+	  "Undo menu",
+	  NULL,
+	  NULL,
+	  NULL,
+	  NULL }, /* just a fake undo menu, to get shortcuts working */
+
+	{ "undo",
+	  "edit-undo",
+	  N_("_Undo"),
+	  "<Control>z",
+	  N_("Undo"),
+	  NULL }, /* Handled by EFocusTracker */
+
+	{ "redo",
+	  "edit-redo",
+	  N_("_Redo"),
+	  "<Control>y",
+	  N_("Redo"),
+	  NULL } /* Handled by EFocusTracker */
+
+};
+
+static void
+connect_closure_free (ConnectClosure *connect_closure)
+{
+	if (connect_closure->editor != NULL)
+		g_object_unref (connect_closure->editor);
+
+	if (connect_closure->source != NULL)
+		g_object_unref (connect_closure->source);
+
+	g_slice_free (ConnectClosure, connect_closure);
+}
+
+static void
+e_contact_editor_contact_added (EABEditor *editor,
+                                const GError *error,
+                                EContact *contact)
+{
+	GtkWindow *window;
+	const gchar *message;
+
+	if (error == NULL)
+		return;
+
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+		return;
+
+	window = eab_editor_get_window (editor);
+	message = _("Error adding contact");
+
+	eab_error_dialog (NULL, window, message, error);
+}
+
+static void
+e_contact_editor_contact_modified (EABEditor *editor,
+                                   const GError *error,
+                                   EContact *contact)
+{
+	GtkWindow *window;
+	const gchar *message;
+
+	if (error == NULL)
+		return;
+
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+		return;
+
+	window = eab_editor_get_window (editor);
+	message = _("Error modifying contact");
+
+	eab_error_dialog (NULL, window, message, error);
+}
+
+static void
+e_contact_editor_contact_deleted (EABEditor *editor,
+                                  const GError *error,
+                                  EContact *contact)
+{
+	GtkWindow *window;
+	const gchar *message;
+
+	if (error == NULL)
+		return;
+
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+		return;
+
+	window = eab_editor_get_window (editor);
+	message = _("Error removing contact");
+
+	eab_error_dialog (NULL, window, message, error);
+}
+
+static void
+e_contact_editor_closed (EABEditor *editor)
+{
+	g_object_unref (editor);
+}
+
+static void
+e_contact_editor_class_init (EContactEditorClass *class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (class);
+	EABEditorClass *editor_class = EAB_EDITOR_CLASS (class);
+
+	g_type_class_add_private (class, sizeof (EContactEditorPrivate));
+
+	parent_class = g_type_class_ref (EAB_TYPE_EDITOR);
+
+	object_class->set_property = e_contact_editor_set_property;
+	object_class->get_property = e_contact_editor_get_property;
+	object_class->constructed = e_contact_editor_constructed;
+	object_class->dispose = e_contact_editor_dispose;
+
+	editor_class->raise = e_contact_editor_raise;
+	editor_class->show = e_contact_editor_show;
+	editor_class->close = e_contact_editor_close;
+	editor_class->is_valid = e_contact_editor_is_valid;
+	editor_class->save_contact = e_contact_editor_save_contact;
+	editor_class->is_changed = e_contact_editor_is_changed;
+	editor_class->get_window = e_contact_editor_get_window;
+	editor_class->contact_added = e_contact_editor_contact_added;
+	editor_class->contact_modified = e_contact_editor_contact_modified;
+	editor_class->contact_deleted = e_contact_editor_contact_deleted;
+	editor_class->editor_closed = e_contact_editor_closed;
+
+	g_object_class_install_property (
+		object_class,
+		PROP_SOURCE_CLIENT,
+		g_param_spec_object (
+			"source_client",
+			"Source EBookClient",
+			NULL,
+			E_TYPE_BOOK_CLIENT,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_TARGET_CLIENT,
+		g_param_spec_object (
+			"target_client",
+			"Target EBookClient",
+			NULL,
+			E_TYPE_BOOK_CLIENT,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_CONTACT,
+		g_param_spec_object (
+			"contact",
+			"Contact",
+			NULL,
+			E_TYPE_CONTACT,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_IS_NEW_CONTACT,
+		g_param_spec_boolean (
+			"is_new_contact",
+			"Is New Contact",
+			NULL,
+			FALSE,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_WRITABLE_FIELDS,
+		g_param_spec_pointer (
+			"writable_fields",
+			"Writable Fields",
+			NULL,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_REQUIRED_FIELDS,
+		g_param_spec_pointer (
+			"required_fields",
+			"Required Fields",
+			NULL,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_EDITABLE,
+		g_param_spec_boolean (
+			"editable",
+			"Editable",
+			NULL,
+			FALSE,
+			G_PARAM_READWRITE));
+
+	g_object_class_install_property (
+		object_class,
+		PROP_CHANGED,
+		g_param_spec_boolean (
+			"changed",
+			"Changed",
+			NULL,
+			FALSE,
+			G_PARAM_READWRITE));
+}
+
+static void
+entry_activated (EContactEditor *editor)
+{
+	save_contact (editor, TRUE);
+}
+
+/* FIXME: Linear time... */
+static gboolean
+is_field_supported (EContactEditor *editor,
+                    EContactField field_id)
+{
+	GSList      *fields, *iter;
+	const gchar *field;
+
+	fields = editor->priv->writable_fields;
+	if (!fields)
+		return FALSE;
+
+	field = e_contact_field_name (field_id);
+	if (!field)
+		return FALSE;
+
+	for (iter = fields; iter; iter = iter->next) {
+		const gchar *this_field = iter->data;
+
+		if (!this_field)
+			continue;
+
+		if (!strcmp (field, this_field))
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+/* This function tells you whether name_to_style will make sense.  */
+static gboolean
+style_makes_sense (const EContactName *name,
+                   const gchar *company,
+                   gint style)
+{
+	switch (style) {
+	case 0: /* Fall Through */
+	case 1:
+		return TRUE;
+	case 2:
+		if (name) {
+			if (name->additional && *name->additional)
+				return TRUE;
+			else
+				return FALSE;
+		}
+		return FALSE;
+	case 3:
+		if (company && *company)
+			return TRUE;
+		else
+			return FALSE;
+	case 4: /* Fall Through */
+	case 5:
+		if (company && *company && name &&
+			((name->given && *name->given) ||
+			 (name->family && *name->family)))
+			return TRUE;
+		else
+			return FALSE;
+	default:
+		return FALSE;
+	}
+}
+
+static gchar *
+name_to_style (const EContactName *name,
+               const gchar *company,
+               gint style)
+{
+	gchar *string;
+	gchar *strings[4], **stringptr;
+	gchar *midstring[4], **midstrptr;
+	gchar *substring;
+	switch (style) {
+	case 0:
+		stringptr = strings;
+		if (name) {
+			if (name->family && *name->family)
+				*(stringptr++) = name->family;
+			if (name->given && *name->given)
+				*(stringptr++) = name->given;
+		}
+		*stringptr = NULL;
+		string = g_strjoinv (", ", strings);
+		break;
+	case 1:
+		stringptr = strings;
+		if (name) {
+			if (name->given && *name->given)
+				*(stringptr++) = name->given;
+			if (name->family && *name->family)
+				*(stringptr++) = name->family;
+		}
+		*stringptr = NULL;
+		string = g_strjoinv (" ", strings);
+		break;
+	case 2:
+		midstrptr = midstring;
+		if (name) {
+			if (name->family && *name->family)
+				*(midstrptr++) = name->family;
+			if (name->given && *name->given)
+				*(midstrptr++) = name->given;
+		}
+		*midstrptr = NULL;
+		stringptr = strings;
+		*(stringptr++) = g_strjoinv(", ", midstring);
+		if (name) {
+			if (name->additional && *name->additional)
+				*(stringptr++) = name->additional;
+		}
+		*stringptr = NULL;
+		string = g_strjoinv (" ", strings);
+		break;
+	case 3:
+		string = g_strdup (company);
+		break;
+	case 4: /* Fall Through */
+	case 5:
+		stringptr = strings;
+		if (name) {
+			if (name->family && *name->family)
+				*(stringptr++) = name->family;
+			if (name->given && *name->given)
+				*(stringptr++) = name->given;
+		}
+		*stringptr = NULL;
+		substring = g_strjoinv (", ", strings);
+		if (!(company && *company))
+			company = "";
+		if (style == 4)
+			string = g_strdup_printf ("%s (%s)", substring, company);
+		else
+			string = g_strdup_printf ("%s (%s)", company, substring);
+		g_free (substring);
+		break;
+	default:
+		string = g_strdup ("");
+	}
+	return string;
+}
+
+static gint
+file_as_get_style (EContactEditor *editor)
+{
+	GtkEntry *file_as = GTK_ENTRY (
+		gtk_bin_get_child (GTK_BIN (
+		e_builder_get_widget (editor->priv->builder, "combo-file-as"))));
+	GtkEntry *company_w = GTK_ENTRY (
+		e_builder_get_widget (editor->priv->builder, "entry-company"));
+	const gchar *filestring;
+	gchar *trystring;
+	EContactName *name = editor->priv->name;
+	const gchar *company;
+	gint i;
+
+	if (!(file_as && GTK_IS_ENTRY (file_as)))
+		return -1;
+
+	company = gtk_entry_get_text (GTK_ENTRY (company_w));
+	filestring = gtk_entry_get_text (file_as);
+
+	for (i = 0; i < 6; i++) {
+		trystring = name_to_style (name, company, i);
+		if (!strcmp (trystring, filestring)) {
+			g_free (trystring);
+			return i;
+		}
+		g_free (trystring);
+	}
+	return -1;
+}
+
+static void
+file_as_set_style (EContactEditor *editor,
+                   gint style)
+{
+	gchar *string;
+	gint i;
+	GList *strings = NULL;
+	GtkComboBox *combo_file_as = GTK_COMBO_BOX (
+		e_builder_get_widget (editor->priv->builder, "combo-file-as"));
+	GtkEntry *company_w = GTK_ENTRY (
+		e_builder_get_widget (editor->priv->builder, "entry-company"));
+	const gchar *company;
+
+	if (!(combo_file_as && GTK_IS_COMBO_BOX (combo_file_as)))
+		return;
+
+	company = gtk_entry_get_text (GTK_ENTRY (company_w));
+
+	if (style == -1) {
+		GtkWidget *entry;
+
+		entry = gtk_bin_get_child (GTK_BIN (combo_file_as));
+		if (entry) {
+			string = g_strdup (gtk_entry_get_text (GTK_ENTRY (entry)));
+			strings = g_list_append (strings, string);
+		}
+	}
+
+	for (i = 0; i < 6; i++) {
+		if (style_makes_sense (editor->priv->name, company, i)) {
+			gchar *u;
+			u = name_to_style (editor->priv->name, company, i);
+			if (!STRING_IS_EMPTY (u))
+				strings = g_list_append (strings, u);
+			else
+				g_free (u);
+		}
+	}
+
+	if (combo_file_as) {
+		GList *l;
+		GtkListStore *list_store;
+		GtkTreeIter iter;
+
+		list_store = GTK_LIST_STORE (
+			gtk_combo_box_get_model (combo_file_as));
+
+		gtk_list_store_clear (list_store);
+
+		for (l = strings; l; l = l->next) {
+			gtk_list_store_append (list_store, &iter);
+			gtk_list_store_set (list_store, &iter, 0, l->data, -1);
+		}
+	}
+
+	g_list_foreach (strings, (GFunc) g_free, NULL);
+	g_list_free (strings);
+
+	if (style != -1) {
+		string = name_to_style (editor->priv->name, company, style);
+		set_entry_text (
+			editor, GTK_ENTRY (gtk_bin_get_child (
+			GTK_BIN (combo_file_as))), string);
+		g_free (string);
+	}
+}
+
+static void
+name_entry_changed (GtkWidget *widget,
+                    EContactEditor *editor)
+{
+	gint style = 0;
+	const gchar *string;
+
+	style = file_as_get_style (editor);
+	e_contact_name_free (editor->priv->name);
+	string = gtk_entry_get_text (GTK_ENTRY (widget));
+	editor->priv->name = e_contact_name_from_string (string);
+	file_as_set_style (editor, style);
+
+	editor->priv->check_merge = TRUE;
+
+	sensitize_ok (editor);
+	if (string && !*string)
+		gtk_window_set_title (
+			GTK_WINDOW (editor->priv->app), _("Contact Editor"));
+}
+
+static void
+file_as_combo_changed (GtkWidget *widget,
+                       EContactEditor *editor)
+{
+	GtkWidget *entry;
+	gchar *string = NULL;
+
+	entry = gtk_bin_get_child (GTK_BIN (widget));
+	if (entry)
+		string = g_strdup (gtk_entry_get_text (GTK_ENTRY (entry)));
+
+	if (string && *string) {
+		gchar *title;
+		title = g_strdup_printf (_("Contact Editor — %s"), string);
+		gtk_window_set_title (GTK_WINDOW (editor->priv->app), title);
+		g_free (title);
+	}
+	else {
+		gtk_window_set_title (
+			GTK_WINDOW (editor->priv->app), _("Contact Editor"));
+	}
+	sensitize_ok (editor);
+
+	g_free (string);
+}
+
+static void
+company_entry_changed (GtkWidget *widget,
+                       EContactEditor *editor)
+{
+	gint style = 0;
+
+	style = file_as_get_style (editor);
+	file_as_set_style (editor, style);
+}
+
+static void
+update_file_as_combo (EContactEditor *editor)
+{
+	file_as_set_style (editor, file_as_get_style (editor));
+}
+
+static void
+fill_in_source_field (EContactEditor *editor)
+{
+	GtkWidget *source_menu;
+
+	if (!editor->priv->target_client)
+		return;
+
+	source_menu = e_builder_get_widget (
+		editor->priv->builder, "client-combo-box");
+
+	e_source_combo_box_set_active (
+		E_SOURCE_COMBO_BOX (source_menu),
+		e_client_get_source (E_CLIENT (editor->priv->target_client)));
+}
+
+static void
+sensitize_ok (EContactEditor *ce)
+{
+	GtkWidget *widget;
+	gboolean   allow_save;
+	GtkWidget *entry_fullname =
+		e_builder_get_widget (ce->priv->builder, "entry-fullname");
+	GtkWidget *entry_file_as =
+		gtk_bin_get_child (GTK_BIN (
+		e_builder_get_widget (ce->priv->builder, "combo-file-as")));
+	GtkWidget *company_name =
+		e_builder_get_widget (ce->priv->builder, "entry-company");
+	const gchar *name_entry_string =
+		gtk_entry_get_text (GTK_ENTRY (entry_fullname));
+	const gchar *file_as_entry_string =
+		gtk_entry_get_text (GTK_ENTRY (entry_file_as));
+	const gchar *company_name_string =
+		gtk_entry_get_text (GTK_ENTRY (company_name));
+
+	allow_save = ce->priv->target_editable && ce->priv->changed;
+
+	if (!strcmp (name_entry_string, "") ||
+	    !strcmp (file_as_entry_string, "")) {
+		if (strcmp (company_name_string , "")) {
+			allow_save = TRUE;
+		}
+		else
+			allow_save = FALSE;
+	}
+	widget = e_builder_get_widget (ce->priv->builder, "button-ok");
+	gtk_widget_set_sensitive (widget, allow_save);
+}
+
+static void
+object_changed (GObject *object,
+                EContactEditor *editor)
+{
+	if (!editor->priv->target_editable) {
+		g_warning ("non-editable contact editor has an editable field in it.");
+		return;
+	}
+
+	if (!editor->priv->check_merge && GTK_IS_WIDGET (object)) {
+		const gchar *widget_name;
+
+		widget_name = gtk_widget_get_name (GTK_WIDGET (object));
+
+		if (widget_name &&
+		    ((g_str_equal (widget_name, "fullname")) ||
+		     (g_str_equal (widget_name, "nickname")) ||
+		     (g_str_equal (widget_name, "file-as")) ||
+		     (g_str_has_prefix (widget_name, "email-"))))
+			editor->priv->check_merge = TRUE;
+	}
+
+	if (!editor->priv->changed) {
+		editor->priv->changed = TRUE;
+		sensitize_ok (editor);
+	}
+}
+
+static void
+image_chooser_changed (GtkWidget *widget,
+                       EContactEditor *editor)
+{
+	editor->priv->image_set = TRUE;
+	editor->priv->image_changed = TRUE;
+}
+
+static void
+set_entry_text (EContactEditor *editor,
+                GtkEntry *entry,
+                const gchar *string)
+{
+	const gchar *oldstring = gtk_entry_get_text (entry);
+
+	if (!string)
+		string = "";
+
+	if (strcmp (string, oldstring)) {
+		g_signal_handlers_block_matched (
+			entry, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+		gtk_entry_set_text (entry, string);
+		g_signal_handlers_unblock_matched (
+			entry, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	}
+}
+
+static void
+init_email_record_location (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *store;
+	gint i, n_elements;
+	EContactEditorDynTable *dyntable;
+	const EABTypeLabel *email_types = eab_get_email_type_labels (&n_elements);
+
+	w = e_builder_get_widget (editor->priv->builder, "mail-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	store = e_contact_editor_dyntable_get_combo_store (dyntable);
+
+	for (i = 0; i < n_elements; i++) {
+		GtkTreeIter iter;
+
+		gtk_list_store_append (store, &iter);
+		gtk_list_store_set (store, &iter,
+		                    DYNTABLE_COMBO_COLUMN_TEXT, _(email_types[i].text),
+		                    DYNTABLE_COMBO_COLUMN_SENSITIVE, TRUE,
+		                    -1);
+	}
+
+	e_contact_editor_dyntable_set_combo_defaults (dyntable, email_default, G_N_ELEMENTS (email_default));
+}
+
+static EVCardAttributeParam *
+get_ui_slot_param (EVCardAttribute *attr)
+{
+	EVCardAttributeParam *param = NULL;
+	GList                *param_list;
+	GList                *l;
+
+	param_list = e_vcard_attribute_get_params (attr);
+
+	for (l = param_list; l; l = g_list_next (l)) {
+		const gchar *str;
+
+		param = l->data;
+
+		str = e_vcard_attribute_param_get_name (param);
+		if (!g_ascii_strcasecmp (str, EVOLUTION_UI_SLOT_PARAM))
+			break;
+
+		param = NULL;
+	}
+
+	return param;
+}
+
+static gint
+get_ui_slot (EVCardAttribute *attr)
+{
+	EVCardAttributeParam *param;
+	gint                  slot = -1;
+
+	param = get_ui_slot_param (attr);
+
+	if (param) {
+		GList *value_list;
+
+		value_list = e_vcard_attribute_param_get_values (param);
+		slot = atoi (value_list->data);
+	}
+
+	return slot;
+}
+
+static void
+set_ui_slot (EVCardAttribute *attr,
+             gint slot)
+{
+	EVCardAttributeParam *param;
+	gchar                *slot_str;
+
+	param = get_ui_slot_param (attr);
+	if (!param) {
+		param = e_vcard_attribute_param_new (EVOLUTION_UI_SLOT_PARAM);
+		e_vcard_attribute_add_param (attr, param);
+	}
+
+	e_vcard_attribute_param_remove_values (param);
+
+	slot_str = g_strdup_printf ("%d", slot);
+	e_vcard_attribute_param_add_value (param, slot_str);
+	g_free (slot_str);
+}
+
+static void
+fill_in_email (EContactEditor *editor)
+{
+	GList *email_attr_list;
+	GList *l;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeIter iter;
+
+	w = e_builder_get_widget (editor->priv->builder, "mail-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+
+	/* Clear */
+
+	e_contact_editor_dyntable_clear_data (dyntable);
+
+	/* Fill in */
+
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+
+	email_attr_list = e_contact_get_attributes (
+		editor->priv->contact, E_CONTACT_EMAIL);
+
+	for (l = email_attr_list; l; l = g_list_next (l)) {
+		EVCardAttribute *attr = l->data;
+		gchar           *email_address;
+		gint             email_location;
+		gint             slot;
+
+		email_address = e_vcard_attribute_get_value (attr);
+		email_location = eab_get_email_type_index (attr);
+		slot = get_ui_slot (attr);
+		if (slot < 1)
+			slot = EMAIL_SLOTS + 1; /* add at the end */
+
+		gtk_list_store_append (data_store, &iter);
+		gtk_list_store_set (data_store, &iter,
+		                    DYNTABLE_STORE_COLUMN_SORTORDER, slot,
+		                    DYNTABLE_STORE_COLUMN_SELECTED_ITEM, email_location,
+		                    DYNTABLE_STORE_COLUMN_ENTRY_STRING, email_address,
+		                    -1);
+
+		g_free (email_address);
+	}
+
+	g_list_free_full (email_attr_list, (GDestroyNotify) e_vcard_attribute_free);
+
+	e_contact_editor_dyntable_fill_in_data (dyntable);
+}
+
+static void
+extract_email (EContactEditor *editor)
+{
+	GList *attr_list = NULL;
+	GList *old_attr_list;
+	GList *ll;
+	gint   i;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeModel *tree_model;
+	GtkTreeIter iter;
+	gboolean valid;
+
+	w = e_builder_get_widget (editor->priv->builder, "mail-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+	tree_model = GTK_TREE_MODEL (data_store);
+
+	valid = gtk_tree_model_get_iter_first (tree_model, &iter);
+	while (valid) {
+		gchar *address = NULL;
+		gint   location;
+		EVCardAttribute *attr;
+
+		attr = e_vcard_attribute_new (
+			"", e_contact_vcard_attribute (E_CONTACT_EMAIL));
+
+		gtk_tree_model_get (tree_model,&iter,
+		                   DYNTABLE_STORE_COLUMN_SELECTED_ITEM, &location,
+		                   DYNTABLE_STORE_COLUMN_ENTRY_STRING, &address,
+		                   -1);
+
+		if (location >= 0) {
+			const gchar *type;
+			eab_email_index_to_type (location, &type);
+			e_vcard_attribute_add_param_with_value (
+				attr,
+				e_vcard_attribute_param_new (EVC_TYPE),
+				type);
+		}
+
+		e_vcard_attribute_add_value (attr, address);
+
+		attr_list = g_list_prepend (attr_list, attr);
+
+		g_free (address);
+
+		valid = gtk_tree_model_iter_next (tree_model, &iter);
+	}
+	attr_list = g_list_reverse (attr_list);
+
+	/* Splice in the old attributes, minus the EMAIL_SLOTS first */
+
+	old_attr_list = e_contact_get_attributes (editor->priv->contact, E_CONTACT_EMAIL);
+	for (ll = old_attr_list, i = 1; ll && i <= EMAIL_SLOTS; i++) {
+		e_vcard_attribute_free (ll->data);
+		ll = g_list_delete_link (ll, ll);
+	}
+
+	old_attr_list = ll;
+	attr_list = g_list_concat (attr_list, old_attr_list);
+
+	e_contact_set_attributes (editor->priv->contact, E_CONTACT_EMAIL, attr_list);
+
+	g_list_free_full (attr_list, (GDestroyNotify) e_vcard_attribute_free);
+}
+
+static void
+sensitize_email (EContactEditor *editor)
+{
+	gboolean enabled = FALSE;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	guint max_entries = SLOTS_IN_COLLAPSED_STATE;
+
+	w = e_builder_get_widget (editor->priv->builder, "mail-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+
+	if (editor->priv->target_editable) {
+		if (is_field_supported (editor, E_CONTACT_EMAIL)) {
+			enabled = TRUE;
+			max_entries = EMAIL_SLOTS;
+		} else if (is_field_supported (editor, E_CONTACT_EMAIL_4)) {
+			enabled = TRUE;
+			max_entries = 4;
+		} else if (is_field_supported (editor, E_CONTACT_EMAIL_3)) {
+			enabled = TRUE;
+			max_entries = 3;
+		} else if (is_field_supported (editor, E_CONTACT_EMAIL_2)) {
+			enabled = TRUE;
+			max_entries = 2;
+		} else if (is_field_supported (editor, E_CONTACT_EMAIL_1)) {
+			enabled = TRUE;
+			max_entries = 1;
+		}
+	}
+
+	gtk_widget_set_sensitive (w, enabled);
+	e_contact_editor_dyntable_set_max_entries (dyntable, max_entries);
+}
+
+static void
+row_added_cb (GtkExpander *expander)
+{
+	/* newly added row is always visible, setting expanded=true */
+	gtk_expander_set_expanded (expander, TRUE);
+}
+
+static void
+init_email (EContactEditor *editor)
+{
+	EContactEditorDynTable *dyntable;
+	GtkExpander *expander;
+
+	expander = GTK_EXPANDER (
+			e_builder_get_widget (editor->priv->builder, "expander-contact-email"));
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (
+			e_builder_get_widget (editor->priv->builder, "mail-dyntable"));
+
+	e_contact_editor_dyntable_set_max_entries (dyntable, EMAIL_SLOTS);
+	e_contact_editor_dyntable_set_num_columns (dyntable, SLOTS_PER_LINE, TRUE);
+	e_contact_editor_dyntable_set_show_min (dyntable, SLOTS_IN_COLLAPSED_STATE);
+
+	g_signal_connect (
+		dyntable, "changed",
+		G_CALLBACK (object_changed), editor);
+	g_signal_connect_swapped (
+		dyntable, "activate",
+		G_CALLBACK (entry_activated), editor);
+	g_signal_connect_swapped (
+		dyntable, "row-added",
+		G_CALLBACK (row_added_cb), expander);
+
+	init_email_record_location (editor);
+
+	gtk_expander_set_expanded (expander, TRUE);
+}
+
+static void
+fill_in_phone (EContactEditor *editor)
+{
+	GList *tel_attr_list;
+	GList *l;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeIter iter;
+
+	w = e_builder_get_widget (editor->priv->builder, "phone-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+
+	/* Clear */
+
+	e_contact_editor_dyntable_clear_data (dyntable);
+
+	/* Fill in */
+
+	tel_attr_list = e_contact_get_attributes (editor->priv->contact, E_CONTACT_TEL);
+
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+
+	for (l = tel_attr_list; l; l = g_list_next (l)) {
+		EVCardAttribute *attr = l->data;
+		gchar *phone;
+		gint slot;
+		gint phone_type;
+
+		slot = get_ui_slot (attr);
+		if (slot < 0)
+			slot = PHONE_SLOTS + 1; /* append at the end */
+
+		phone_type = eab_get_phone_type_index (attr);
+		phone = e_vcard_attribute_get_value (attr);
+
+		gtk_list_store_append (data_store, &iter);
+		gtk_list_store_set (data_store,&iter,
+		                   DYNTABLE_STORE_COLUMN_SORTORDER, slot,
+		                   DYNTABLE_STORE_COLUMN_SELECTED_ITEM, phone_type,
+		                   DYNTABLE_STORE_COLUMN_ENTRY_STRING, phone,
+		                   -1);
+
+		g_free (phone);
+	}
+
+	e_contact_editor_dyntable_fill_in_data (dyntable);
+
+	g_list_free_full (tel_attr_list, (GDestroyNotify) e_vcard_attribute_free);
+}
+
+static void
+extract_phone (EContactEditor *editor)
+{
+	GList *tel_attr_list = NULL;
+	GList *old_attr_list;
+	GList *ll;
+	gint i;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeModel *tree_model;
+	GtkTreeIter iter;
+	gboolean valid;
+
+	w = e_builder_get_widget (editor->priv->builder, "phone-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+	tree_model = GTK_TREE_MODEL (data_store);
+
+	valid = gtk_tree_model_get_iter_first (tree_model, &iter);
+	while (valid) {
+		gint phone_type;
+		gchar *phone = NULL;
+		EVCardAttribute *attr;
+
+		gtk_tree_model_get (tree_model,&iter,
+		                   DYNTABLE_STORE_COLUMN_SELECTED_ITEM, &phone_type,
+		                   DYNTABLE_STORE_COLUMN_ENTRY_STRING, &phone,
+		                   -1);
+
+		attr = e_vcard_attribute_new ("", EVC_TEL);
+		if (phone_type >= 0) {
+			const gchar *type_1;
+			const gchar *type_2;
+
+			eab_phone_index_to_type (phone_type, &type_1, &type_2);
+
+			e_vcard_attribute_add_param_with_value (
+				attr, e_vcard_attribute_param_new (EVC_TYPE), type_1);
+
+			if (type_2)
+				e_vcard_attribute_add_param_with_value (
+					attr, e_vcard_attribute_param_new (EVC_TYPE), type_2);
+		}
+
+		e_vcard_attribute_add_value (attr, phone);
+
+		tel_attr_list = g_list_prepend (tel_attr_list, attr);
+
+		g_free (phone);
+
+		valid = gtk_tree_model_iter_next (tree_model, &iter);
+	}
+
+	/* Splice in the old attributes, minus the PHONE_SLOTS first */
+
+	tel_attr_list = g_list_reverse (tel_attr_list);
+	old_attr_list = e_contact_get_attributes (editor->priv->contact, E_CONTACT_TEL);
+	for (ll = old_attr_list, i = 1; ll && i <= PHONE_SLOTS; i++) {
+		e_vcard_attribute_free (ll->data);
+		ll = g_list_delete_link (ll, ll);
+	}
+
+	old_attr_list = ll;
+	tel_attr_list = g_list_concat (tel_attr_list, old_attr_list);
+
+	e_contact_set_attributes (editor->priv->contact, E_CONTACT_TEL, tel_attr_list);
+
+	g_list_free_full (tel_attr_list, (GDestroyNotify) e_vcard_attribute_free);
+}
+
+static void
+init_phone_record_type (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *store;
+	gint i, n_elements;
+	EContactEditorDynTable *dyntable;
+	const EABTypeLabel *eab_phone_types;
+
+	w = e_builder_get_widget (editor->priv->builder, "phone-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	store = e_contact_editor_dyntable_get_combo_store (dyntable);
+	eab_phone_types = eab_get_phone_type_labels (&n_elements);
+
+	for (i = 0; i < n_elements; i++) {
+		GtkTreeIter iter;
+
+		gtk_list_store_append (store, &iter);
+		gtk_list_store_set (store, &iter,
+		                    DYNTABLE_COMBO_COLUMN_TEXT, _(eab_phone_types[i].text),
+		                    DYNTABLE_COMBO_COLUMN_SENSITIVE, TRUE,
+		                    -1);
+	}
+
+	e_contact_editor_dyntable_set_combo_defaults (dyntable, phones_default, G_N_ELEMENTS (phones_default));
+}
+
+static void
+init_phone (EContactEditor *editor)
+{
+	EContactEditorDynTable *dyntable;
+	GtkExpander *expander;
+
+	expander = GTK_EXPANDER (
+			e_builder_get_widget (editor->priv->builder, "expander-contact-phone"));
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (
+			e_builder_get_widget (editor->priv->builder, "phone-dyntable"));
+
+	e_contact_editor_dyntable_set_max_entries (dyntable, PHONE_SLOTS);
+	e_contact_editor_dyntable_set_num_columns (dyntable, SLOTS_PER_LINE, TRUE);
+	e_contact_editor_dyntable_set_show_min (dyntable, SLOTS_IN_COLLAPSED_STATE);
+
+	g_signal_connect (
+		dyntable, "changed",
+		G_CALLBACK (object_changed), editor);
+	g_signal_connect_swapped (
+		dyntable, "activate",
+		G_CALLBACK (entry_activated), editor);
+	g_signal_connect_swapped (
+		dyntable, "row-added",
+		G_CALLBACK (row_added_cb), expander);
+
+	init_phone_record_type (editor);
+
+	gtk_expander_set_expanded (expander, TRUE);
+}
+
+static void
+sensitize_phone_types (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *listStore;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	gint i, n_elements;
+	gboolean valid;
+	const EABTypeLabel *eab_phone_types;
+
+	w = e_builder_get_widget (editor->priv->builder, "phone-dyntable");
+	listStore = e_contact_editor_dyntable_get_combo_store (E_CONTACT_EDITOR_DYNTABLE (w));
+	model = GTK_TREE_MODEL (listStore);
+
+	valid = gtk_tree_model_get_iter_first (model, &iter);
+
+	eab_phone_types = eab_get_phone_type_labels (&n_elements);
+	for (i = 0; i < n_elements; i++) {
+		if (!valid) {
+			g_warning (G_STRLOC ": Unexpected end of phone items in combo box");
+			return;
+		}
+
+		gtk_list_store_set (GTK_LIST_STORE (model), &iter,
+		                    DYNTABLE_COMBO_COLUMN_SENSITIVE,
+		                    is_field_supported (editor, eab_phone_types[i].field_id),
+		                    -1);
+
+		valid = gtk_tree_model_iter_next (model, &iter);
+	}
+}
+
+static void
+sensitize_phone (EContactEditor *editor)
+{
+	GtkWidget *w;
+	gboolean enabled = FALSE;
+	gint i, n_elements;
+	const EABTypeLabel *eab_phone_types;
+
+	w = e_builder_get_widget (editor->priv->builder, "phone-dyntable");
+
+	eab_phone_types = eab_get_phone_type_labels (&n_elements);
+	if (editor->priv->target_editable) {
+		enabled = is_field_supported (editor, E_CONTACT_TEL);
+		for (i = 0; i < n_elements && !enabled; i++) {
+			enabled = is_field_supported (editor, eab_phone_types[i].field_id);
+		}
+	}
+
+	gtk_widget_set_sensitive (w, enabled);
+
+	sensitize_phone_types (editor);
+}
+
+static void
+fill_in_sip (EContactEditor *editor)
+{
+	GList *sip_attr_list;
+	GList *l;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeIter iter;
+
+	w = e_builder_get_widget (editor->priv->builder, "sip-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+
+	/* Clear */
+
+	e_contact_editor_dyntable_clear_data (dyntable);
+
+	/* Fill in */
+
+	sip_attr_list = e_contact_get_attributes (editor->priv->contact, E_CONTACT_SIP);
+
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+
+	for (l = sip_attr_list; l; l = g_list_next (l)) {
+		EVCardAttribute *attr = l->data;
+		gchar *sip;
+		gint sip_type;
+
+		sip_type = eab_get_sip_type_index (attr);
+		sip = e_vcard_attribute_get_value (attr);
+
+		if (sip_type < 0)
+			sip_type = 2;
+
+		gtk_list_store_append (data_store, &iter);
+		gtk_list_store_set (data_store,&iter,
+		                   DYNTABLE_STORE_COLUMN_SORTORDER, -1,
+		                   DYNTABLE_STORE_COLUMN_SELECTED_ITEM, sip_type,
+		                   DYNTABLE_STORE_COLUMN_ENTRY_STRING, sip,
+		                   -1);
+
+		g_free (sip);
+	}
+
+	e_contact_editor_dyntable_fill_in_data (dyntable);
+	g_list_free_full (sip_attr_list, (GDestroyNotify) e_vcard_attribute_free);
+}
+
+static void
+extract_sip (EContactEditor *editor)
+{
+	GList *sip_attr_list = NULL;
+	GList *old_attr_list;
+	GList *ll;
+	gint i;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeModel *tree_model;
+	GtkTreeIter iter;
+	gboolean valid;
+
+	w = e_builder_get_widget (editor->priv->builder, "sip-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+	tree_model = GTK_TREE_MODEL (data_store);
+
+	valid = gtk_tree_model_get_iter_first (tree_model, &iter);
+	while (valid) {
+		gint sip_type;
+		gchar *sip = NULL;
+		EVCardAttribute *attr;
+
+		gtk_tree_model_get (tree_model,&iter,
+		                   DYNTABLE_STORE_COLUMN_SELECTED_ITEM, &sip_type,
+		                   DYNTABLE_STORE_COLUMN_ENTRY_STRING, &sip,
+		                   -1);
+
+		attr = e_vcard_attribute_new ("", EVC_X_SIP);
+		if (sip_type >= 0) {
+			const gchar *type_1;
+
+			eab_sip_index_to_type (sip_type, &type_1);
+
+			e_vcard_attribute_add_param_with_value (
+				attr, e_vcard_attribute_param_new (EVC_TYPE), type_1);
+		}
+
+		e_vcard_attribute_add_value (attr, sip);
+
+		sip_attr_list = g_list_prepend (sip_attr_list, attr);
+
+		g_free (sip);
+
+		valid = gtk_tree_model_iter_next (tree_model, &iter);
+	}
+
+	/* Splice in the old attributes, minus the SIP_SLOTS first */
+
+	sip_attr_list = g_list_reverse (sip_attr_list);
+	old_attr_list = e_contact_get_attributes (editor->priv->contact, E_CONTACT_SIP);
+	for (ll = old_attr_list, i = 1; ll && i <= SIP_SLOTS; i++) {
+		e_vcard_attribute_free (ll->data);
+		ll = g_list_delete_link (ll, ll);
+	}
+
+	old_attr_list = ll;
+	sip_attr_list = g_list_concat (sip_attr_list, old_attr_list);
+
+	e_contact_set_attributes (editor->priv->contact, E_CONTACT_SIP, sip_attr_list);
+
+	g_list_free_full (sip_attr_list, (GDestroyNotify) e_vcard_attribute_free);
+}
+
+static void
+init_sip_record_type (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *store;
+	gint i, n_elements;
+	EContactEditorDynTable *dyntable;
+	const EABTypeLabel *sip_types = eab_get_sip_type_labels (&n_elements);
+
+	w = e_builder_get_widget (editor->priv->builder, "sip-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	store = e_contact_editor_dyntable_get_combo_store (dyntable);
+
+	for (i = 0; i < n_elements; i++) {
+		GtkTreeIter iter;
+
+		gtk_list_store_append (store, &iter);
+		gtk_list_store_set (store, &iter,
+		                    DYNTABLE_COMBO_COLUMN_TEXT, _(sip_types[i].text),
+		                    DYNTABLE_COMBO_COLUMN_SENSITIVE, TRUE,
+		                    -1);
+	}
+
+	e_contact_editor_dyntable_set_combo_defaults (dyntable, sips_default, G_N_ELEMENTS (sips_default));
+}
+
+static void
+init_sip (EContactEditor *editor)
+{
+	EContactEditorDynTable *dyntable;
+	GtkExpander *expander;
+
+	expander = GTK_EXPANDER (
+			e_builder_get_widget (editor->priv->builder, "expander-contact-sip"));
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (
+			e_builder_get_widget (editor->priv->builder, "sip-dyntable"));
+
+	e_contact_editor_dyntable_set_max_entries (dyntable, SIP_SLOTS);
+	e_contact_editor_dyntable_set_num_columns (dyntable, SLOTS_PER_LINE, TRUE);
+	e_contact_editor_dyntable_set_show_min (dyntable, SLOTS_IN_COLLAPSED_STATE);
+
+	g_signal_connect (
+		dyntable, "changed",
+		G_CALLBACK (object_changed), editor);
+	g_signal_connect_swapped (
+		dyntable, "activate",
+		G_CALLBACK (entry_activated), editor);
+	g_signal_connect_swapped (
+		dyntable, "row-added",
+		G_CALLBACK (row_added_cb), expander);
+
+	init_sip_record_type (editor);
+
+	gtk_expander_set_expanded (expander, TRUE);
+}
+
+static gboolean
+check_dyntable_for_data (EContactEditor *editor,
+                         const gchar *name)
+{
+	EContactEditorDynTable *dyntable;
+	GtkTreeModel *tree_model;
+	GtkTreeIter iter;
+
+	dyntable   = E_CONTACT_EDITOR_DYNTABLE (e_builder_get_widget (editor->priv->builder, name));
+	tree_model = GTK_TREE_MODEL (e_contact_editor_dyntable_extract_data (dyntable));
+
+	return gtk_tree_model_get_iter_first (tree_model, &iter);
+}
+
+static void
+extract_address_textview (EContactEditor *editor,
+                          gint record,
+                          EContactAddress *address)
+{
+	gchar         *textview_name;
+	GtkWidget     *textview;
+	GtkTextBuffer *text_buffer;
+	GtkTextIter    iter_1, iter_2;
+
+	textview_name = g_strdup_printf ("textview-%s-address", address_name[record]);
+	textview = e_builder_get_widget (editor->priv->builder, textview_name);
+	g_free (textview_name);
+
+	text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (textview));
+	gtk_text_buffer_get_start_iter (text_buffer, &iter_1);
+
+	/* Skip blank lines */
+	while (gtk_text_iter_get_chars_in_line (&iter_1) < 1 &&
+	       !gtk_text_iter_is_end (&iter_1))
+		gtk_text_iter_forward_line (&iter_1);
+
+	if (gtk_text_iter_is_end (&iter_1))
+		return;
+
+	iter_2 = iter_1;
+	gtk_text_iter_forward_to_line_end (&iter_2);
+
+	/* Extract street (first line of text) */
+	address->street = gtk_text_iter_get_text (&iter_1, &iter_2);
+
+	iter_1 = iter_2;
+	gtk_text_iter_forward_line (&iter_1);
+
+	if (gtk_text_iter_is_end (&iter_1))
+		return;
+
+	gtk_text_iter_forward_to_end (&iter_2);
+
+	/* Extract extended address (remaining lines of text) */
+	address->ext = gtk_text_iter_get_text (&iter_1, &iter_2);
+}
+
+static gchar *
+extract_address_field (EContactEditor *editor,
+                       gint record,
+                       const gchar *widget_field_name)
+{
+	gchar     *entry_name;
+	GtkWidget *entry;
+
+	entry_name = g_strdup_printf (
+		"entry-%s-%s", address_name[record], widget_field_name);
+	entry = e_builder_get_widget (editor->priv->builder, entry_name);
+	g_free (entry_name);
+
+	return g_strdup (gtk_entry_get_text (GTK_ENTRY (entry)));
+}
+
+static void
+extract_address_from_gui (EContactEditor* editor,
+                          EContactAddress* address,
+                          gint record)
+{
+	extract_address_textview (editor, record, address);
+	address->locality = extract_address_field (editor, record, "city");
+	address->region = extract_address_field (editor, record, "state");
+	address->code = extract_address_field (editor, record, "zip");
+	address->country = extract_address_field (editor, record, "country");
+	address->po = extract_address_field (editor, record, "pobox");
+}
+
+static gboolean
+check_address_for_data (EContactEditor *editor,
+                        gint record)
+{
+	gboolean has_data = FALSE;
+	EContactAddress *address;
+
+	address = e_contact_address_new ();
+
+	extract_address_from_gui (editor, address, record);
+	if (!STRING_IS_EMPTY (address->street)   ||
+	    !STRING_IS_EMPTY (address->ext)      ||
+	    !STRING_IS_EMPTY (address->locality) ||
+	    !STRING_IS_EMPTY (address->region)   ||
+	    !STRING_IS_EMPTY (address->code)     ||
+	    !STRING_IS_EMPTY (address->po)       ||
+	    !STRING_IS_EMPTY (address->country)) {
+		has_data = TRUE;
+	}
+
+	e_contact_address_free (address);
+
+	return has_data;
+}
+
+static gboolean
+check_web_for_data (EContactEditor *editor)
+{
+	GtkBuilder *b = editor->priv->builder;
+
+	return  !STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-homepage")))) ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-weblog"))))   ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-caluri"))))   ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-fburl"))))    ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-videourl")))) ;
+}
+
+static gboolean
+check_job_for_data (EContactEditor *editor)
+{
+	GtkBuilder *b = editor->priv->builder;
+
+	return  !STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-manager"))))    ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-assistant"))))  ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-profession")))) ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-jobtitle"))))   ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-company"))))    ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-department")))) ||
+		!STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-office"))));
+}
+
+static gboolean
+check_misc_for_data (EContactEditor *editor)
+{
+	GtkBuilder *b = editor->priv->builder;
+	gint year, month, day;
+
+	return  !STRING_IS_EMPTY (gtk_entry_get_text (GTK_ENTRY (e_builder_get_widget (b, "entry-spouse")))) ||
+		e_date_edit_get_date (E_DATE_EDIT (e_builder_get_widget (b, "dateedit-birthday")), &year, &month, &day) ||
+		e_date_edit_get_date (E_DATE_EDIT (e_builder_get_widget (b, "dateedit-anniversary")), &year, &month, &day);
+}
+
+static gboolean
+check_notes_for_data (EContactEditor *editor)
+{
+	GtkWidget *tv = e_builder_get_widget (editor->priv->builder, "text-comments");
+	GtkTextBuffer *buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (tv));
+
+	return gtk_text_buffer_get_char_count (buffer) > 0;
+}
+
+static gboolean
+check_certs_for_data (EContactEditor *editor)
+{
+	GtkWidget *treeview = e_builder_get_widget (editor->priv->builder, "certs-treeview");
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (treeview));
+	return model && gtk_tree_model_get_iter_first (model, &iter);
+}
+
+static gboolean
+check_section_for_data (EContactEditor *editor,
+                        gint check)
+{
+	gboolean has_data = TRUE;
+
+	switch (check) {
+	case CHECK_PHONE:
+		has_data = check_dyntable_for_data (editor, "phone-dyntable");
+		break;
+	case CHECK_SIP:
+		has_data = check_dyntable_for_data (editor, "sip-dyntable");
+		break;
+	case CHECK_IM:
+		has_data = check_dyntable_for_data (editor, "im-dyntable");
+		break;
+	case CHECK_HOME:
+		has_data = check_address_for_data (editor, ADDRESS_SLOT_HOME);
+		break;
+	case CHECK_WORK:
+		has_data = check_address_for_data (editor, ADDRESS_SLOT_WORK);
+		break;
+	case CHECK_OTHER:
+		has_data = check_address_for_data (editor, ADDRESS_SLOT_OTHER);
+		break;
+	case CHECK_WEB:
+		has_data = check_web_for_data (editor);
+		break;
+	case CHECK_JOB:
+		has_data = check_job_for_data (editor);
+		break;
+	case CHECK_MISC:
+		has_data = check_misc_for_data (editor);
+		break;
+	case CHECK_NOTE:
+		has_data = check_notes_for_data (editor);
+		break;
+	case CHECK_CERTS:
+		has_data = check_certs_for_data (editor);
+		break;
+	default:
+		g_warning ("unknown data check requested");
+	}
+
+	return has_data;
+}
+
+static void
+config_sensitize_item (EContactEditor *editor,
+                       const gchar *item_name,
+                       gint check)
+{
+	GtkWidget *item;
+	gboolean has_data;
+
+	has_data = check_section_for_data (editor, check);
+	item     = e_builder_get_widget (editor->priv->builder, item_name);
+
+	if (has_data) {
+		gtk_widget_set_sensitive (item, FALSE);
+		gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), TRUE);
+	} else {
+		gtk_widget_set_sensitive (item, TRUE);
+	}
+}
+
+static void
+config_sensitize_cb (GtkWidget *button,
+                     EContactEditor *editor)
+{
+	config_sensitize_item (editor, "menuitem-config-phone", CHECK_PHONE);
+	config_sensitize_item (editor, "menuitem-config-sip", CHECK_SIP);
+	config_sensitize_item (editor, "menuitem-config-im", CHECK_IM);
+
+	config_sensitize_item (editor, "menuitem-config-web", CHECK_WEB);
+	config_sensitize_item (editor, "menuitem-config-job", CHECK_JOB);
+	config_sensitize_item (editor, "menuitem-config-misc", CHECK_MISC);
+
+	config_sensitize_item (editor, "menuitem-config-home", CHECK_HOME);
+	config_sensitize_item (editor, "menuitem-config-work", CHECK_WORK);
+	config_sensitize_item (editor, "menuitem-config-other", CHECK_OTHER);
+
+	config_sensitize_item (editor, "menuitem-config-notes", CHECK_NOTE);
+	config_sensitize_item (editor, "menuitem-config-certs", CHECK_CERTS);
+}
+
+/*
+ * get the value from GSettings and check if there is data in the widget.
+ * if no data is found set_visible (value), set_visible (true) otherwise
+ *
+ * Returns: the new visibility
+ */
+static gboolean
+configure_widget_visibility (EContactEditor *editor,
+                             GSettings *settings,
+                             const gchar *widget_name,
+                             const gchar *settings_name,
+                             gint check)
+{
+	gboolean  config, has_data;
+	GtkWidget *widget;
+
+	config = g_settings_get_boolean (settings, settings_name);
+	widget = e_builder_get_widget (editor->priv->builder, widget_name);
+	has_data = check_section_for_data (editor, check);
+
+	gtk_widget_set_visible (widget, config || has_data);
+
+	return config || has_data;
+}
+
+static void
+configure_visibility (EContactEditor *editor)
+{
+	gboolean show_tab;
+	GSettings *settings = e_util_ref_settings ("org.gnome.evolution.addressbook");
+
+	configure_widget_visibility (editor, settings, "vbox-contact-phone", "editor-show-contact-phone", CHECK_PHONE);
+	configure_widget_visibility (editor, settings, "vbox-contact-sip",   "editor-show-contact-sip",   CHECK_SIP);
+	configure_widget_visibility (editor, settings, "vbox-contact-im",    "editor-show-contact-im",    CHECK_IM);
+
+	show_tab  = configure_widget_visibility (editor, settings, "frame-mailing-home",     "editor-show-mailing-home",  CHECK_HOME);
+	show_tab |= configure_widget_visibility (editor, settings, "frame-mailing-work",     "editor-show-mailing-work",  CHECK_WORK);
+	show_tab |= configure_widget_visibility (editor, settings, "expander-address-other", "editor-show-mailing-other", CHECK_OTHER);
+	gtk_widget_set_visible (
+			e_builder_get_widget (editor->priv->builder, "scrolledwindow-mailing"),
+			show_tab);
+
+	show_tab  = configure_widget_visibility (editor, settings, "expander-personal-web",  "editor-show-personal-web",  CHECK_WEB);
+	show_tab |= configure_widget_visibility (editor, settings, "expander-personal-job",  "editor-show-personal-job",  CHECK_JOB);
+	show_tab |= configure_widget_visibility (editor, settings, "expander-personal-misc", "editor-show-personal-misc", CHECK_MISC);
+	gtk_widget_set_visible (
+			e_builder_get_widget (editor->priv->builder, "scrolledwindow-personal"),
+			show_tab);
+
+	configure_widget_visibility (editor, settings, "scrolledwindow-notes", "editor-show-notes", CHECK_NOTE);
+	configure_widget_visibility (editor, settings, "certs-grid", "editor-show-certs", CHECK_CERTS);
+
+	g_object_unref (settings);
+}
+
+static void
+config_menuitem_save (EContactEditor *editor,
+                      GSettings *settings,
+                      const gchar *item_name,
+                      const gchar *key)
+{
+	GtkWidget *item;
+	gboolean active, sensitive;
+
+	item      = e_builder_get_widget (editor->priv->builder, item_name);
+	active    = gtk_check_menu_item_get_active (GTK_CHECK_MENU_ITEM (item));
+	sensitive = gtk_widget_get_sensitive (item);
+
+	if (sensitive)
+		g_settings_set_boolean (settings, key, active);
+}
+
+static void
+config_save_cb (GtkWidget *button,
+                EContactEditor *editor)
+{
+	GSettings *settings;
+
+	settings = e_util_ref_settings ("org.gnome.evolution.addressbook");
+
+	config_menuitem_save (editor, settings, "menuitem-config-phone", "editor-show-contact-phone");
+	config_menuitem_save (editor, settings, "menuitem-config-sip",   "editor-show-contact-sip");
+	config_menuitem_save (editor, settings, "menuitem-config-im",    "editor-show-contact-im");
+
+	config_menuitem_save (editor, settings, "menuitem-config-web",   "editor-show-personal-web");
+	config_menuitem_save (editor, settings, "menuitem-config-job",   "editor-show-personal-job");
+	config_menuitem_save (editor, settings, "menuitem-config-misc",  "editor-show-personal-misc");
+
+	config_menuitem_save (editor, settings, "menuitem-config-home",  "editor-show-mailing-home");
+	config_menuitem_save (editor, settings, "menuitem-config-work",  "editor-show-mailing-work");
+	config_menuitem_save (editor, settings, "menuitem-config-other", "editor-show-mailing-other");
+
+	config_menuitem_save (editor, settings, "menuitem-config-notes", "editor-show-notes");
+	config_menuitem_save (editor, settings, "menuitem-config-certs", "editor-show-certs");
+
+	g_object_unref (settings);
+
+	configure_visibility (editor);
+}
+
+static void
+init_config_menuitem (EContactEditor *editor,
+                      GSettings *settings,
+                      const gchar *item_name,
+                      const gchar *key)
+{
+	gboolean show;
+	GtkWidget *item;
+
+	show = g_settings_get_boolean (settings, key);
+	item = e_builder_get_widget (editor->priv->builder, item_name);
+	gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), show);
+
+	g_signal_connect (
+		item, "activate",
+		G_CALLBACK (config_save_cb), editor);
+}
+
+static void
+init_config (EContactEditor *editor)
+{
+	GtkWidget *button, *menu;
+	GSettings *settings;
+
+	button = e_builder_get_widget (editor->priv->builder, "button-config");
+	menu   = e_builder_get_widget (editor->priv->builder, "menu-editor-config");
+	gtk_menu_button_set_popup (GTK_MENU_BUTTON (button), menu);
+
+	/* save resources by only doing the data checks and sensitizing upon request,
+	 * instead of doing it with each change in object_changed()
+	 */
+	g_signal_connect (
+		button, "clicked",
+		G_CALLBACK (config_sensitize_cb), editor);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.addressbook");
+
+	init_config_menuitem (editor, settings, "menuitem-config-phone", "editor-show-contact-phone");
+	init_config_menuitem (editor, settings, "menuitem-config-sip",   "editor-show-contact-sip");
+	init_config_menuitem (editor, settings, "menuitem-config-im",    "editor-show-contact-im");
+
+	init_config_menuitem (editor, settings, "menuitem-config-web",   "editor-show-personal-web");
+	init_config_menuitem (editor, settings, "menuitem-config-job",   "editor-show-personal-job");
+	init_config_menuitem (editor, settings, "menuitem-config-misc",  "editor-show-personal-misc");
+
+	init_config_menuitem (editor, settings, "menuitem-config-home",  "editor-show-mailing-home");
+	init_config_menuitem (editor, settings, "menuitem-config-work",  "editor-show-mailing-work");
+	init_config_menuitem (editor, settings, "menuitem-config-other", "editor-show-mailing-other");
+
+	init_config_menuitem (editor, settings, "menuitem-config-notes", "editor-show-notes");
+	init_config_menuitem (editor, settings, "menuitem-config-certs", "editor-show-certs");
+
+	g_object_unref (settings);
+}
+
+static void
+sensitize_sip_types (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *listStore;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	gint i, n_elements;
+	gboolean valid;
+	const EABTypeLabel *sip_types = eab_get_sip_type_labels (&n_elements);
+
+	w = e_builder_get_widget (editor->priv->builder, "sip-dyntable");
+	listStore = e_contact_editor_dyntable_get_combo_store (E_CONTACT_EDITOR_DYNTABLE (w));
+	model = GTK_TREE_MODEL (listStore);
+
+	valid = gtk_tree_model_get_iter_first (model, &iter);
+
+	for (i = 0; i < n_elements; i++) {
+		if (!valid) {
+			g_warning (G_STRLOC ": Unexpected end of sip items in combo box");
+			return;
+		}
+
+		gtk_list_store_set (GTK_LIST_STORE (model), &iter,
+		                    DYNTABLE_COMBO_COLUMN_SENSITIVE,
+		                    is_field_supported (editor, sip_types[i].field_id),
+		                    -1);
+
+		valid = gtk_tree_model_iter_next (model, &iter);
+	}
+}
+
+static void
+sensitize_sip (EContactEditor *editor)
+{
+	GtkWidget *w;
+	gboolean enabled = TRUE;
+
+	w = e_builder_get_widget (editor->priv->builder, "sip-dyntable");
+
+	if (!editor->priv->target_editable ||
+	    !is_field_supported (editor, E_CONTACT_SIP))
+		enabled = FALSE;
+
+	gtk_widget_set_sensitive (w, enabled);
+
+	sensitize_sip_types (editor);
+}
+
+static void
+init_im_record_type (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *store;
+	gint i, n_elements;
+	EContactEditorDynTable *dyntable;
+	const EABTypeLabel *im_service;
+
+	w = e_builder_get_widget (editor->priv->builder, "im-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	store = e_contact_editor_dyntable_get_combo_store (dyntable);
+
+	im_service = eab_get_im_type_labels (&n_elements);
+	for (i = 0; i < n_elements; i++) {
+		GtkTreeIter iter;
+
+		gtk_list_store_append (store, &iter);
+		gtk_list_store_set (store, &iter,
+		                    DYNTABLE_COMBO_COLUMN_TEXT, _(im_service[i].text),
+		                    DYNTABLE_COMBO_COLUMN_SENSITIVE, TRUE,
+		                    -1);
+	}
+
+	e_contact_editor_dyntable_set_combo_defaults (dyntable, im_service_default, G_N_ELEMENTS (im_service_default));
+}
+
+static void
+init_im (EContactEditor *editor)
+{
+	EContactEditorDynTable *dyntable;
+	GtkExpander *expander;
+
+	expander = GTK_EXPANDER (
+			e_builder_get_widget (editor->priv->builder, "expander-contact-im"));
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (
+			e_builder_get_widget (editor->priv->builder, "im-dyntable"));
+
+	e_contact_editor_dyntable_set_max_entries (dyntable, IM_SLOTS);
+	e_contact_editor_dyntable_set_num_columns (dyntable, SLOTS_PER_LINE, TRUE);
+	e_contact_editor_dyntable_set_show_min (dyntable, SLOTS_IN_COLLAPSED_STATE);
+
+	g_signal_connect (
+		dyntable, "changed",
+		G_CALLBACK (object_changed), editor);
+	g_signal_connect_swapped (
+		dyntable, "activate",
+		G_CALLBACK (entry_activated), editor);
+	g_signal_connect_swapped (
+		dyntable, "row-added",
+		G_CALLBACK (row_added_cb), expander);
+
+	init_im_record_type (editor);
+
+	gtk_expander_set_expanded (expander, TRUE);
+}
+
+static void
+fill_in_im (EContactEditor *editor)
+{
+	GList *im_attr_list;
+	GList *l;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeIter iter;
+
+	w = e_builder_get_widget (editor->priv->builder, "im-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+
+	/* Clear */
+
+	e_contact_editor_dyntable_clear_data (dyntable);
+
+	/* Fill in */
+
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+
+	im_attr_list = e_contact_get_attributes_set (
+			editor->priv->contact,
+			im_service_fetch_set,
+			G_N_ELEMENTS (im_service_fetch_set)
+			);
+
+	for (l = im_attr_list; l; l = g_list_next(l)) {
+		EVCardAttribute *attr = l->data;
+		gchar *im_name;
+		gint   service_type;
+		gint   slot;
+
+		im_name = e_vcard_attribute_get_value (attr);
+		service_type = eab_get_im_type_index (attr);
+
+		slot = get_ui_slot (attr);
+		if (slot < 0)
+			slot = IM_SLOTS + 1; /* attach at the end */
+
+		gtk_list_store_append (data_store, &iter);
+		gtk_list_store_set (data_store, &iter,
+		                    DYNTABLE_STORE_COLUMN_SORTORDER, slot,
+		                    DYNTABLE_STORE_COLUMN_SELECTED_ITEM, service_type,
+		                    DYNTABLE_STORE_COLUMN_ENTRY_STRING, im_name,
+		                    -1);
+
+		g_free (im_name);
+	}
+
+	g_list_free_full (im_attr_list, (GDestroyNotify) e_vcard_attribute_free);
+
+	e_contact_editor_dyntable_fill_in_data (dyntable);
+}
+
+static void
+extract_im (EContactEditor *editor)
+{
+	GList *attr_list = NULL;
+	GList *old_attr_list = NULL;
+	GList *ll;
+	gint ii;
+	GtkWidget *w;
+	EContactEditorDynTable *dyntable;
+	GtkListStore *data_store;
+	GtkTreeModel *tree_model;
+	GtkTreeIter iter;
+	gboolean valid;
+
+	w = e_builder_get_widget (editor->priv->builder, "im-dyntable");
+	dyntable = E_CONTACT_EDITOR_DYNTABLE (w);
+	data_store = e_contact_editor_dyntable_extract_data (dyntable);
+	tree_model = GTK_TREE_MODEL (data_store);
+
+	valid = gtk_tree_model_get_iter_first (tree_model, &iter);
+	while (valid) {
+		gint             service_type;
+		gint             slot;
+		gchar           *im_name = NULL;
+		EVCardAttribute *attr;
+		const EABTypeLabel *im_service = eab_get_im_type_labels (&service_type);
+
+		gtk_tree_model_get (tree_model,&iter,
+		                   DYNTABLE_STORE_COLUMN_SORTORDER, &slot,
+		                   DYNTABLE_STORE_COLUMN_SELECTED_ITEM, &service_type,
+		                   DYNTABLE_STORE_COLUMN_ENTRY_STRING, &im_name,
+		                   -1);
+
+		attr = e_vcard_attribute_new ("",
+				e_contact_vcard_attribute (
+				im_service[service_type].field_id));
+
+		/* older evolution versions (<=3.12) will crash if SLOT>4 is stored,
+		 * but if we don't store the slot we loose sortorder.
+		 * this works only for <=4 IM slots. for more, old evolution
+		 * will go through types (AIM, Jabber, ...) and stop after 4
+		 * no matter what x-evo-slot says.
+		 */
+		if (slot < 4)
+			set_ui_slot (attr, slot + 1);
+
+		e_vcard_attribute_add_value (attr, im_name);
+
+		attr_list = g_list_prepend (attr_list, attr);
+
+		g_free (im_name);
+
+		valid = gtk_tree_model_iter_next (tree_model, &iter);
+	}
+	attr_list = g_list_reverse (attr_list);
+
+	/* Splice in the old attributes, minus the IM_SLOTS first */
+
+	old_attr_list = e_contact_get_attributes_set (
+			editor->priv->contact,
+			im_service_fetch_set,
+			G_N_ELEMENTS (im_service_fetch_set)
+			);
+	for (ll = old_attr_list, ii = 0; ll && ii < IM_SLOTS; ii++) {
+		e_vcard_attribute_free (ll->data);
+		ll = g_list_delete_link (ll, ll);
+	}
+
+	old_attr_list = ll;
+	attr_list = g_list_concat (attr_list, old_attr_list);
+
+	for (ii = 0; ii < G_N_ELEMENTS (im_service_fetch_set); ii++) {
+		e_contact_set_attributes (editor->priv->contact, im_service_fetch_set[ii], NULL);
+	}
+
+	for (ll = attr_list; ll; ll = ll->next) {
+		EVCard *vcard;
+		vcard = E_VCARD (editor->priv->contact);
+		e_vcard_append_attribute (vcard, e_vcard_attribute_copy ((EVCardAttribute *) ll->data));
+	}
+
+	g_list_free_full (attr_list, (GDestroyNotify) e_vcard_attribute_free);
+}
+
+static void
+sensitize_im_types (EContactEditor *editor)
+{
+	GtkWidget *w;
+	GtkListStore *list_store;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	gint i, n_elements;
+	gboolean valid;
+	const EABTypeLabel *im_service = eab_get_im_type_labels (&n_elements);
+
+	w = e_builder_get_widget (editor->priv->builder, "im-dyntable");
+	list_store = e_contact_editor_dyntable_get_combo_store (E_CONTACT_EDITOR_DYNTABLE (w));
+	model = GTK_TREE_MODEL (list_store);
+
+	valid = gtk_tree_model_get_iter_first (model, &iter);
+
+	for (i = 0; i < n_elements; i++) {
+		if (!valid) {
+			g_warning (G_STRLOC ": Unexpected end of im items in combo box");
+			return;
+		}
+
+		gtk_list_store_set (
+			GTK_LIST_STORE (model), &iter,
+			DYNTABLE_COMBO_COLUMN_SENSITIVE,
+			is_field_supported (editor, im_service[i].field_id),
+			-1);
+
+		valid = gtk_tree_model_iter_next (model, &iter);
+	}
+}
+
+static void
+sensitize_im (EContactEditor *editor)
+{
+	gint i, n_elements;
+	gboolean enabled;
+	gboolean no_ims_supported;
+	GtkWidget *w;
+	const EABTypeLabel *im_service = eab_get_im_type_labels (&n_elements);
+
+	enabled = editor->priv->target_editable;
+	no_ims_supported = TRUE;
+
+	for (i = 0; i < n_elements; i++)
+		if (is_field_supported (editor, im_service[i].field_id)) {
+			no_ims_supported = FALSE;
+			break;
+		}
+
+	if (no_ims_supported)
+		enabled = FALSE;
+
+	w = e_builder_get_widget (editor->priv->builder, "im-dyntable");
+	gtk_widget_set_sensitive (w, enabled);
+
+	sensitize_im_types (editor);
+}
+
+static void
+init_address_textview (EContactEditor *editor,
+                       gint record)
+{
+	gchar *textview_name;
+	GtkWidget *textview;
+	GtkTextBuffer *text_buffer;
+
+	textview_name = g_strdup_printf (
+		"textview-%s-address", address_name[record]);
+	textview = e_builder_get_widget (editor->priv->builder, textview_name);
+	g_free (textview_name);
+
+	text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (textview));
+
+	g_signal_connect (
+		text_buffer, "changed",
+		G_CALLBACK (object_changed), editor);
+}
+
+static void
+init_address_field (EContactEditor *editor,
+                    gint record,
+                    const gchar *widget_field_name)
+{
+	gchar *entry_name;
+	GtkWidget *entry;
+
+	entry_name = g_strdup_printf (
+		"entry-%s-%s", address_name[record], widget_field_name);
+	entry = e_builder_get_widget (editor->priv->builder, entry_name);
+	g_free (entry_name);
+
+	g_signal_connect (
+		entry, "changed",
+		G_CALLBACK (object_changed), editor);
+	g_signal_connect_swapped (
+		entry, "activate",
+		G_CALLBACK (entry_activated), editor);
+}
+
+static void
+init_address_record (EContactEditor *editor,
+                     gint record)
+{
+	init_address_textview (editor, record);
+	init_address_field (editor, record, "city");
+	init_address_field (editor, record, "state");
+	init_address_field (editor, record, "zip");
+	init_address_field (editor, record, "country");
+	init_address_field (editor, record, "pobox");
+}
+
+static void
+init_address (EContactEditor *editor)
+{
+	gint i;
+
+	for (i = 0; i < ADDRESS_SLOTS; i++)
+		init_address_record (editor, i);
+
+	gtk_expander_set_expanded (
+				GTK_EXPANDER (e_builder_get_widget (editor->priv->builder, "expander-address-other")),
+				!editor->priv->compress_ui);
+}
+
+static void
+fill_in_address_textview (EContactEditor *editor,
+                          gint record,
+                          EContactAddress *address)
+{
+	gchar         *textview_name;
+	GtkWidget     *textview;
+	GtkTextBuffer *text_buffer;
+	GtkTextIter    iter_end, iter_start;
+
+	textview_name = g_strdup_printf ("textview-%s-address", address_name[record]);
+	textview = e_builder_get_widget (editor->priv->builder, textview_name);
+	g_free (textview_name);
+
+	text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (textview));
+	gtk_text_buffer_set_text (text_buffer, address->street ? address->street : "", -1);
+
+	gtk_text_buffer_get_end_iter (text_buffer, &iter_end);
+	if (address->ext && *address->ext) {
+		gtk_text_buffer_insert (text_buffer, &iter_end, "\n", -1);
+		gtk_text_buffer_insert (text_buffer, &iter_end, address->ext, -1);
+	} else {
+		gtk_text_buffer_insert (text_buffer, &iter_end, "", -1);
+	}
+	gtk_text_buffer_get_iter_at_line (text_buffer, &iter_start, 0);
+	gtk_text_buffer_place_cursor (text_buffer, &iter_start);
+}
+
+static void
+fill_in_address_label_textview (EContactEditor *editor,
+                                gint record,
+                                const gchar *label)
+{
+	gchar         *textview_name;
+	GtkWidget     *textview;
+	GtkTextBuffer *text_buffer;
+
+	textview_name = g_strdup_printf (
+		"textview-%s-address", address_name[record]);
+	textview = e_builder_get_widget (editor->priv->builder, textview_name);
+	g_free (textview_name);
+
+	text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (textview));
+	gtk_text_buffer_set_text (text_buffer, label ? label : "", -1);
+}
+
+static void
+fill_in_address_field (EContactEditor *editor,
+                       gint record,
+                       const gchar *widget_field_name,
+                       const gchar *string)
+{
+	gchar     *entry_name;
+	GtkWidget *entry;
+
+	entry_name = g_strdup_printf (
+		"entry-%s-%s", address_name[record], widget_field_name);
+	entry = e_builder_get_widget (editor->priv->builder, entry_name);
+	g_free (entry_name);
+
+	set_entry_text (editor, GTK_ENTRY (entry), string);
+}
+
+static void
+fill_in_address_record (EContactEditor *editor,
+                        gint record)
+{
+	EContactAddress *address;
+	gchar           *address_label;
+
+	address = e_contact_get (editor->priv->contact, addresses[record]);
+	address_label = e_contact_get (editor->priv->contact, address_labels[record]);
+
+	if (address &&
+	    (!STRING_IS_EMPTY (address->street)   ||
+	     !STRING_IS_EMPTY (address->ext)      ||
+	     !STRING_IS_EMPTY (address->locality) ||
+	     !STRING_IS_EMPTY (address->region)   ||
+	     !STRING_IS_EMPTY (address->code)     ||
+	     !STRING_IS_EMPTY (address->po)       ||
+	     !STRING_IS_EMPTY (address->country))) {
+		fill_in_address_textview (editor, record, address);
+		fill_in_address_field (editor, record, "city", address->locality);
+		fill_in_address_field (editor, record, "state", address->region);
+		fill_in_address_field (editor, record, "zip", address->code);
+		fill_in_address_field (editor, record, "country", address->country);
+		fill_in_address_field (editor, record, "pobox", address->po);
+	} else if (!STRING_IS_EMPTY (address_label)) {
+		fill_in_address_label_textview (editor, record, address_label);
+	}
+
+	g_free (address_label);
+	if (address)
+		g_boxed_free (e_contact_address_get_type (), address);
+}
+
+static void
+fill_in_address (EContactEditor *editor)
+{
+	gint i;
+
+	for (i = 0; i < ADDRESS_SLOTS; i++)
+		fill_in_address_record (editor, i);
+}
+
+static gchar *
+append_to_address_label (gchar *address_label,
+                         const gchar *part,
+                         gboolean newline)
+{
+	gchar *new_address_label;
+
+	if (STRING_IS_EMPTY (part))
+		return address_label;
+
+	if (address_label)
+		new_address_label = g_strjoin (
+			newline ? "\n" : ", ",
+			address_label, part, NULL);
+	else
+		new_address_label = g_strdup (part);
+
+	g_free (address_label);
+	return new_address_label;
+}
+
+static void
+set_address_label (EContact *contact,
+                   EContactField label_field,
+                   EContactField address_field,
+                   EContactAddress *address)
+{
+	gchar *address_label = NULL;
+	gboolean format_address;
+	GSettings *settings;
+
+	if (!address) {
+		e_contact_set (contact, label_field, NULL);
+		return;
+	}
+
+	settings = e_util_ref_settings ("org.gnome.evolution.addressbook");
+	format_address = g_settings_get_boolean (settings, "address-formatting");
+	g_object_unref (settings);
+
+	if (format_address)
+		address_label = eab_format_address (contact, address_field);
+
+	if (!format_address || !address_label) {
+		address_label = append_to_address_label (
+			address_label, address->street, TRUE);
+		address_label = append_to_address_label (
+			address_label, address->ext, TRUE);
+		address_label = append_to_address_label (
+			address_label, address->locality, TRUE);
+		address_label = append_to_address_label (
+			address_label, address->region, FALSE);
+		address_label = append_to_address_label (
+			address_label, address->code, TRUE);
+		address_label = append_to_address_label (
+			address_label, address->po, TRUE);
+		address_label = append_to_address_label (
+			address_label, address->country, TRUE);
+	}
+
+	e_contact_set (contact, label_field, address_label);
+	g_free (address_label);
+}
+
+static void
+extract_address_record (EContactEditor *editor,
+                        gint record)
+{
+	EContactAddress *address;
+
+	address = e_contact_address_new ();
+
+	extract_address_from_gui (editor, address, record);
+	if (!STRING_IS_EMPTY (address->street)   ||
+	    !STRING_IS_EMPTY (address->ext)      ||
+	    !STRING_IS_EMPTY (address->locality) ||
+	    !STRING_IS_EMPTY (address->region)   ||
+	    !STRING_IS_EMPTY (address->code)     ||
+	    !STRING_IS_EMPTY (address->po)       ||
+	    !STRING_IS_EMPTY (address->country)) {
+		e_contact_set (editor->priv->contact, addresses[record], address);
+		set_address_label (editor->priv->contact, address_labels[record], addresses[record], address);
+	}
+	else {
+		e_contact_set (editor->priv->contact, addresses[record], NULL);
+		set_address_label (editor->priv->contact, address_labels[record], addresses[record], NULL);
+	}
+
+	e_contact_address_free (address);
+}
+
+static void
+extract_address (EContactEditor *editor)
+{
+	gint i;
+
+	for (i = 0; i < ADDRESS_SLOTS; i++)
+		extract_address_record (editor, i);
+}
+
+static void
+sensitize_address_textview (EContactEditor *editor,
+                            gint record,
+                            gboolean enabled)
+{
+	gchar         *widget_name;
+	GtkWidget     *textview;
+	GtkWidget     *label;
+
+	widget_name = g_strdup_printf ("textview-%s-address", address_name[record]);
+	textview = e_builder_get_widget (editor->priv->builder, widget_name);
+	g_free (widget_name);
+
+	widget_name = g_strdup_printf ("label-%s-address", address_name[record]);
+	label = e_builder_get_widget (editor->priv->builder, widget_name);
+	g_free (widget_name);
+
+	gtk_text_view_set_editable (GTK_TEXT_VIEW (textview), enabled);
+	gtk_widget_set_sensitive (label, enabled);
+}
+
+static void
+sensitize_address_field (EContactEditor *editor,
+                         gint record,
+                         const gchar *widget_field_name,
+                         gboolean enabled)
+{
+	gchar     *widget_name;
+	GtkWidget *entry;
+	GtkWidget *label;
+
+	widget_name = g_strdup_printf (
+		"entry-%s-%s", address_name[record], widget_field_name);
+	entry = e_builder_get_widget (editor->priv->builder, widget_name);
+	g_free (widget_name);
+
+	widget_name = g_strdup_printf (
+		"label-%s-%s", address_name[record], widget_field_name);
+	label = e_builder_get_widget (editor->priv->builder, widget_name);
+	g_free (widget_name);
+
+	gtk_editable_set_editable (GTK_EDITABLE (entry), enabled);
+	gtk_widget_set_sensitive (label, enabled);
+}
+
+static void
+sensitize_address_record (EContactEditor *editor,
+                          gint record,
+                          gboolean enabled)
+{
+	sensitize_address_textview (editor, record, enabled);
+	sensitize_address_field (editor, record, "city", enabled);
+	sensitize_address_field (editor, record, "state", enabled);
+	sensitize_address_field (editor, record, "zip", enabled);
+	sensitize_address_field (editor, record, "country", enabled);
+	sensitize_address_field (editor, record, "pobox", enabled);
+}
+
+static void
+sensitize_address (EContactEditor *editor)
+{
+	gint i;
+
+	for (i = 0; i < ADDRESS_SLOTS; i++) {
+		gboolean enabled = TRUE;
+
+		if (!editor->priv->target_editable ||
+		    !(is_field_supported (editor, addresses[i]) ||
+		      is_field_supported (editor, address_labels[i])))
+			enabled = FALSE;
+
+		sensitize_address_record (editor, i, enabled);
+	}
+}
+
+typedef struct {
+	const gchar   *widget_name;
+	gint           field_id;      /* EContactField or -1 */
+	gboolean       process_data;  /* If we should extract/fill in contents */
+	gboolean       desensitize_for_read_only;
+}
+FieldMapping;
+
+/* Table of widgets that interact with simple fields. This table is used to:
+ *
+ * - Fill in data.
+ * - Extract data.
+ * - Set sensitivity based on backend capabilities.
+ * - Set sensitivity based on book writeability. */
+
+static FieldMapping simple_field_map[] = {
+	{ "entry-homepage",       E_CONTACT_HOMEPAGE_URL, TRUE,  TRUE  },
+	{ "accellabel-homepage",  E_CONTACT_HOMEPAGE_URL, FALSE, TRUE  },
+
+	{ "entry-jobtitle",       E_CONTACT_TITLE,        TRUE,  TRUE  },
+	{ "label-jobtitle",       E_CONTACT_TITLE,        FALSE, TRUE  },
+
+	{ "entry-company",        E_CONTACT_ORG,          TRUE,  TRUE  },
+	{ "label-company",        E_CONTACT_ORG,          FALSE, TRUE  },
+
+	{ "entry-department",     E_CONTACT_ORG_UNIT,     TRUE,  TRUE  },
+	{ "label-department",     E_CONTACT_ORG_UNIT,     FALSE, TRUE  },
+
+	{ "entry-profession",     E_CONTACT_ROLE,         TRUE,  TRUE  },
+	{ "label-profession",     E_CONTACT_ROLE,         FALSE, TRUE  },
+
+	{ "entry-manager",        E_CONTACT_MANAGER,      TRUE,  TRUE  },
+	{ "label-manager",        E_CONTACT_MANAGER,      FALSE, TRUE  },
+
+	{ "entry-assistant",      E_CONTACT_ASSISTANT,    TRUE,  TRUE  },
+	{ "label-assistant",      E_CONTACT_ASSISTANT,    FALSE, TRUE  },
+
+	{ "entry-nickname",       E_CONTACT_NICKNAME,     TRUE,  TRUE  },
+	{ "label-nickname",       E_CONTACT_NICKNAME,     FALSE, TRUE  },
+
+	{ "dateedit-birthday",    E_CONTACT_BIRTH_DATE,   TRUE,  TRUE  },
+	{ "label-birthday",       E_CONTACT_BIRTH_DATE,   FALSE, TRUE  },
+
+	{ "dateedit-anniversary", E_CONTACT_ANNIVERSARY,  TRUE,  TRUE  },
+	{ "label-anniversary",    E_CONTACT_ANNIVERSARY,  FALSE, TRUE  },
+
+	{ "entry-spouse",         E_CONTACT_SPOUSE,       TRUE,  TRUE  },
+	{ "label-spouse",         E_CONTACT_SPOUSE,       FALSE, TRUE  },
+
+	{ "entry-office",         E_CONTACT_OFFICE,       TRUE,  TRUE  },
+	{ "label-office",         E_CONTACT_OFFICE,       FALSE, TRUE  },
+
+	{ "text-comments",        E_CONTACT_NOTE,         TRUE,  TRUE  },
+
+	{ "entry-fullname",       E_CONTACT_FULL_NAME,    TRUE,  TRUE  },
+	{ "button-fullname",      E_CONTACT_FULL_NAME,    FALSE, TRUE  },
+
+	{ "entry-categories",     E_CONTACT_CATEGORIES,   TRUE,  TRUE  },
+	{ "button-categories",    E_CONTACT_CATEGORIES,   FALSE, TRUE  },
+
+	{ "entry-weblog",         E_CONTACT_BLOG_URL,     TRUE,  TRUE  },
+	{ "label-weblog",         E_CONTACT_BLOG_URL,     FALSE, TRUE  },
+
+	{ "entry-caluri",         E_CONTACT_CALENDAR_URI, TRUE,  TRUE  },
+	{ "label-caluri",         E_CONTACT_CALENDAR_URI, FALSE, TRUE  },
+
+	{ "entry-fburl",          E_CONTACT_FREEBUSY_URL, TRUE,  TRUE  },
+	{ "label-fburl",          E_CONTACT_FREEBUSY_URL, FALSE, TRUE  },
+
+	{ "entry-videourl",       E_CONTACT_VIDEO_URL,    TRUE,  TRUE  },
+	{ "label-videourl",       E_CONTACT_VIDEO_URL,    FALSE, TRUE  },
+
+	{ "checkbutton-htmlmail", E_CONTACT_WANTS_HTML,   TRUE,  TRUE  },
+
+	{ "image-chooser",        E_CONTACT_PHOTO,        TRUE,  TRUE  },
+	{ "button-image",         E_CONTACT_PHOTO,        FALSE, TRUE  },
+
+	{ "combo-file-as",        E_CONTACT_FILE_AS,      TRUE,  TRUE  },
+	{ "accellabel-fileas",    E_CONTACT_FILE_AS,      FALSE, TRUE  },
+};
+
+static void
+init_simple_field (EContactEditor *editor,
+                   GtkWidget *widget)
+{
+	GObject *changed_object = NULL;
+
+	if (GTK_IS_ENTRY (widget)) {
+		changed_object = G_OBJECT (widget);
+		g_signal_connect_swapped (
+			widget, "activate",
+			G_CALLBACK (entry_activated), editor);
+
+	} else if (GTK_IS_COMBO_BOX (widget)) {
+		changed_object = G_OBJECT (widget);
+		g_signal_connect_swapped (
+			gtk_bin_get_child (GTK_BIN (widget)), "activate",
+			G_CALLBACK (entry_activated), editor);
+
+	} else if (GTK_IS_TEXT_VIEW (widget)) {
+		changed_object = G_OBJECT (
+			gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget)));
+
+	} else if (E_IS_URL_ENTRY (widget)) {
+		changed_object = G_OBJECT (widget);
+		g_signal_connect_swapped (
+			changed_object, "activate",
+			G_CALLBACK (entry_activated), editor);
+
+	} else if (E_IS_DATE_EDIT (widget)) {
+		changed_object = G_OBJECT (widget);
+
+	} else if (E_IS_IMAGE_CHOOSER (widget)) {
+		changed_object = G_OBJECT (widget);
+		g_signal_connect (
+			widget, "changed",
+			G_CALLBACK (image_chooser_changed), editor);
+
+	} else if (GTK_IS_TOGGLE_BUTTON (widget)) {
+		g_signal_connect (
+			widget, "toggled",
+			G_CALLBACK (object_changed), editor);
+	}
+
+	if (changed_object)
+		g_signal_connect (
+			changed_object, "changed",
+			G_CALLBACK (object_changed), editor);
+}
+
+static void
+fill_in_simple_field (EContactEditor *editor,
+                      GtkWidget *widget,
+                      gint field_id)
+{
+	EContact *contact;
+
+	contact = editor->priv->contact;
+
+	g_signal_handlers_block_matched (
+		widget, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+
+	if (GTK_IS_ENTRY (widget)) {
+		gchar *text = e_contact_get (contact, field_id);
+		gtk_entry_set_text (GTK_ENTRY (widget), STRING_MAKE_NON_NULL (text));
+		g_free (text);
+
+	} else if (GTK_IS_COMBO_BOX (widget)) {
+		gchar *text = e_contact_get (contact, field_id);
+		gtk_entry_set_text (
+			GTK_ENTRY (gtk_bin_get_child (GTK_BIN (widget))),
+			STRING_MAKE_NON_NULL (text));
+		g_free (text);
+
+	} else if (GTK_IS_TEXT_VIEW (widget)) {
+		GtkTextBuffer *buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+		gchar *text = e_contact_get (contact, field_id);
+		gtk_text_buffer_set_text (buffer, STRING_MAKE_NON_NULL (text), -1);
+		g_free (text);
+
+	} else if (E_IS_URL_ENTRY (widget)) {
+		gchar *text = e_contact_get (contact, field_id);
+		gtk_entry_set_text (
+			GTK_ENTRY (widget), STRING_MAKE_NON_NULL (text));
+		g_free (text);
+
+	} else if (E_IS_DATE_EDIT (widget)) {
+		EContactDate *date = e_contact_get (contact, field_id);
+		if (date)
+			e_date_edit_set_date (
+				E_DATE_EDIT (widget),
+				date->year, date->month, date->day);
+		else
+			e_date_edit_set_time (E_DATE_EDIT (widget), -1);
+
+		e_contact_date_free (date);
+
+	} else if (E_IS_IMAGE_CHOOSER (widget)) {
+		EContactPhoto *photo = e_contact_get (contact, field_id);
+		editor->priv->image_set = FALSE;
+		if (photo && photo->type == E_CONTACT_PHOTO_TYPE_INLINED) {
+			e_image_chooser_set_image_data (
+				E_IMAGE_CHOOSER (widget),
+				(gchar *) photo->data.inlined.data,
+				photo->data.inlined.length);
+			editor->priv->image_set = TRUE;
+		} else if (photo && photo->type == E_CONTACT_PHOTO_TYPE_URI) {
+			gchar *file_name = g_filename_from_uri (photo->data.uri, NULL, NULL);
+			if (file_name) {
+				e_image_chooser_set_from_file (
+					E_IMAGE_CHOOSER (widget),
+					file_name);
+				editor->priv->image_set = TRUE;
+				g_free (file_name);
+			}
+		}
+
+		if (!editor->priv->image_set) {
+			gchar *file_name;
+
+			file_name = e_icon_factory_get_icon_filename (
+				"avatar-default", GTK_ICON_SIZE_DIALOG);
+			e_image_chooser_set_from_file (
+				E_IMAGE_CHOOSER (widget), file_name);
+			editor->priv->image_set = FALSE;
+			g_free (file_name);
+		}
+
+		editor->priv->image_changed = FALSE;
+		e_contact_photo_free (photo);
+
+	} else if (GTK_IS_TOGGLE_BUTTON (widget)) {
+		gboolean val = e_contact_get (contact, field_id) != NULL;
+
+		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), val);
+
+	} else {
+		g_warning (G_STRLOC ": Unhandled widget class in mappings!");
+	}
+
+	g_signal_handlers_unblock_matched (
+		widget, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+}
+
+static void
+extract_simple_field (EContactEditor *editor,
+                      GtkWidget *widget,
+                      gint field_id)
+{
+	EContact *contact;
+
+	contact = editor->priv->contact;
+
+	if (GTK_IS_ENTRY (widget)) {
+		const gchar *text = gtk_entry_get_text (GTK_ENTRY (widget));
+		e_contact_set (contact, field_id, (text && *text) ? (gchar *) text : NULL);
+
+	} else if (GTK_IS_COMBO_BOX_TEXT (widget)) {
+		gchar *text = NULL;
+
+		if (gtk_combo_box_get_has_entry (GTK_COMBO_BOX (widget))) {
+			GtkWidget *entry = gtk_bin_get_child (GTK_BIN (widget));
+
+			text = g_strdup (gtk_entry_get_text (GTK_ENTRY (entry)));
+		}
+
+		if (!text)
+			text = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX_TEXT (widget));
+
+		e_contact_set (contact, field_id, (text && *text) ? text : NULL);
+
+		g_free (text);
+	} else if (GTK_IS_COMBO_BOX (widget)) {
+		GtkTreeIter iter;
+		gchar *text = NULL;
+
+		if (gtk_combo_box_get_has_entry (GTK_COMBO_BOX (widget))) {
+			GtkWidget *entry = gtk_bin_get_child (GTK_BIN (widget));
+
+			text = g_strdup (gtk_entry_get_text (GTK_ENTRY (entry)));
+		}
+
+		if (!text && gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter)) {
+			GtkListStore *store;
+
+			store = GTK_LIST_STORE (
+				gtk_combo_box_get_model (
+				GTK_COMBO_BOX (widget)));
+
+			gtk_tree_model_get (
+				GTK_TREE_MODEL (store), &iter,
+				0, &text,
+				-1);
+		}
+
+		e_contact_set (contact, field_id, (text && *text) ? text : NULL);
+
+		g_free (text);
+
+	} else if (GTK_IS_TEXT_VIEW (widget)) {
+		GtkTextBuffer *buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (widget));
+		GtkTextIter    start, end;
+		gchar         *text;
+
+		gtk_text_buffer_get_start_iter (buffer, &start);
+		gtk_text_buffer_get_end_iter   (buffer, &end);
+		text = gtk_text_buffer_get_text (buffer, &start, &end, FALSE);
+		e_contact_set (contact, field_id, (text && *text) ? text : NULL);
+		g_free (text);
+
+	} else if (E_IS_URL_ENTRY (widget)) {
+		const gchar *text = gtk_entry_get_text (GTK_ENTRY (widget));
+		e_contact_set (contact, field_id, (text && *text) ? (gchar *) text : NULL);
+
+	} else if (E_IS_DATE_EDIT (widget)) {
+		EContactDate date;
+		if (e_date_edit_get_date (
+				E_DATE_EDIT (widget),
+				(gint *) &date.year,
+				(gint *) &date.month,
+				(gint *) &date.day))
+			e_contact_set (contact, field_id, &date);
+		else
+			e_contact_set (contact, field_id, NULL);
+
+	} else if (E_IS_IMAGE_CHOOSER (widget)) {
+		EContactPhoto photo;
+		photo.type = E_CONTACT_PHOTO_TYPE_INLINED;
+		photo.data.inlined.mime_type = NULL;
+		if (editor->priv->image_changed) {
+			gchar *img_buff = NULL;
+			if (editor->priv->image_set &&
+			    e_image_chooser_get_image_data (
+					E_IMAGE_CHOOSER (widget),
+					&img_buff, &photo.data.inlined.length)) {
+				GdkPixbuf *pixbuf, *new;
+				GdkPixbufLoader *loader = gdk_pixbuf_loader_new ();
+
+				photo.data.inlined.data = (guchar *) img_buff;
+				img_buff = NULL;
+				gdk_pixbuf_loader_write (
+					loader,
+					photo.data.inlined.data,
+					photo.data.inlined.length, NULL);
+				gdk_pixbuf_loader_close (loader, NULL);
+
+				pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);
+				if (pixbuf) {
+					gint width, height, prompt_response;
+
+					g_object_ref (pixbuf);
+
+					height = gdk_pixbuf_get_height (pixbuf);
+					width = gdk_pixbuf_get_width (pixbuf);
+					if ((height > 96 || width > 96)) {
+
+						prompt_response =
+							e_alert_run_dialog_for_args
+							(GTK_WINDOW (editor->priv->app),
+							 "addressbook:prompt-resize",
+							 NULL);
+
+						if (prompt_response == GTK_RESPONSE_YES) {
+							if (width > height) {
+								height = height * 96 / width;
+								width = 96;
+							} else {
+								width = width *96 / height;
+								height = 96;
+							}
+
+							new = e_icon_factory_pixbuf_scale (pixbuf, width, height);
+							if (new) {
+								GdkPixbufFormat *format =
+									gdk_pixbuf_loader_get_format (loader);
+								gchar *format_name =
+									gdk_pixbuf_format_get_name (format);
+								g_free (photo.data.inlined.data);
+								gdk_pixbuf_save_to_buffer (
+									new, &img_buff,
+									&photo.data.inlined.length,
+									format_name, NULL, NULL);
+								photo.data.inlined.data = (guchar *) img_buff;
+								img_buff = NULL;
+								g_free (format_name);
+								g_object_unref (new);
+							}
+						} else if (prompt_response == GTK_RESPONSE_CANCEL) {
+							g_object_unref (pixbuf);
+							g_object_unref (loader);
+							return;
+						}
+					}
+					g_object_unref (pixbuf);
+				}
+				editor->priv->image_changed = FALSE;
+				g_object_unref (loader);
+
+				e_contact_set (contact, field_id, &photo);
+
+				g_free (photo.data.inlined.data);
+
+			} else {
+				editor->priv->image_changed = FALSE;
+				e_contact_set (contact, E_CONTACT_PHOTO, NULL);
+			}
+		}
+
+	} else if (GTK_IS_TOGGLE_BUTTON (widget)) {
+		gboolean val;
+
+		val = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget));
+		e_contact_set (contact, field_id, val ? (gpointer) 1 : NULL);
+
+	} else {
+		g_warning (G_STRLOC ": Unhandled widget class in mappings!");
+	}
+}
+
+static void
+sensitize_simple_field (GtkWidget *widget,
+                        gboolean enabled)
+{
+	if (GTK_IS_ENTRY (widget))
+		gtk_editable_set_editable (GTK_EDITABLE (widget), enabled);
+	else if (GTK_IS_TEXT_VIEW (widget))
+		gtk_text_view_set_editable (GTK_TEXT_VIEW (widget), enabled);
+	else if (E_IS_DATE_EDIT (widget))
+		e_date_edit_set_editable (E_DATE_EDIT (widget), enabled);
+	else
+		gtk_widget_set_sensitive (widget, enabled);
+}
+
+static void
+init_simple (EContactEditor *editor)
+{
+	GtkWidget *widget;
+	gint       i;
+
+	for (i = 0; i < G_N_ELEMENTS (simple_field_map); i++) {
+		widget = e_builder_get_widget (
+			editor->priv->builder, simple_field_map[i].widget_name);
+		if (!widget)
+			continue;
+
+		init_simple_field (editor, widget);
+	}
+
+	/* --- Special cases --- */
+
+	/* Update file_as */
+
+	widget = e_builder_get_widget (editor->priv->builder, "entry-fullname");
+	g_signal_connect (
+		widget, "changed",
+		G_CALLBACK (name_entry_changed), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "combo-file-as");
+	gtk_combo_box_set_entry_text_column (GTK_COMBO_BOX (widget), 0);
+	g_signal_connect (
+		widget, "changed",
+		G_CALLBACK (file_as_combo_changed), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "entry-company");
+	g_signal_connect (
+		widget, "changed",
+		G_CALLBACK (company_entry_changed), editor);
+}
+
+static void
+fill_in_simple (EContactEditor *editor)
+{
+	EContactName *name;
+	gchar *filename;
+	gint          i;
+
+	for (i = 0; i < G_N_ELEMENTS (simple_field_map); i++) {
+		GtkWidget *widget;
+
+		if (simple_field_map[i].field_id < 0 ||
+		    !simple_field_map[i].process_data)
+			continue;
+
+		widget = e_builder_get_widget (
+			editor->priv->builder, simple_field_map[i].widget_name);
+		if (!widget)
+			continue;
+
+		fill_in_simple_field (
+			editor, widget, simple_field_map[i].field_id);
+	}
+
+	/* --- Special cases --- */
+
+	/* Update broken-up name */
+
+	g_object_get (editor->priv->contact, "name", &name, NULL);
+
+	if (editor->priv->name)
+		e_contact_name_free (editor->priv->name);
+
+	editor->priv->name = name;
+
+	/* Update the contact editor title */
+
+	filename = (gchar *) e_contact_get (editor->priv->contact, E_CONTACT_FILE_AS);
+
+	if (filename) {
+		gchar *title;
+		title = g_strdup_printf (_("Contact Editor — %s"), filename);
+		gtk_window_set_title (GTK_WINDOW (editor->priv->app), title);
+		g_free (title);
+		g_free (filename);
+	} else
+		gtk_window_set_title (
+			GTK_WINDOW (editor->priv->app), _("Contact Editor"));
+
+	/* Update file_as combo options */
+
+	update_file_as_combo (editor);
+}
+
+static void
+extract_simple (EContactEditor *editor)
+{
+	gint i;
+
+	for (i = 0; i < G_N_ELEMENTS (simple_field_map); i++) {
+		GtkWidget *widget;
+
+		if (simple_field_map[i].field_id < 0 ||
+		    !simple_field_map[i].process_data)
+			continue;
+
+		widget = e_builder_get_widget (
+			editor->priv->builder, simple_field_map[i].widget_name);
+		if (!widget)
+			continue;
+
+		extract_simple_field (
+			editor, widget, simple_field_map[i].field_id);
+	}
+
+	/* Special cases */
+
+	e_contact_set (editor->priv->contact, E_CONTACT_NAME, editor->priv->name);
+}
+
+static void
+sensitize_simple (EContactEditor *editor)
+{
+	gint i;
+
+	for (i = 0; i < G_N_ELEMENTS (simple_field_map); i++) {
+		GtkWidget *widget;
+		gboolean   enabled = TRUE;
+
+		widget = e_builder_get_widget (
+			editor->priv->builder, simple_field_map[i].widget_name);
+		if (!widget)
+			continue;
+
+		if (simple_field_map[i].field_id >= 0 &&
+		    !is_field_supported (editor, simple_field_map[i].field_id))
+			enabled = FALSE;
+
+		if (simple_field_map[i].desensitize_for_read_only &&
+		    !editor->priv->target_editable)
+			enabled = FALSE;
+
+		sensitize_simple_field (widget, enabled);
+	}
+}
+
+enum CertKind {
+	CERT_KIND_X509,
+	CERT_KIND_PGP
+};
+
+enum CertColumns {
+	CERT_COLUMN_SUBJECT_STRING,
+	CERT_COLUMN_KIND_STRING,
+	CERT_COLUMN_KIND_INT,
+	CERT_COLUMN_DATA_ECONTACTCERT,
+	CERT_COLUMN_CERT_GCRCERTIFICATE,
+	N_CERT_COLUMNS
+};
+
+static void
+cert_tab_selection_changed_cb (GtkTreeSelection *selection,
+			       EContactEditor *editor)
+{
+	GtkWidget *widget;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	gboolean has_selected;
+
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	has_selected = gtk_tree_selection_get_selected (selection, &model, &iter);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-remove-btn");
+	gtk_widget_set_sensitive (widget, has_selected);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-load-pgp-btn");
+	gtk_widget_set_sensitive (widget, has_selected && is_field_supported (editor, E_CONTACT_PGP_CERT));
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-load-x509-btn");
+	gtk_widget_set_sensitive (widget, has_selected && is_field_supported (editor, E_CONTACT_X509_CERT));
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-save-btn");
+	gtk_widget_set_sensitive (widget, has_selected);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-preview-scw");
+	widget = gtk_bin_get_child (GTK_BIN (widget));
+
+	if (GTK_IS_VIEWPORT (widget))
+		widget = gtk_bin_get_child (GTK_BIN (widget));
+
+	g_return_if_fail (GCR_IS_CERTIFICATE_WIDGET (widget));
+
+	if (has_selected) {
+		GcrCertificate *cert = NULL;
+
+		gtk_tree_model_get (model, &iter, CERT_COLUMN_CERT_GCRCERTIFICATE, &cert, -1);
+
+		gcr_certificate_widget_set_certificate (GCR_CERTIFICATE_WIDGET (widget), cert);
+
+		g_clear_object (&cert);
+	} else {
+		gcr_certificate_widget_set_certificate (GCR_CERTIFICATE_WIDGET (widget), NULL);
+	}
+}
+
+static void
+cert_add_filters_for_kind (GtkFileChooser *file_chooser,
+			   enum CertKind kind)
+{
+	GtkFileFilter *filter;
+
+	g_return_if_fail (GTK_IS_FILE_CHOOSER (file_chooser));
+	g_return_if_fail (kind == CERT_KIND_PGP || kind == CERT_KIND_X509);
+
+	if (kind == CERT_KIND_X509) {
+		filter = gtk_file_filter_new ();
+		gtk_file_filter_set_name (filter, _("X.509 certificates"));
+		gtk_file_filter_add_mime_type (filter, "application/x-x509-user-cert");
+		gtk_file_chooser_add_filter (file_chooser, filter);
+	} else {
+		filter = gtk_file_filter_new ();
+		gtk_file_filter_set_name (filter, _("PGP keys"));
+		gtk_file_filter_add_mime_type (filter, "application/pgp-keys");
+		gtk_file_chooser_add_filter (file_chooser, filter);
+	}
+
+	filter = gtk_file_filter_new ();
+	gtk_file_filter_set_name (filter, _("All files"));
+	gtk_file_filter_add_pattern (filter, "*");
+	gtk_file_chooser_add_filter (file_chooser, filter);
+}
+
+static EContactCert *
+cert_load_for_kind (EContactEditor *editor,
+		    enum CertKind kind)
+{
+	EContactCert *cert = NULL;
+	GtkWindow *parent;
+	GtkFileChooserNative *native;
+	GtkFileChooser *file_chooser;
+	GError *error = NULL;
+
+	g_return_val_if_fail (E_IS_CONTACT_EDITOR (editor), NULL);
+	g_return_val_if_fail (kind == CERT_KIND_PGP || kind == CERT_KIND_X509, NULL);
+
+	parent = eab_editor_get_window (EAB_EDITOR (editor));
+	native = gtk_file_chooser_native_new (
+		kind == CERT_KIND_PGP ? _("Open PGP key") : _("Open X.509 certificate"), parent,
+		GTK_FILE_CHOOSER_ACTION_OPEN,
+		_("_Open"), _("_Cancel"));
+
+	file_chooser = GTK_FILE_CHOOSER (native);
+	gtk_file_chooser_set_local_only (file_chooser, TRUE);
+	gtk_file_chooser_set_select_multiple (file_chooser, FALSE);
+
+	cert_add_filters_for_kind (file_chooser, kind);
+
+	if (gtk_native_dialog_run (GTK_NATIVE_DIALOG (native)) == GTK_RESPONSE_ACCEPT) {
+		gchar *filename;
+		gchar *content = NULL;
+		gsize length = 0;
+
+		filename = gtk_file_chooser_get_filename (file_chooser);
+		if (!filename) {
+			g_set_error_literal (&error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED, _("Chosen file is not a local file."));
+		} else if (g_file_get_contents (filename, &content, &length, &error) && length > 0) {
+			cert = e_contact_cert_new ();
+			cert->length = length;
+			cert->data = content;
+		}
+
+		g_free (filename);
+	}
+
+	g_object_unref (native);
+
+	if (error) {
+		e_notice (parent, GTK_MESSAGE_ERROR, _("Failed to load certificate: %s"), error->message);
+		g_clear_error (&error);
+	}
+
+	return cert;
+}
+
+static void
+cert_update_row_with_cert (GtkListStore *list_store,
+			   GtkTreeIter *iter,
+			   EContactCert *cert,
+			   enum CertKind kind)
+{
+	GcrCertificate *gcr_cert = NULL;
+	gchar *subject = NULL;
+
+	g_return_if_fail (GTK_IS_LIST_STORE (list_store));
+	g_return_if_fail (iter != NULL);
+	g_return_if_fail (cert != NULL);
+	g_return_if_fail (kind == CERT_KIND_PGP || kind == CERT_KIND_X509);
+
+	if (kind == CERT_KIND_X509) {
+		gcr_cert = gcr_simple_certificate_new ((const guchar *) cert->data, cert->length);
+		if (gcr_cert)
+			subject = gcr_certificate_get_subject_name (gcr_cert);
+	}
+
+	gtk_list_store_set (list_store, iter,
+		CERT_COLUMN_SUBJECT_STRING, subject,
+		CERT_COLUMN_KIND_STRING, kind == CERT_KIND_X509 ? C_("cert-kind", "X.509") : C_("cert-kind", "PGP"),
+		CERT_COLUMN_KIND_INT, kind,
+		CERT_COLUMN_DATA_ECONTACTCERT, cert,
+		CERT_COLUMN_CERT_GCRCERTIFICATE, gcr_cert,
+		-1);
+
+	g_clear_object (&gcr_cert);
+	g_free (subject);
+}
+
+static void
+cert_add_kind (EContactEditor *editor,
+	       enum CertKind kind)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	EContactCert *cert;
+
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+	g_return_if_fail (kind == CERT_KIND_PGP || kind == CERT_KIND_X509);
+
+	tree_view = GTK_TREE_VIEW (e_builder_get_widget (editor->priv->builder, "certs-treeview"));
+	g_return_if_fail (tree_view != NULL);
+
+	model = gtk_tree_view_get_model (tree_view);
+	selection = gtk_tree_view_get_selection (tree_view);
+
+	cert = cert_load_for_kind (editor, kind);
+	if (cert) {
+		gtk_list_store_append (GTK_LIST_STORE (model), &iter);
+		cert_update_row_with_cert (GTK_LIST_STORE (model), &iter, cert, kind);
+		e_contact_cert_free (cert);
+
+		gtk_tree_selection_select_iter (selection, &iter);
+
+		object_changed (G_OBJECT (tree_view), editor);
+	}
+}
+
+static void
+cert_add_pgp_btn_clicked_cb (GtkWidget *button,
+			     EContactEditor *editor)
+{
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	cert_add_kind (editor, CERT_KIND_PGP);
+}
+
+static void
+cert_add_x509_btn_clicked_cb (GtkWidget *button,
+			      EContactEditor *editor)
+{
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	cert_add_kind (editor, CERT_KIND_X509);
+}
+
+static void
+cert_remove_btn_clicked_cb (GtkWidget *button,
+			    EContactEditor *editor)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter, select;
+	gboolean have_select;
+
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	tree_view = GTK_TREE_VIEW (e_builder_get_widget (editor->priv->builder, "certs-treeview"));
+	g_return_if_fail (tree_view != NULL);
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	g_return_if_fail (gtk_tree_selection_get_selected (selection, &model, &iter));
+
+	select = iter;
+	have_select = gtk_tree_model_iter_next (model, &select);
+	if (!have_select) {
+		select = iter;
+		have_select = gtk_tree_model_iter_previous (model, &select);
+	}
+
+	if (have_select)
+		gtk_tree_selection_select_iter (selection, &select);
+
+	gtk_list_store_remove (GTK_LIST_STORE (model), &iter);
+
+	object_changed (G_OBJECT (tree_view), editor);
+}
+
+static void
+cert_load_kind (EContactEditor *editor,
+		enum CertKind kind)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	EContactCert *cert;
+
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+	g_return_if_fail (kind == CERT_KIND_PGP || kind == CERT_KIND_X509);
+
+	tree_view = GTK_TREE_VIEW (e_builder_get_widget (editor->priv->builder, "certs-treeview"));
+	g_return_if_fail (tree_view != NULL);
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	g_return_if_fail (gtk_tree_selection_get_selected (selection, &model, &iter));
+
+	cert = cert_load_for_kind (editor, kind);
+	if (cert) {
+		cert_update_row_with_cert (GTK_LIST_STORE (model), &iter, cert, kind);
+		e_contact_cert_free (cert);
+
+		object_changed (G_OBJECT (tree_view), editor);
+	}
+}
+
+static void
+cert_load_pgp_btn_clicked_cb (GtkWidget *button,
+			      EContactEditor *editor)
+{
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	cert_load_kind (editor, CERT_KIND_PGP);
+}
+
+static void
+cert_load_x509_btn_clicked_cb (GtkWidget *button,
+			       EContactEditor *editor)
+{
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	cert_load_kind (editor, CERT_KIND_X509);
+}
+
+static void
+cert_save_btn_clicked_cb (GtkWidget *button,
+			  EContactEditor *editor)
+{
+	GtkTreeView *tree_view;
+	GtkTreeSelection *selection;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	EContactCert *cert = NULL;
+	gint kind = -1;
+	GtkWindow *parent;
+	GtkFileChooserNative *native;
+	GtkFileChooser *file_chooser;
+	GError *error = NULL;
+
+	g_return_if_fail (E_IS_CONTACT_EDITOR (editor));
+
+	tree_view = GTK_TREE_VIEW (e_builder_get_widget (editor->priv->builder, "certs-treeview"));
+	g_return_if_fail (tree_view != NULL);
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	g_return_if_fail (gtk_tree_selection_get_selected (selection, &model, &iter));
+
+	gtk_tree_model_get (model, &iter,
+		CERT_COLUMN_KIND_INT, &kind,
+		CERT_COLUMN_DATA_ECONTACTCERT, &cert,
+		-1);
+
+	g_return_if_fail (kind == CERT_KIND_X509 || kind == CERT_KIND_PGP);
+	g_return_if_fail (cert != NULL);
+
+	parent = eab_editor_get_window (EAB_EDITOR (editor));
+	native = gtk_file_chooser_native_new (
+		kind == CERT_KIND_PGP ? _("Save PGP key") : _("Save X.509 certificate"), parent,
+		GTK_FILE_CHOOSER_ACTION_SAVE,
+		_("_Save"), _("_Cancel"));
+
+	file_chooser = GTK_FILE_CHOOSER (native);
+	gtk_file_chooser_set_local_only (file_chooser, TRUE);
+	gtk_file_chooser_set_select_multiple (file_chooser, FALSE);
+
+	cert_add_filters_for_kind (file_chooser, kind);
+
+	if (gtk_native_dialog_run (GTK_NATIVE_DIALOG (native)) == GTK_RESPONSE_ACCEPT) {
+		gchar *filename;
+
+		filename = gtk_file_chooser_get_filename (file_chooser);
+		if (!filename) {
+			g_set_error_literal (&error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED, _("Chosen file is not a local file."));
+		} else {
+			g_file_set_contents (filename, cert->data, cert->length, &error);
+		}
+
+		g_free (filename);
+	}
+
+	g_object_unref (native);
+	e_contact_cert_free (cert);
+
+	if (error) {
+		e_notice (parent, GTK_MESSAGE_ERROR, _("Failed to save certificate: %s"), error->message);
+		g_clear_error (&error);
+	}
+}
+
+static void
+init_certs (EContactEditor *editor)
+{
+	GtkListStore *list_store;
+	GtkTreeView *tree_view;
+	GtkTreeViewColumn *column;
+	GtkTreeSelection *selection;
+	GtkCellRenderer *renderer;
+	GcrCertificateWidget *certificate_widget;
+	GtkWidget *widget;
+
+	tree_view = GTK_TREE_VIEW (e_builder_get_widget (editor->priv->builder, "certs-treeview"));
+	g_return_if_fail (tree_view != NULL);
+
+	gtk_tree_view_set_headers_visible (tree_view, FALSE);
+
+	column = gtk_tree_view_column_new ();
+	gtk_tree_view_append_column (tree_view, column);
+
+	renderer = gtk_cell_renderer_text_new ();
+	gtk_tree_view_column_pack_start (column, renderer, FALSE);
+	gtk_tree_view_column_add_attribute (column, renderer, "text", CERT_COLUMN_KIND_STRING);
+
+	column = gtk_tree_view_column_new ();
+	gtk_tree_view_column_set_expand (column, TRUE);
+	gtk_tree_view_append_column (tree_view, column);
+
+	renderer = gtk_cell_renderer_text_new ();
+	gtk_tree_view_column_pack_start (column, renderer, FALSE);
+	gtk_tree_view_column_add_attribute (column, renderer, "text", CERT_COLUMN_SUBJECT_STRING);
+
+	list_store = gtk_list_store_new (N_CERT_COLUMNS,
+		G_TYPE_STRING,		/* CERT_COLUMN_SUBJECT_STRING */
+		G_TYPE_STRING,		/* CERT_COLUMN_KIND_STRING */
+		G_TYPE_INT,		/* CERT_COLUMN_KIND_INT */
+		E_TYPE_CONTACT_CERT,	/* CERT_COLUMN_DATA_ECONTACTCERT */
+		GCR_TYPE_CERTIFICATE);	/* CERT_COLUMN_CERT_GCRCERTIFICATE */
+
+	gtk_tree_view_set_model (tree_view, GTK_TREE_MODEL (list_store));
+
+	certificate_widget = gcr_certificate_widget_new (NULL);
+	gtk_widget_show (GTK_WIDGET (certificate_widget));
+	widget = e_builder_get_widget (editor->priv->builder, "cert-preview-scw");
+	gtk_container_add (GTK_CONTAINER (widget), GTK_WIDGET (certificate_widget));
+
+	selection = gtk_tree_view_get_selection (tree_view);
+	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+	g_signal_connect (selection, "changed", G_CALLBACK (cert_tab_selection_changed_cb), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-add-pgp-btn");
+	g_signal_connect (widget, "clicked", G_CALLBACK (cert_add_pgp_btn_clicked_cb), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-add-x509-btn");
+	g_signal_connect (widget, "clicked", G_CALLBACK (cert_add_x509_btn_clicked_cb), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-remove-btn");
+	g_signal_connect (widget, "clicked", G_CALLBACK (cert_remove_btn_clicked_cb), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-load-pgp-btn");
+	g_signal_connect (widget, "clicked", G_CALLBACK (cert_load_pgp_btn_clicked_cb), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-load-x509-btn");
+	g_signal_connect (widget, "clicked", G_CALLBACK (cert_load_x509_btn_clicked_cb), editor);
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-save-btn");
+	g_signal_connect (widget, "clicked", G_CALLBACK (cert_save_btn_clicked_cb), editor);
+}
+
+static void
+fill_in_certs (EContactEditor *editor)
+{
+	GtkTreeModel *model;
+	GtkListStore *list_store;
+	GtkWidget *widget;
+	GList *attrs, *link;
+	GtkTreeIter iter;
+	enum CertKind kind;
+
+	widget = e_builder_get_widget (editor->priv->builder, "certs-treeview");
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (widget));
+	list_store = GTK_LIST_STORE (model);
+
+	/* Clear */
+
+	gtk_list_store_clear (list_store);
+
+	/* Fill in */
+
+	attrs = e_vcard_get_attributes (E_VCARD (editor->priv->contact));
+	for (link = attrs; link; link = g_list_next (link)) {
+		EVCardAttribute *attr = link->data;
+		EContactCert *cert;
+		GString *value;
+		GtkTreeIter iter;
+
+		if (e_vcard_attribute_has_type (attr, "X509"))
+			kind = CERT_KIND_X509;
+		else if (e_vcard_attribute_has_type (attr, "PGP"))
+			kind = CERT_KIND_PGP;
+		else
+			continue;
+
+		value = e_vcard_attribute_get_value_decoded (attr);
+		if (!value || !value->len) {
+			if (value)
+				g_string_free (value, TRUE);
+			continue;
+		}
+
+		cert = e_contact_cert_new ();
+		cert->length = value->len;
+		cert->data = g_malloc (cert->length);
+		memcpy (cert->data, value->str, cert->length);
+
+		gtk_list_store_append (list_store, &iter);
+
+		cert_update_row_with_cert (list_store, &iter, cert, kind);
+
+		e_contact_cert_free (cert);
+		g_string_free (value, TRUE);
+	}
+
+	if (gtk_tree_model_get_iter_first (model, &iter)) {
+		GtkTreeSelection *selection;
+
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (widget));
+		gtk_tree_selection_select_iter (selection, &iter);
+	}
+}
+
+static void
+extract_certs_for_kind (EContactEditor *editor,
+			enum CertKind kind,
+			EContactField field,
+			GtkTreeModel *model)
+{
+	GtkTreeIter iter;
+	gboolean valid;
+	EVCard *vcard;
+	GList *attrs = NULL, *link;
+
+	if (is_field_supported (editor, field)) {
+		valid = gtk_tree_model_get_iter_first (model, &iter);
+		while (valid) {
+			EContactCert *cert = NULL;
+			gint set_kind = -1;
+
+			gtk_tree_model_get (model, &iter,
+					    CERT_COLUMN_KIND_INT, &set_kind,
+					    CERT_COLUMN_DATA_ECONTACTCERT, &cert,
+					   -1);
+
+			if (cert && set_kind == kind) {
+				EVCardAttribute *attr;
+
+				attr = e_vcard_attribute_new ("", e_contact_vcard_attribute (field));
+				e_vcard_attribute_add_param_with_value (
+					attr, e_vcard_attribute_param_new (EVC_TYPE),
+					field == E_CONTACT_X509_CERT ? "X509" : "PGP");
+				e_vcard_attribute_add_param_with_value (
+					attr,
+					e_vcard_attribute_param_new (EVC_ENCODING),
+					"b");
+
+				e_vcard_attribute_add_value_decoded (attr, cert->data, cert->length);
+
+				attrs = g_list_prepend (attrs, attr);
+			}
+
+			e_contact_cert_free (cert);
+
+			valid = gtk_tree_model_iter_next (model, &iter);
+		}
+	}
+
+	attrs = g_list_reverse (attrs);
+
+	vcard = E_VCARD (editor->priv->contact);
+
+	for (link = attrs; link; link = g_list_next (link)) {
+		/* takes ownership of the attribute */
+		e_vcard_append_attribute (vcard, link->data);
+	}
+
+	g_list_free (attrs);
+}
+
+static void
+extract_certs (EContactEditor *editor)
+{
+	GtkWidget *widget;
+	GtkTreeModel *model;
+	GList *attrs, *link;
+	EVCard *vcard;
+
+	widget = e_builder_get_widget (editor->priv->builder, "certs-treeview");
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (widget));
+
+	vcard = E_VCARD (editor->priv->contact);
+	attrs = g_list_copy (e_vcard_get_attributes (vcard));
+
+	for (link = attrs; link; link = g_list_next (link)) {
+		EVCardAttribute *attr = link->data;
+
+		/* Remove only those types the editor can work with. */
+		if ((!e_vcard_attribute_get_name (attr) ||
+		     g_ascii_strcasecmp (EVC_KEY, e_vcard_attribute_get_name (attr)) == 0) &&
+		    (e_vcard_attribute_has_type (attr, "X509") ||
+		     e_vcard_attribute_has_type (attr, "PGP"))) {
+			e_vcard_remove_attribute (vcard, attr);
+		}
+	}
+
+	g_list_free (attrs);
+
+	/* The saved order will always be X.509 first, then PGP */
+	extract_certs_for_kind (editor, CERT_KIND_X509, E_CONTACT_X509_CERT, model);
+	extract_certs_for_kind (editor, CERT_KIND_PGP, E_CONTACT_PGP_CERT, model);
+}
+
+static void
+sensitize_certs (EContactEditor *editor)
+{
+	GtkWidget *widget;
+
+	widget = e_builder_get_widget (editor->priv->builder, "certs-grid");
+
+	gtk_widget_set_sensitive (widget, editor->priv->target_editable && (
+		is_field_supported (editor, E_CONTACT_X509_CERT) ||
+		is_field_supported (editor, E_CONTACT_PGP_CERT)));
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-add-pgp-btn");
+	gtk_widget_set_sensitive (widget, is_field_supported (editor, E_CONTACT_PGP_CERT));
+
+	widget = e_builder_get_widget (editor->priv->builder, "cert-add-x509-btn");
+	gtk_widget_set_sensitive (widget, is_field_supported (editor, E_CONTACT_X509_CERT));
+
+	widget = e_builder_get_widget (editor->priv->builder, "certs-treeview");
+	cert_tab_selection_changed_cb (gtk_tree_view_get_selection (GTK_TREE_VIEW (widget)), editor);
+}
+
+static void
+fill_in_all (EContactEditor *editor)
+{
+	GtkWidget *focused_widget;
+	gpointer weak_pointer;
+
+	/* Widget changes can cause focus widget change, thus remember the current
+	   widget and restore it after the fill is done; some fill operations
+	   can delete widgets, like the dyntable, thus do the weak_pointer as well.
+	*/
+	focused_widget = gtk_window_get_focus (eab_editor_get_window (EAB_EDITOR (editor)));
+	weak_pointer = focused_widget;
+	if (focused_widget)
+		g_object_add_weak_pointer (G_OBJECT (focused_widget), &weak_pointer);
+
+	fill_in_source_field (editor);
+	fill_in_simple       (editor);
+	fill_in_email        (editor);
+	fill_in_phone        (editor);
+	fill_in_sip          (editor);
+	fill_in_im           (editor);
+	fill_in_address      (editor);
+	fill_in_certs        (editor);
+
+	/* Visibility of sections and status of menuitems in the config-menu depend on data
+	 * they have to be initialized here instead of init_all() and sensitize_all()
+	 */
+	configure_visibility (editor);
+	config_sensitize_cb (NULL, editor);
+
+	if (weak_pointer) {
+		g_object_remove_weak_pointer (G_OBJECT (focused_widget), &weak_pointer);
+		gtk_widget_grab_focus (focused_widget);
+	}
+}
+
+static void
+extract_all (EContactEditor *editor)
+{
+	extract_simple  (editor);
+	extract_email   (editor);
+	extract_phone   (editor);
+	extract_sip     (editor);
+	extract_im      (editor);
+	extract_address (editor);
+	extract_certs   (editor);
+}
+
+static void
+sensitize_all (EContactEditor *editor)
+{
+	GtkWidget *focused_widget;
+	gpointer weak_pointer;
+
+	/* Widget changes can cause focus widget change, thus remember the current
+	   widget and restore it after the fill is done; some fill operations
+	   can delete widgets, like the dyntable, thus do the weak_pointer as well.
+	*/
+	focused_widget = gtk_window_get_focus (eab_editor_get_window (EAB_EDITOR (editor)));
+	weak_pointer = focused_widget;
+	if (focused_widget)
+		g_object_add_weak_pointer (G_OBJECT (focused_widget), &weak_pointer);
+
+	sensitize_ok      (editor);
+	sensitize_simple  (editor);
+	sensitize_email   (editor);
+	sensitize_phone   (editor);
+	sensitize_sip     (editor);
+	sensitize_im      (editor);
+	sensitize_address (editor);
+	sensitize_certs   (editor);
+
+	if (weak_pointer) {
+		g_object_remove_weak_pointer (G_OBJECT (focused_widget), &weak_pointer);
+		gtk_widget_grab_focus (focused_widget);
+	}
+}
+
+static void
+init_personal (EContactEditor *editor)
+{
+	gtk_expander_set_expanded (
+				GTK_EXPANDER (e_builder_get_widget (editor->priv->builder, "expander-personal-web")),
+				!editor->priv->compress_ui);
+	gtk_expander_set_expanded (
+				GTK_EXPANDER (e_builder_get_widget (editor->priv->builder, "expander-personal-job")),
+				!editor->priv->compress_ui);
+	gtk_expander_set_expanded (
+				GTK_EXPANDER (e_builder_get_widget (editor->priv->builder, "expander-personal-misc")),
+				!editor->priv->compress_ui);
+}
+
+static void
+init_all (EContactEditor *editor)
+{
+	const gchar *contents[] = { "viewport1", "viewport2", "viewport3", "text-comments" };
+	gint ii;
+	GtkRequisition tab_req, requisition;
+	GtkWidget *widget;
+
+	init_simple   (editor);
+	init_email    (editor);
+	init_phone    (editor);
+	init_sip      (editor);
+	init_im       (editor);
+	init_personal (editor);
+	init_address  (editor);
+	init_certs    (editor);
+	init_config   (editor);
+
+	/* with so many scrolled windows, we need to
+	 * do some manual sizing */
+	requisition.width = -1;
+	requisition.height = -1;
+
+	for (ii = 0; ii < G_N_ELEMENTS (contents); ii++) {
+		widget = e_builder_get_widget (editor->priv->builder, contents[ii]);
+
+		gtk_widget_get_preferred_size (widget, NULL, &tab_req);
+
+		if (tab_req.width > requisition.width)
+			requisition.width = tab_req.width;
+		if (tab_req.height > requisition.height)
+			requisition.height = tab_req.height;
+	}
+
+	if (requisition.width > 0 && requisition.height > 0) {
+		GtkWidget *window;
+		GdkScreen *screen;
+		GdkRectangle monitor_area;
+		gint x = 0, y = 0, monitor, width, height;
+
+		window = e_builder_get_widget (
+			editor->priv->builder, "contact editor");
+
+		gtk_widget_get_preferred_size (window, &tab_req, NULL);
+		width = tab_req.width - 320 + 24;
+		height = tab_req.height - 240 + 24;
+
+		screen = gtk_window_get_screen (GTK_WINDOW (window));
+		gtk_window_get_position (GTK_WINDOW (window), &x, &y);
+
+		monitor = gdk_screen_get_monitor_at_point (screen, x, y);
+
+		if (monitor < 0)
+			monitor = 0;
+
+		if (monitor >= gdk_screen_get_n_monitors (screen))
+			monitor = 0;
+
+		gdk_screen_get_monitor_workarea (screen, monitor, &monitor_area);
+
+		if (requisition.width > monitor_area.width - width)
+			requisition.width = monitor_area.width - width;
+
+		if (requisition.height > monitor_area.height - height)
+			requisition.height = monitor_area.height - height;
+
+		if (requisition.width > 0 && requisition.height > 0)
+			gtk_window_set_default_size (
+				GTK_WINDOW (window),
+				width + requisition.width,
+				height + requisition.height);
+	}
+
+	widget = e_builder_get_widget (editor->priv->builder, "text-comments");
+	if (widget)
+		e_spell_text_view_attach (GTK_TEXT_VIEW (widget));
+}
+
+static void
+contact_editor_get_client_cb (GObject *source_object,
+                              GAsyncResult *result,
+                              gpointer user_data)
+{
+	EClientComboBox *combo_box;
+	ConnectClosure *closure = user_data;
+	EClient *client;
+	GError *error = NULL;
+
+	combo_box = E_CLIENT_COMBO_BOX (source_object);
+
+	client = e_client_combo_box_get_client_finish (
+		combo_box, result, &error);
+
+	/* Sanity check. */
+	g_return_if_fail (
+		((client != NULL) && (error == NULL)) ||
+		((client == NULL) && (error != NULL)));
+
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		g_warn_if_fail (client == NULL);
+		g_error_free (error);
+		goto exit;
+
+	} else if (error != NULL) {
+		GtkWindow *parent;
+
+		parent = eab_editor_get_window (EAB_EDITOR (closure->editor));
+
+		eab_load_error_dialog (
+			GTK_WIDGET (parent), NULL,
+			closure->source, error);
+
+		e_source_combo_box_set_active (
+			E_SOURCE_COMBO_BOX (combo_box),
+			e_client_get_source (E_CLIENT (closure->editor->priv->target_client)));
+
+		g_error_free (error);
+		goto exit;
+	}
+
+	/* FIXME Write a private contact_editor_set_target_client(). */
+	g_object_set (closure->editor, "target_client", client, NULL);
+
+	g_object_unref (client);
+
+exit:
+	connect_closure_free (closure);
+}
+
+static void
+source_changed (EClientComboBox *combo_box,
+                EContactEditor *editor)
+{
+	ConnectClosure *closure;
+	ESource *target_source;
+	ESource *source_source;
+	ESource *source;
+
+	source = e_source_combo_box_ref_active (
+		E_SOURCE_COMBO_BOX (combo_box));
+	g_return_if_fail (source != NULL);
+
+	if (editor->priv->cancellable != NULL) {
+		g_cancellable_cancel (editor->priv->cancellable);
+		g_object_unref (editor->priv->cancellable);
+		editor->priv->cancellable = NULL;
+	}
+
+	target_source = e_client_get_source (E_CLIENT (editor->priv->target_client));
+	source_source = e_client_get_source (E_CLIENT (editor->priv->source_client));
+
+	if (e_source_equal (target_source, source))
+		goto exit;
+
+	if (e_source_equal (source_source, source)) {
+		g_object_set (
+			editor, "target_client",
+			editor->priv->source_client, NULL);
+		goto exit;
+	}
+
+	editor->priv->cancellable = g_cancellable_new ();
+
+	closure = g_slice_new0 (ConnectClosure);
+	closure->editor = g_object_ref (editor);
+	closure->source = g_object_ref (source);
+
+	e_client_combo_box_get_client (
+		combo_box, source,
+		editor->priv->cancellable,
+		contact_editor_get_client_cb,
+		closure);
+
+exit:
+	g_object_unref (source);
+}
+
+static void
+full_name_editor_closed_cb (GtkWidget *widget,
+			    gpointer data)
+{
+	if (GTK_IS_WIDGET (widget))
+		gtk_widget_destroy (widget);
+}
+
+static void
+full_name_response (GtkDialog *dialog,
+                    gint response,
+                    EContactEditor *editor)
+{
+	EContactName *name;
+	GtkWidget *fname_widget;
+	gint style = 0;
+	gboolean editable = FALSE;
+
+	g_object_get (dialog, "editable", &editable, NULL);
+
+	if (editable && response == GTK_RESPONSE_OK) {
+		g_object_get (dialog, "name", &name, NULL);
+
+		style = file_as_get_style (editor);
+
+		fname_widget = e_builder_get_widget (
+			editor->priv->builder, "entry-fullname");
+
+		if (GTK_IS_ENTRY (fname_widget)) {
+			GtkEntry *entry;
+			gchar *full_name = e_contact_name_to_string (name);
+			const gchar *old_full_name;
+
+			entry = GTK_ENTRY (fname_widget);
+			old_full_name = gtk_entry_get_text (entry);
+
+			if (strcmp (full_name, old_full_name))
+				gtk_entry_set_text (entry, full_name);
+			g_free (full_name);
+		}
+
+		e_contact_name_free (editor->priv->name);
+		editor->priv->name = name;
+
+		file_as_set_style (editor, style);
+	}
+
+	g_signal_handlers_disconnect_by_func (editor, G_CALLBACK (full_name_editor_closed_cb), dialog);
+
+	gtk_widget_destroy (GTK_WIDGET (dialog));
+	editor->priv->fullname_dialog = NULL;
+}
+
+static void
+full_name_clicked (GtkWidget *button,
+                   EContactEditor *editor)
+{
+	GtkDialog *dialog;
+	GtkWindow *parent;
+	gboolean fullname_supported;
+
+	if (editor->priv->fullname_dialog) {
+		gtk_window_present (GTK_WINDOW (editor->priv->fullname_dialog));
+		return;
+	}
+
+	parent = eab_editor_get_window (EAB_EDITOR (editor));
+	dialog = GTK_DIALOG (e_contact_editor_fullname_new (parent, editor->priv->name));
+	fullname_supported = is_field_supported (editor, E_CONTACT_FULL_NAME);
+
+	g_object_set (
+		dialog, "editable",
+		fullname_supported & editor->priv->target_editable, NULL);
+
+	g_signal_connect (
+		dialog, "response",
+		G_CALLBACK (full_name_response), editor);
+
+	/* Close the fullname dialog if the editor is closed */
+	g_signal_connect_swapped (
+		editor, "editor_closed",
+		G_CALLBACK (full_name_editor_closed_cb), dialog);
+
+	gtk_widget_show (GTK_WIDGET (dialog));
+	editor->priv->fullname_dialog = GTK_WIDGET (dialog);
+}
+
+static void
+categories_response (GtkDialog *dialog,
+                     gint response,
+                     EContactEditor *editor)
+{
+	gchar *categories;
+	GtkWidget *entry;
+
+	entry = e_builder_get_widget (editor->priv->builder, "entry-categories");
+
+	if (response == GTK_RESPONSE_OK) {
+		categories = e_categories_dialog_get_categories (
+			E_CATEGORIES_DIALOG (dialog));
+		if (GTK_IS_ENTRY (entry))
+			gtk_entry_set_text (
+				GTK_ENTRY (entry), categories);
+		else
+			e_contact_set (
+				editor->priv->contact,
+				E_CONTACT_CATEGORIES,
+				categories);
+		g_free (categories);
+	}
+
+	gtk_widget_destroy (GTK_WIDGET (dialog));
+	editor->priv->categories_dialog = NULL;
+}
+
+static void
+categories_clicked (GtkWidget *button,
+                    EContactEditor *editor)
+{
+	gchar *categories = NULL;
+	GtkDialog *dialog;
+	GtkWindow *window;
+	GtkWidget *entry = e_builder_get_widget (editor->priv->builder, "entry-categories");
+
+	if (entry && GTK_IS_ENTRY (entry))
+		categories = g_strdup (gtk_entry_get_text (GTK_ENTRY (entry)));
+	else if (editor->priv->contact)
+		categories = e_contact_get (editor->priv->contact, E_CONTACT_CATEGORIES);
+
+	if (editor->priv->categories_dialog != NULL) {
+		gtk_window_present (GTK_WINDOW (editor->priv->categories_dialog));
+		g_free (categories);
+		return;
+	}else if (!(dialog = GTK_DIALOG (e_categories_dialog_new (categories)))) {
+		e_alert_run_dialog_for_args (
+			GTK_WINDOW (editor->priv->app),
+			"addressbook:edit-categories", NULL);
+		g_free (categories);
+		return;
+	}
+
+	g_signal_connect (
+		dialog, "response",
+		G_CALLBACK (categories_response), editor);
+
+	window = GTK_WINDOW (dialog);
+
+	/* Close the category dialog if the editor is closed */
+	gtk_window_set_destroy_with_parent (window, TRUE);
+	gtk_window_set_modal (window, FALSE);
+	gtk_window_set_transient_for (window, eab_editor_get_window (EAB_EDITOR (editor)));
+
+	gtk_widget_show (GTK_WIDGET (dialog));
+	g_free (categories);
+
+	editor->priv->categories_dialog = GTK_WIDGET (dialog);
+}
+
+static void
+image_selected (EContactEditor *editor)
+{
+	gchar     *file_name;
+	GtkWidget *image_chooser;
+
+	if (editor->priv->image_selector)
+		file_name = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (editor->priv->image_selector));
+	else
+		file_name = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (editor->priv->image_selector_native));
+
+	if (!file_name)
+		return;
+
+	image_chooser = e_builder_get_widget (editor->priv->builder, "image-chooser");
+
+	g_signal_handlers_block_by_func (
+		image_chooser, image_chooser_changed, editor);
+	e_image_chooser_set_from_file (
+		E_IMAGE_CHOOSER (image_chooser), file_name);
+	g_signal_handlers_unblock_by_func (
+		image_chooser, image_chooser_changed, editor);
+
+	editor->priv->image_set = TRUE;
+	editor->priv->image_changed = TRUE;
+	object_changed (G_OBJECT (image_chooser), editor);
+}
+
+static void
+image_cleared (EContactEditor *editor)
+{
+	GtkWidget *image_chooser;
+	gchar     *file_name;
+
+	image_chooser = e_builder_get_widget (
+		editor->priv->builder, "image-chooser");
+
+	file_name = e_icon_factory_get_icon_filename (
+		"avatar-default", GTK_ICON_SIZE_DIALOG);
+
+	g_signal_handlers_block_by_func (
+		image_chooser, image_chooser_changed, editor);
+	e_image_chooser_set_from_file (
+		E_IMAGE_CHOOSER (image_chooser), file_name);
+	g_signal_handlers_unblock_by_func (
+		image_chooser, image_chooser_changed, editor);
+
+	g_free (file_name);
+
+	editor->priv->image_set = FALSE;
+	editor->priv->image_changed = TRUE;
+	object_changed (G_OBJECT (image_chooser), editor);
+}
+
+static void
+file_chooser_response (GtkWidget *widget,
+                       gint response,
+                       EContactEditor *editor)
+{
+	if (response == GTK_RESPONSE_ACCEPT)
+		image_selected (editor);
+	else if (response == GTK_RESPONSE_NO)
+		image_cleared (editor);
+	else if (editor->priv->image_selector_native &&
+		 editor->priv->image_set) {
+		/* It doesn't support custom buttons, thus ask separately, which is a pita */
+		if (e_alert_run_dialog_for_args (GTK_WINDOW (editor->priv->app),
+			"addressbook:ask-unset-image", NULL) == GTK_RESPONSE_ACCEPT)
+			image_cleared (editor);
+	}
+
+	if (editor->priv->image_selector)
+		gtk_widget_hide (editor->priv->image_selector);
+	else
+		g_clear_object (&editor->priv->image_selector_native);
+}
+
+static gboolean
+file_selector_deleted (GtkWidget *widget)
+{
+	gtk_widget_hide (widget);
+	return TRUE;
+}
+
+static void
+update_preview_cb (GtkFileChooser *file_chooser,
+                   gpointer data)
+{
+	GtkWidget *preview;
+	gchar *filename;
+	GdkPixbuf *pixbuf;
+
+	preview = GTK_WIDGET (data);
+	filename = gtk_file_chooser_get_preview_filename (file_chooser);
+	if (!e_util_can_preview_filename (filename)) {
+		gtk_file_chooser_set_preview_widget_active (file_chooser, FALSE);
+		g_free (filename);
+		return;
+	}
+
+	gtk_file_chooser_set_preview_widget_active (file_chooser, TRUE);
+
+	pixbuf = gdk_pixbuf_new_from_file_at_size (filename, 128, 128, NULL);
+
+	if (!pixbuf) {
+		gchar *alternate_file;
+		alternate_file = e_icon_factory_get_icon_filename (
+			"avatar-default", GTK_ICON_SIZE_DIALOG);
+		if (alternate_file) {
+			pixbuf = gdk_pixbuf_new_from_file_at_size (
+				alternate_file, 128, 128, NULL);
+			g_free (alternate_file);
+		}
+	}
+	g_free (filename);
+
+	gtk_image_set_from_pixbuf (GTK_IMAGE (preview), pixbuf);
+	if (pixbuf)
+		g_object_unref (pixbuf);
+}
+
+static void
+image_clicked (GtkWidget *button,
+               EContactEditor *editor)
+{
+	if (!editor->priv->image_selector && !editor->priv->image_selector_native) {
+		GtkImage *preview;
+		GtkFileFilter *filter;
+
+		if (e_util_is_running_flatpak ()) {
+			editor->priv->image_selector_native = gtk_file_chooser_native_new (
+				_("Please select an image for this contact"),
+				GTK_WINDOW (editor->priv->app),
+				GTK_FILE_CHOOSER_ACTION_OPEN,
+				_("_Open"), _("_Cancel"));
+		} else {
+			editor->priv->image_selector = gtk_file_chooser_dialog_new (
+				_("Please select an image for this contact"),
+				GTK_WINDOW (editor->priv->app),
+				GTK_FILE_CHOOSER_ACTION_OPEN,
+				_("_Cancel"), GTK_RESPONSE_CANCEL,
+				_("_Open"), GTK_RESPONSE_ACCEPT,
+				_("_No image"), GTK_RESPONSE_NO,
+				NULL);
+		}
+
+		filter = gtk_file_filter_new ();
+		gtk_file_filter_add_mime_type (filter, "image/*");
+		gtk_file_chooser_set_filter (
+			editor->priv->image_selector ? GTK_FILE_CHOOSER (editor->priv->image_selector) : GTK_FILE_CHOOSER (editor->priv->image_selector_native),
+			filter);
+
+		if (editor->priv->image_selector) {
+			preview = GTK_IMAGE (gtk_image_new ());
+			gtk_file_chooser_set_preview_widget (
+				GTK_FILE_CHOOSER (editor->priv->image_selector),
+				GTK_WIDGET (preview));
+			g_signal_connect (
+				editor->priv->image_selector, "update-preview",
+				G_CALLBACK (update_preview_cb), preview);
+
+			gtk_dialog_set_default_response (
+				GTK_DIALOG (editor->priv->image_selector),
+				GTK_RESPONSE_ACCEPT);
+
+			g_signal_connect (
+				editor->priv->image_selector, "response",
+				G_CALLBACK (file_chooser_response), editor);
+
+			g_signal_connect_after (
+				editor->priv->image_selector, "delete-event",
+				G_CALLBACK (file_selector_deleted),
+				editor->priv->image_selector);
+		} else {
+			g_signal_connect (
+				editor->priv->image_selector_native, "response",
+				G_CALLBACK (file_chooser_response), editor);
+		}
+	}
+
+	/* Display the dialog */
+	if (editor->priv->image_selector) {
+		gtk_window_set_modal (GTK_WINDOW (editor->priv->image_selector), TRUE);
+		gtk_window_present (GTK_WINDOW (editor->priv->image_selector));
+	} else {
+		gtk_native_dialog_set_modal (GTK_NATIVE_DIALOG (editor->priv->image_selector_native), TRUE);
+		gtk_native_dialog_show (GTK_NATIVE_DIALOG (editor->priv->image_selector_native));
+	}
+}
+
+typedef struct {
+	EContactEditor *ce;
+	gboolean should_close;
+	gchar *new_id;
+} EditorCloseStruct;
+
+static void
+editor_close_struct_free (EditorCloseStruct *ecs)
+{
+	if (ecs) {
+		g_clear_object (&ecs->ce);
+		g_free (ecs->new_id);
+		g_slice_free (EditorCloseStruct, ecs);
+	}
+}
+
+static void
+contact_removed_cb (GObject *source_object,
+                    GAsyncResult *result,
+                    gpointer user_data)
+{
+	EBookClient *book_client = E_BOOK_CLIENT (source_object);
+	EditorCloseStruct *ecs = user_data;
+	EContactEditor *ce = ecs->ce;
+	gboolean should_close = ecs->should_close;
+	GError *error = NULL;
+
+	e_book_client_remove_contact_finish (book_client, result, &error);
+
+	gtk_widget_set_sensitive (ce->priv->app, TRUE);
+	ce->priv->in_async_call = FALSE;
+
+	e_contact_set (ce->priv->contact, E_CONTACT_UID, ecs->new_id);
+
+	eab_editor_contact_deleted (EAB_EDITOR (ce), error, ce->priv->contact);
+
+	ce->priv->is_new_contact = FALSE;
+
+	if (should_close) {
+		eab_editor_close (EAB_EDITOR (ce));
+	} else {
+		ce->priv->changed = FALSE;
+
+		g_object_ref (ce->priv->target_client);
+		g_object_unref (ce->priv->source_client);
+		ce->priv->source_client = ce->priv->target_client;
+
+		sensitize_all (ce);
+	}
+
+	g_clear_error (&error);
+
+	editor_close_struct_free (ecs);
+}
+
+static void
+contact_added_cb (EBookClient *book_client,
+                  const GError *error,
+                  const gchar *id,
+                  gpointer closure)
+{
+	EditorCloseStruct *ecs = closure;
+	EContactEditor *ce = ecs->ce;
+	gboolean should_close = ecs->should_close;
+
+	if (ce->priv->source_client != ce->priv->target_client && !e_client_is_readonly (E_CLIENT (ce->priv->source_client)) &&
+	    !error && ce->priv->is_new_contact == FALSE) {
+		ecs->new_id = g_strdup (id);
+		e_book_client_remove_contact (
+			ce->priv->source_client, ce->priv->contact, E_BOOK_OPERATION_FLAG_NONE, NULL, contact_removed_cb, ecs);
+		return;
+	}
+
+	gtk_widget_set_sensitive (ce->priv->app, TRUE);
+	ce->priv->in_async_call = FALSE;
+
+	e_contact_set (ce->priv->contact, E_CONTACT_UID, id);
+
+	eab_editor_contact_added (EAB_EDITOR (ce), error, ce->priv->contact);
+
+	if (!error) {
+		ce->priv->is_new_contact = FALSE;
+
+		if (should_close) {
+			eab_editor_close (EAB_EDITOR (ce));
+		} else {
+			ce->priv->changed = FALSE;
+			sensitize_all (ce);
+		}
+	}
+
+	editor_close_struct_free (ecs);
+}
+
+static void
+contact_modified_cb (EBookClient *book_client,
+                     const GError *error,
+                     gpointer closure)
+{
+	EditorCloseStruct *ecs = closure;
+	EContactEditor *ce = ecs->ce;
+	gboolean should_close = ecs->should_close;
+
+	gtk_widget_set_sensitive (ce->priv->app, TRUE);
+	ce->priv->in_async_call = FALSE;
+
+	eab_editor_contact_modified (EAB_EDITOR (ce), error, ce->priv->contact);
+
+	if (!error) {
+		if (should_close) {
+			eab_editor_close (EAB_EDITOR (ce));
+		}
+		else {
+			ce->priv->changed = FALSE;
+			sensitize_all (ce);
+		}
+	}
+
+	editor_close_struct_free (ecs);
+}
+
+static void
+contact_modified_ready_cb (GObject *source_object,
+                           GAsyncResult *result,
+                           gpointer user_data)
+{
+	EBookClient *book_client = E_BOOK_CLIENT (source_object);
+	GError *error = NULL;
+
+	e_book_client_modify_contact_finish (book_client, result, &error);
+
+	contact_modified_cb (book_client, error, user_data);
+
+	if (error != NULL)
+		g_error_free (error);
+}
+
+/* Emits the signal to request saving a contact */
+static void
+real_save_contact (EContactEditor *ce,
+                   gboolean should_close)
+{
+	EShell *shell;
+	EditorCloseStruct *ecs;
+	ESourceRegistry *registry;
+
+	shell = eab_editor_get_shell (EAB_EDITOR (ce));
+	registry = e_shell_get_registry (shell);
+
+	ecs = g_slice_new0 (EditorCloseStruct);
+	ecs->ce = g_object_ref (ce);
+	ecs->should_close = should_close;
+
+	gtk_widget_set_sensitive (ce->priv->app, FALSE);
+	ce->priv->in_async_call = TRUE;
+
+	if (ce->priv->source_client != ce->priv->target_client) {
+		/* Two-step move; add to target, then remove from source */
+		eab_merging_book_add_contact (
+			registry, ce->priv->target_client,
+			ce->priv->contact, contact_added_cb, ecs);
+	} else {
+		if (ce->priv->is_new_contact)
+			eab_merging_book_add_contact (
+				registry, ce->priv->target_client,
+				ce->priv->contact, contact_added_cb, ecs);
+		else if (ce->priv->check_merge)
+			eab_merging_book_modify_contact (
+				registry, ce->priv->target_client,
+				ce->priv->contact, contact_modified_cb, ecs);
+		else
+			e_book_client_modify_contact (
+				ce->priv->target_client, ce->priv->contact, E_BOOK_OPERATION_FLAG_NONE, NULL,
+				contact_modified_ready_cb, ecs);
+	}
+}
+
+static void
+save_contact (EContactEditor *ce,
+              gboolean should_close)
+{
+	gchar *uid;
+	const gchar *name_entry_string;
+	const gchar *file_as_entry_string;
+	const gchar *company_name_string;
+	GtkWidget *entry_fullname, *entry_file_as, *company_name, *client_combo_box;
+	ESource *active_source;
+
+	if (!ce->priv->target_client)
+		return;
+
+	client_combo_box = e_builder_get_widget (ce->priv->builder, "client-combo-box");
+	active_source = e_source_combo_box_ref_active (E_SOURCE_COMBO_BOX (client_combo_box));
+	g_return_if_fail (active_source != NULL);
+
+	if (!e_source_equal (e_client_get_source (E_CLIENT (ce->priv->target_client)), active_source)) {
+		e_alert_run_dialog_for_args (
+				GTK_WINDOW (ce->priv->app),
+				"addressbook:error-still-opening",
+				e_source_get_display_name (active_source),
+				NULL);
+		g_object_unref (active_source);
+		return;
+	}
+
+	g_object_unref (active_source);
+
+	if (ce->priv->target_editable && e_client_is_readonly (E_CLIENT (ce->priv->source_client))) {
+		if (e_alert_run_dialog_for_args (
+				GTK_WINDOW (ce->priv->app),
+				"addressbook:prompt-move",
+				NULL) == GTK_RESPONSE_NO)
+			return;
+	}
+
+	entry_fullname = e_builder_get_widget (ce->priv->builder, "entry-fullname");
+	entry_file_as = gtk_bin_get_child (
+		GTK_BIN (e_builder_get_widget (ce->priv->builder, "combo-file-as")));
+	company_name = e_builder_get_widget (ce->priv->builder, "entry-company");
+	name_entry_string = gtk_entry_get_text (GTK_ENTRY (entry_fullname));
+	file_as_entry_string = gtk_entry_get_text (GTK_ENTRY (entry_file_as));
+	company_name_string = gtk_entry_get_text (GTK_ENTRY (company_name));
+
+	if (strcmp (company_name_string , "")) {
+		if (!strcmp (name_entry_string, ""))
+			gtk_entry_set_text (
+				GTK_ENTRY (entry_fullname),
+				company_name_string);
+		if (!strcmp (file_as_entry_string, ""))
+			gtk_entry_set_text (
+				GTK_ENTRY (entry_file_as),
+				company_name_string);
+	}
+
+	extract_all (ce);
+
+	if (!e_contact_editor_is_valid (EAB_EDITOR (ce))) {
+		uid = e_contact_get (ce->priv->contact, E_CONTACT_UID);
+		g_object_unref (ce->priv->contact);
+		ce->priv->contact = e_contact_new ();
+		if (uid) {
+			e_contact_set (ce->priv->contact, E_CONTACT_UID, uid);
+			g_free (uid);
+		}
+		return;
+	}
+
+	real_save_contact (ce, should_close);
+}
+
+static void
+e_contact_editor_save_contact (EABEditor *editor,
+                               gboolean should_close)
+{
+	save_contact (E_CONTACT_EDITOR (editor), should_close);
+}
+
+/* Closes the dialog box and emits the appropriate signals */
+static void
+e_contact_editor_close (EABEditor *editor)
+{
+	EContactEditor *ce = E_CONTACT_EDITOR (editor);
+
+	if (ce->priv->app != NULL) {
+		gtk_widget_destroy (ce->priv->app);
+		ce->priv->app = NULL;
+		eab_editor_closed (editor);
+	}
+}
+
+static const EContactField  non_string_fields[] = {
+	E_CONTACT_FULL_NAME,
+	E_CONTACT_ADDRESS,
+	E_CONTACT_ADDRESS_HOME,
+	E_CONTACT_ADDRESS_WORK,
+	E_CONTACT_ADDRESS_OTHER,
+	E_CONTACT_EMAIL,
+	E_CONTACT_IM_AIM,
+	E_CONTACT_IM_GROUPWISE,
+	E_CONTACT_IM_JABBER,
+	E_CONTACT_IM_YAHOO,
+	E_CONTACT_IM_GADUGADU,
+	E_CONTACT_IM_MSN,
+	E_CONTACT_IM_ICQ,
+	E_CONTACT_IM_SKYPE,
+	E_CONTACT_IM_TWITTER,
+	E_CONTACT_IM_MATRIX,
+	E_CONTACT_PHOTO,
+	E_CONTACT_LOGO,
+	E_CONTACT_X509_CERT,
+	E_CONTACT_CATEGORY_LIST,
+	E_CONTACT_BIRTH_DATE,
+	E_CONTACT_ANNIVERSARY
+
+};
+
+static gboolean
+is_non_string_field (EContactField id)
+{
+	gint count = sizeof (non_string_fields) / sizeof (EContactField);
+	gint i;
+	for (i = 0; i < count; i++)
+		if (id == non_string_fields[i])
+			return TRUE;
+	return FALSE;
+
+}
+
+/* insert checks here (date format, for instance, etc.) */
+static gboolean
+e_contact_editor_is_valid (EABEditor *editor)
+{
+	EContactEditor *ce = E_CONTACT_EDITOR (editor);
+	GtkWidget *widget;
+	gboolean validation_error = FALSE;
+	GSList *iter;
+	GString *errmsg = g_string_new (_("The contact data is invalid:\n\n"));
+	time_t bday, now = time (NULL);
+
+	widget = e_builder_get_widget (ce->priv->builder, "dateedit-birthday");
+	if (!(e_date_edit_date_is_valid (E_DATE_EDIT (widget)))) {
+		g_string_append_printf (
+			errmsg, _("“%s” has an invalid format"),
+			e_contact_pretty_name (E_CONTACT_BIRTH_DATE));
+		validation_error = TRUE;
+	}
+	/* If valid, see if the birthday is a future date */
+	bday = e_date_edit_get_time (E_DATE_EDIT (widget));
+	if (bday > now) {
+		g_string_append_printf (
+			errmsg, _("“%s” cannot be a future date"),
+			e_contact_pretty_name (E_CONTACT_BIRTH_DATE));
+		validation_error = TRUE;
+	}
+
+	widget = e_builder_get_widget (ce->priv->builder, "dateedit-anniversary");
+	if (!(e_date_edit_date_is_valid (E_DATE_EDIT (widget)))) {
+		g_string_append_printf (
+			errmsg, _("%s“%s” has an invalid format"),
+			validation_error ? ",\n" : "",
+			e_contact_pretty_name (E_CONTACT_ANNIVERSARY));
+		validation_error = TRUE;
+	}
+
+	for (iter = ce->priv->required_fields; iter; iter = iter->next) {
+		const gchar *field_name = iter->data;
+		EContactField  field_id = e_contact_field_id (field_name);
+
+		if (is_non_string_field (field_id)) {
+			if (e_contact_get_const (ce->priv->contact, field_id) == NULL) {
+				g_string_append_printf (
+					errmsg, _("%s“%s” is empty"),
+					validation_error ? ",\n" : "",
+					e_contact_pretty_name (field_id));
+				validation_error = TRUE;
+				break;
+			}
+
+		} else {
+			const gchar *text;
+
+			text = e_contact_get_const (ce->priv->contact, field_id);
+
+			if (STRING_IS_EMPTY (text)) {
+				g_string_append_printf (
+					errmsg, _("%s“%s” is empty"),
+					validation_error ? ",\n" : "",
+					e_contact_pretty_name (field_id));
+				validation_error = TRUE;
+				break;
+			}
+
+		}
+	}
+
+	if (validation_error) {
+		g_string_append_c (errmsg, '.');
+		e_alert_run_dialog_for_args (
+			GTK_WINDOW (ce->priv->app),
+			"addressbook:generic-error",
+			_("Invalid contact."), errmsg->str, NULL);
+		g_string_free (errmsg, TRUE);
+		return FALSE;
+	}
+	else {
+		g_string_free (errmsg, TRUE);
+		return TRUE;
+	}
+}
+
+static gboolean
+e_contact_editor_is_changed (EABEditor *editor)
+{
+	return E_CONTACT_EDITOR (editor)->priv->changed;
+}
+
+static GtkWindow *
+e_contact_editor_get_window (EABEditor *editor)
+{
+	return GTK_WINDOW (E_CONTACT_EDITOR (editor)->priv->app);
+}
+
+static void
+file_save_and_close_cb (GtkWidget *widget,
+                        EContactEditor *ce)
+{
+	save_contact (ce, TRUE);
+}
+
+static void
+file_cancel_cb (GtkWidget *widget,
+                EContactEditor *ce)
+{
+	eab_editor_close (EAB_EDITOR (ce));
+}
+
+/* Callback used when the dialog box is destroyed */
+static gint
+app_delete_event_cb (GtkWidget *widget,
+                     GdkEvent *event,
+                     gpointer data)
+{
+	EContactEditor *ce;
+
+	ce = E_CONTACT_EDITOR (data);
+
+	/* if we're saving, don't allow the dialog to close */
+	if (ce->priv->in_async_call)
+		return TRUE;
+
+	if (ce->priv->changed) {
+		switch (eab_prompt_save_dialog (GTK_WINDOW (ce->priv->app))) {
+			case GTK_RESPONSE_YES:
+				eab_editor_save_contact (EAB_EDITOR (ce), TRUE);
+				return TRUE;
+
+			case GTK_RESPONSE_NO:
+				break;
+
+			case GTK_RESPONSE_CANCEL:
+			default:
+				return TRUE;
+
+		}
+	}
+
+	eab_editor_close (EAB_EDITOR (ce));
+	return TRUE;
+}
+
+static void
+show_help_cb (GtkWidget *widget,
+              gpointer data)
+{
+	/* FIXME Pass a proper parent window. */
+	e_display_help (NULL, "contacts-usage-add-contact");
+}
+
+static GList *
+add_to_tab_order (GList *list,
+                  GtkBuilder *builder,
+                  const gchar *name)
+{
+	GtkWidget *widget = e_builder_get_widget (builder, name);
+	return g_list_prepend (list, widget);
+}
+
+static void
+setup_tab_order (GtkBuilder *builder)
+{
+	GtkWidget *container;
+	GList *list = NULL;
+/*
+	container = e_builder_get_widget (builder, "table-contact-editor-general");
+ *
+	if (container) {
+		list = add_to_tab_order (list, builder, "entry-fullname");
+		list = add_to_tab_order (list, builder, "entry-jobtitle");
+		list = add_to_tab_order (list, builder, "entry-company");
+		list = add_to_tab_order (list, builder, "combo-file-as");
+		list = add_to_tab_order (list, builder, "entry-phone-1");
+		list = add_to_tab_order (list, builder, "entry-phone-2");
+		list = add_to_tab_order (list, builder, "entry-phone-3");
+		list = add_to_tab_order (list, builder, "entry-phone-4");
+ *
+		list = add_to_tab_order (list, builder, "entry-email1");
+		list = add_to_tab_order (list, builder, "alignment-htmlmail");
+		list = add_to_tab_order (list, builder, "entry-web");
+		list = add_to_tab_order (list, builder, "entry-homepage");
+		list = add_to_tab_order (list, builder, "button-fulladdr");
+		list = add_to_tab_order (list, builder, "text-address");
+		list = g_list_reverse (list);
+		e_container_change_tab_order (GTK_CONTAINER (container), list);
+		g_list_free (list);
+	}
+*/
+
+	container = e_builder_get_widget (builder, "table-home-address");
+	gtk_container_get_focus_chain (GTK_CONTAINER (container), &list);
+
+	list = add_to_tab_order (list, builder, "scrolledwindow-home-address");
+	list = add_to_tab_order (list, builder, "entry-home-city");
+	list = add_to_tab_order (list, builder, "entry-home-zip");
+	list = add_to_tab_order (list, builder, "entry-home-state");
+	list = add_to_tab_order (list, builder, "entry-home-pobox");
+	list = add_to_tab_order (list, builder, "entry-home-country");
+	list = g_list_reverse (list);
+
+	gtk_container_set_focus_chain (GTK_CONTAINER (container), list);
+	g_list_free (list);
+
+	container = e_builder_get_widget (builder, "table-work-address");
+	gtk_container_get_focus_chain (GTK_CONTAINER (container), &list);
+
+	list = add_to_tab_order (list, builder, "scrolledwindow-work-address");
+	list = add_to_tab_order (list, builder, "entry-work-city");
+	list = add_to_tab_order (list, builder, "entry-work-zip");
+	list = add_to_tab_order (list, builder, "entry-work-state");
+	list = add_to_tab_order (list, builder, "entry-work-pobox");
+	list = add_to_tab_order (list, builder, "entry-work-country");
+	list = g_list_reverse (list);
+
+	gtk_container_set_focus_chain (GTK_CONTAINER (container), list);
+	g_list_free (list);
+
+	container = e_builder_get_widget (builder, "table-other-address");
+	gtk_container_get_focus_chain (GTK_CONTAINER (container), &list);
+
+	list = add_to_tab_order (list, builder, "scrolledwindow-other-address");
+	list = add_to_tab_order (list, builder, "entry-other-city");
+	list = add_to_tab_order (list, builder, "entry-other-zip");
+	list = add_to_tab_order (list, builder, "entry-other-state");
+	list = add_to_tab_order (list, builder, "entry-other-pobox");
+	list = add_to_tab_order (list, builder, "entry-other-country");
+	list = g_list_reverse (list);
+
+	gtk_container_set_focus_chain (GTK_CONTAINER (container), list);
+	g_list_free (list);
+}
+
+static void
+expand_dyntable (GtkExpander *expander,
+		 EContactEditorDynTable *dyntable,
+		 gint max_slots)
+{
+	if (gtk_expander_get_expanded (expander)) {
+		e_contact_editor_dyntable_set_show_max (dyntable, max_slots);
+	} else {
+		e_contact_editor_dyntable_set_show_max (dyntable,
+				SLOTS_IN_COLLAPSED_STATE);
+	}
+}
+
+static void
+expander_contact_mail_cb (GObject *object,
+                          GParamSpec *param_spec,
+                          gpointer user_data)
+{
+	expand_dyntable (GTK_EXPANDER (object),
+			E_CONTACT_EDITOR_DYNTABLE (user_data),
+			EMAIL_SLOTS);
+}
+
+static void
+expander_contact_phone_cb (GObject *object,
+                           GParamSpec *param_spec,
+                           gpointer user_data)
+{
+	expand_dyntable (GTK_EXPANDER (object),
+			E_CONTACT_EDITOR_DYNTABLE (user_data),
+			PHONE_SLOTS);
+}
+
+static void
+expander_contact_sip_cb (GObject *object,
+                         GParamSpec *param_spec,
+                         gpointer user_data)
+{
+	expand_dyntable (GTK_EXPANDER (object),
+			E_CONTACT_EDITOR_DYNTABLE (user_data),
+			SIP_SLOTS);
+}
+
+static void
+expander_contact_im_cb (GObject *object,
+                        GParamSpec *param_spec,
+                        gpointer user_data)
+{
+	expand_dyntable (GTK_EXPANDER (object),
+			E_CONTACT_EDITOR_DYNTABLE (user_data),
+			IM_SLOTS);
+}
+
+static void
+contact_editor_focus_widget_changed_cb (EFocusTracker *focus_tracker,
+                                        GParamSpec *param,
+                                        EContactEditor *editor)
+{
+	GtkWidget *widget;
+
+	widget = e_focus_tracker_get_focus (focus_tracker);
+
+	/* there is no problem to call the attach multiple times */
+	if (widget)
+		e_widget_undo_attach (widget, focus_tracker);
+}
+
+static void
+e_contact_editor_init (EContactEditor *e_contact_editor)
+{
+	GtkBuilder *builder;
+	EShell *shell;
+	EClientCache *client_cache;
+	GtkWidget *container;
+	GtkWidget *widget, *label, *dyntable;
+	GtkEntryCompletion *completion;
+
+	e_contact_editor->priv = G_TYPE_INSTANCE_GET_PRIVATE (
+		e_contact_editor, E_TYPE_CONTACT_EDITOR, EContactEditorPrivate);
+
+	/* FIXME The shell should be obtained
+	 *       through a constructor property. */
+	shell = e_shell_get_default ();
+	client_cache = e_shell_get_client_cache (shell);
+
+	e_contact_editor->priv->name = e_contact_name_new ();
+
+	e_contact_editor->priv->contact = NULL;
+	e_contact_editor->priv->changed = FALSE;
+	e_contact_editor->priv->check_merge = FALSE;
+	e_contact_editor->priv->image_set = FALSE;
+	e_contact_editor->priv->image_changed = FALSE;
+	e_contact_editor->priv->in_async_call = FALSE;
+	e_contact_editor->priv->target_editable = TRUE;
+	e_contact_editor->priv->fullname_dialog = NULL;
+	e_contact_editor->priv->categories_dialog = NULL;
+	e_contact_editor->priv->compress_ui = e_shell_get_express_mode (shell);
+
+	/* Make sure custom widget types are available */
+	g_type_ensure (E_TYPE_IMAGE_CHOOSER);
+	g_type_ensure (E_TYPE_CLIENT_COMBO_BOX);
+	g_type_ensure (E_TYPE_CONTACT_EDITOR_DYNTABLE);
+	g_type_ensure (E_TYPE_URL_ENTRY);
+	g_type_ensure (E_TYPE_DATE_EDIT);
+
+	builder = gtk_builder_new ();
+	e_load_ui_builder_definition (builder, "contact-editor.ui");
+
+	e_contact_editor->priv->builder = builder;
+
+	setup_tab_order (builder);
+
+	e_contact_editor->priv->app =
+		e_builder_get_widget (builder, "contact editor");
+	widget = e_contact_editor->priv->app;
+
+	gtk_window_set_type_hint (
+		GTK_WINDOW (widget), GDK_WINDOW_TYPE_HINT_NORMAL);
+	container = gtk_dialog_get_action_area (GTK_DIALOG (widget));
+	gtk_container_set_border_width (GTK_CONTAINER (container), 12);
+	container = gtk_dialog_get_content_area (GTK_DIALOG (widget));
+	gtk_container_set_border_width (GTK_CONTAINER (container), 0);
+
+	init_all (e_contact_editor);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "button-image");
+	g_signal_connect (
+		widget, "clicked",
+		G_CALLBACK (image_clicked), e_contact_editor);
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "button-fullname");
+	g_signal_connect (
+		widget, "clicked",
+		G_CALLBACK (full_name_clicked), e_contact_editor);
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "button-categories");
+	g_signal_connect (
+		widget, "clicked",
+		G_CALLBACK (categories_clicked), e_contact_editor);
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "client-combo-box");
+	e_client_combo_box_set_client_cache (
+		E_CLIENT_COMBO_BOX (widget), client_cache);
+	g_signal_connect (
+		widget, "changed",
+		G_CALLBACK (source_changed), e_contact_editor);
+	label = e_builder_get_widget (
+		e_contact_editor->priv->builder, "where-label");
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), widget);
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "button-ok");
+	g_signal_connect (
+		widget, "clicked",
+		G_CALLBACK (file_save_and_close_cb), e_contact_editor);
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "button-cancel");
+	g_signal_connect (
+		widget, "clicked",
+		G_CALLBACK (file_cancel_cb), e_contact_editor);
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "button-help");
+	g_signal_connect (
+		widget, "clicked",
+		G_CALLBACK (show_help_cb), e_contact_editor);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "expander-contact-phone");
+	dyntable = e_builder_get_widget (
+		e_contact_editor->priv->builder, "phone-dyntable");
+	g_signal_connect (widget, "notify::expanded",
+	                  G_CALLBACK (expander_contact_phone_cb), dyntable);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "expander-contact-sip");
+	dyntable = e_builder_get_widget (
+		e_contact_editor->priv->builder, "sip-dyntable");
+	g_signal_connect (widget, "notify::expanded",
+	                  G_CALLBACK (expander_contact_sip_cb), dyntable);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "expander-contact-im");
+	dyntable = e_builder_get_widget (
+		e_contact_editor->priv->builder, "im-dyntable");
+	g_signal_connect (widget, "notify::expanded",
+	                  G_CALLBACK (expander_contact_im_cb), dyntable);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "expander-contact-email");
+	dyntable = e_builder_get_widget (
+		e_contact_editor->priv->builder, "mail-dyntable");
+	g_signal_connect (widget, "notify::expanded",
+	                  G_CALLBACK (expander_contact_mail_cb), dyntable);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "entry-fullname");
+	if (widget)
+		gtk_widget_grab_focus (widget);
+
+	widget = e_builder_get_widget (
+		e_contact_editor->priv->builder, "entry-categories");
+	completion = e_category_completion_new ();
+	gtk_entry_set_completion (GTK_ENTRY (widget), completion);
+	g_object_unref (completion);
+
+	/* Connect to the deletion of the dialog */
+
+	g_signal_connect (
+		e_contact_editor->priv->app, "delete_event",
+		G_CALLBACK (app_delete_event_cb), e_contact_editor);
+
+	/* set the icon */
+	gtk_window_set_icon_name (
+		GTK_WINDOW (e_contact_editor->priv->app), "contact-editor");
+
+	gtk_application_add_window (
+		GTK_APPLICATION (shell),
+		GTK_WINDOW (e_contact_editor->priv->app));
+}
+
+static void
+e_contact_editor_constructed (GObject *object)
+{
+	const gchar *ui =
+		"<ui>"
+		"  <menubar name='undo-menubar'>"
+		"      <menu action='undo-menu'>"
+		"      <menuitem action='undo'/>"
+		"    <menuitem action='redo'/>"
+		"    </menu>"
+		"  </menubar>"
+		"</ui>";
+	EContactEditor *editor = E_CONTACT_EDITOR (object);
+	GtkActionGroup *action_group;
+	GtkAction *action;
+	GError *error = NULL;
+
+	/* Chain up to parent's method. */
+	G_OBJECT_CLASS (parent_class)->constructed (object);
+
+	editor->priv->focus_tracker = e_focus_tracker_new (GTK_WINDOW (editor->priv->app));
+	editor->priv->ui_manager = gtk_ui_manager_new ();
+
+	gtk_window_add_accel_group (
+		GTK_WINDOW (editor->priv->app),
+		gtk_ui_manager_get_accel_group (editor->priv->ui_manager));
+
+	e_signal_connect_notify (
+		editor->priv->focus_tracker, "notify::focus",
+		G_CALLBACK (contact_editor_focus_widget_changed_cb), editor);
+
+	action_group = gtk_action_group_new ("undo");
+	gtk_action_group_set_translation_domain (
+		action_group, GETTEXT_PACKAGE);
+	gtk_action_group_add_actions (
+		action_group, undo_entries,
+		G_N_ELEMENTS (undo_entries), editor);
+	gtk_ui_manager_insert_action_group (
+		editor->priv->ui_manager, action_group, 0);
+
+	action = gtk_action_group_get_action (action_group, "undo");
+	e_focus_tracker_set_undo_action (editor->priv->focus_tracker, action);
+
+	action = gtk_action_group_get_action (action_group, "redo");
+	e_focus_tracker_set_redo_action (editor->priv->focus_tracker, action);
+
+	g_object_unref (action_group);
+
+	gtk_ui_manager_add_ui_from_string (editor->priv->ui_manager, ui, -1, &error);
+	if (error != NULL) {
+		g_warning ("%s: %s", G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+}
+
+static void
+e_contact_editor_dispose (GObject *object)
+{
+	EContactEditor *e_contact_editor = E_CONTACT_EDITOR (object);
+
+	g_clear_pointer (&e_contact_editor->priv->image_selector, gtk_widget_destroy);
+	g_clear_object (&e_contact_editor->priv->image_selector_native);
+
+	g_slist_free_full (
+		e_contact_editor->priv->writable_fields,
+		(GDestroyNotify) g_free);
+	e_contact_editor->priv->writable_fields = NULL;
+
+	g_slist_free_full (
+		e_contact_editor->priv->required_fields,
+		(GDestroyNotify) g_free);
+	e_contact_editor->priv->required_fields = NULL;
+
+	if (e_contact_editor->priv->target_client) {
+		g_signal_handler_disconnect (
+			e_contact_editor->priv->target_client,
+			e_contact_editor->priv->target_editable_id);
+	}
+
+	g_clear_pointer (&e_contact_editor->priv->name, e_contact_name_free);
+
+	if (e_contact_editor->priv->focus_tracker) {
+		g_signal_handlers_disconnect_by_data (
+			e_contact_editor->priv->focus_tracker,
+			e_contact_editor);
+	}
+
+	g_clear_object (&e_contact_editor->priv->contact);
+	g_clear_object (&e_contact_editor->priv->source_client);
+	g_clear_object (&e_contact_editor->priv->target_client);
+	g_clear_object (&e_contact_editor->priv->builder);
+	g_clear_object (&e_contact_editor->priv->ui_manager);
+	g_clear_object (&e_contact_editor->priv->cancellable);
+	g_clear_object (&e_contact_editor->priv->focus_tracker);
+
+	/* Chain up to parent's dispose() method. */
+	G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+supported_fields_cb (GObject *source_object,
+                     GAsyncResult *result,
+                     gpointer user_data)
+{
+	EBookClient *book_client = E_BOOK_CLIENT (source_object);
+	EContactEditor *ce = user_data;
+	gchar *prop_value = NULL;
+	GSList *fields;
+	gboolean success;
+	GError *error = NULL;
+
+	success = e_client_get_backend_property_finish (
+		E_CLIENT (book_client), result, &prop_value, &error);
+
+	if (!success)
+		prop_value = NULL;
+
+	if (error != NULL) {
+		g_warning (
+			"%s: Failed to get supported fields: %s",
+			G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+
+	if (!g_slist_find (eab_editor_get_all_editors (), ce)) {
+		g_warning (
+			"supported_fields_cb called for book that's still "
+			"around, but contact editor that's been destroyed.");
+		g_free (prop_value);
+		return;
+	}
+
+	fields = e_client_util_parse_comma_strings (prop_value);
+
+	g_object_set (ce, "writable_fields", fields, NULL);
+
+	g_slist_free_full (fields, (GDestroyNotify) g_free);
+	g_free (prop_value);
+
+	eab_editor_show (EAB_EDITOR (ce));
+
+	sensitize_all (ce);
+}
+
+static void
+required_fields_cb (GObject *source_object,
+                    GAsyncResult *result,
+                    gpointer user_data)
+{
+	EBookClient *book_client = E_BOOK_CLIENT (source_object);
+	EContactEditor *ce = user_data;
+	gchar *prop_value = NULL;
+	GSList *fields;
+	gboolean success;
+	GError *error = NULL;
+
+	success = e_client_get_backend_property_finish (
+		E_CLIENT (book_client), result, &prop_value, &error);
+
+	if (!success)
+		prop_value = NULL;
+
+	if (error != NULL) {
+		g_warning (
+			"%s: Failed to get supported fields: %s",
+			G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+
+	if (!g_slist_find (eab_editor_get_all_editors (), ce)) {
+		g_warning (
+			"supported_fields_cb called for book that's still "
+			"around, but contact editor that's been destroyed.");
+		g_free (prop_value);
+		return;
+	}
+
+	fields = e_client_util_parse_comma_strings (prop_value);
+
+	g_object_set (ce, "required_fields", fields, NULL);
+
+	g_slist_free_full (fields, (GDestroyNotify) g_free);
+	g_free (prop_value);
+}
+
+EABEditor *
+e_contact_editor_new (EShell *shell,
+                      EBookClient *book_client,
+                      EContact *contact,
+                      gboolean is_new_contact,
+                      gboolean editable)
+{
+	EABEditor *editor;
+
+	g_return_val_if_fail (E_IS_SHELL (shell), NULL);
+	g_return_val_if_fail (E_IS_BOOK_CLIENT (book_client), NULL);
+	g_return_val_if_fail (E_IS_CONTACT (contact), NULL);
+
+	editor = g_object_new (E_TYPE_CONTACT_EDITOR, "shell", shell, NULL);
+
+	g_object_set (
+		editor,
+		"source_client", book_client,
+		"contact", contact,
+		"is_new_contact", is_new_contact,
+		"editable", editable,
+		NULL);
+
+	return editor;
+}
+
+static void
+notify_readonly_cb (EBookClient *book_client,
+                    GParamSpec *pspec,
+                    EContactEditor *ce)
+{
+	EClient *client;
+	gint new_target_editable;
+	gboolean changed = FALSE;
+
+	client = E_CLIENT (ce->priv->target_client);
+	new_target_editable = !e_client_is_readonly (client);
+
+	if (ce->priv->target_editable != new_target_editable)
+		changed = TRUE;
+
+	ce->priv->target_editable = new_target_editable;
+
+	if (changed)
+		sensitize_all (ce);
+}
+
+static void
+e_contact_editor_set_property (GObject *object,
+                               guint property_id,
+                               const GValue *value,
+                               GParamSpec *pspec)
+{
+	EContactEditor *editor;
+
+	editor = E_CONTACT_EDITOR (object);
+
+	switch (property_id) {
+	case PROP_SOURCE_CLIENT: {
+		gboolean  writable;
+		gboolean  changed = FALSE;
+		EBookClient *source_client;
+
+		source_client = E_BOOK_CLIENT (g_value_get_object (value));
+
+		if (source_client == editor->priv->source_client)
+			break;
+
+		if (editor->priv->source_client)
+			g_object_unref (editor->priv->source_client);
+
+		editor->priv->source_client = source_client;
+		g_object_ref (editor->priv->source_client);
+
+		if (!editor->priv->target_client) {
+			editor->priv->target_client = editor->priv->source_client;
+			g_object_ref (editor->priv->target_client);
+
+			editor->priv->target_editable_id = e_signal_connect_notify (
+				editor->priv->target_client, "notify::readonly",
+				G_CALLBACK (notify_readonly_cb), editor);
+
+			e_client_get_backend_property (
+				E_CLIENT (editor->priv->target_client),
+				E_BOOK_BACKEND_PROPERTY_SUPPORTED_FIELDS,
+				NULL, supported_fields_cb, editor);
+
+			e_client_get_backend_property (
+				E_CLIENT (editor->priv->target_client),
+				E_BOOK_BACKEND_PROPERTY_REQUIRED_FIELDS,
+				NULL, required_fields_cb, editor);
+		}
+
+		writable = !e_client_is_readonly (E_CLIENT (editor->priv->target_client));
+		if (writable != editor->priv->target_editable) {
+			editor->priv->target_editable = writable;
+			changed = TRUE;
+		}
+
+		if (changed)
+			sensitize_all (editor);
+
+		break;
+	}
+
+	case PROP_TARGET_CLIENT: {
+		gboolean  writable;
+		gboolean  changed = FALSE;
+		EBookClient *target_client;
+
+		target_client = E_BOOK_CLIENT (g_value_get_object (value));
+
+		if (target_client == editor->priv->target_client)
+			break;
+
+		if (editor->priv->target_client) {
+			g_signal_handler_disconnect (
+				editor->priv->target_client,
+				editor->priv->target_editable_id);
+			g_object_unref (editor->priv->target_client);
+		}
+
+		editor->priv->target_client = target_client;
+		g_object_ref (editor->priv->target_client);
+
+		editor->priv->target_editable_id = e_signal_connect_notify (
+			editor->priv->target_client, "notify::readonly",
+			G_CALLBACK (notify_readonly_cb), editor);
+
+		e_client_get_backend_property (
+			E_CLIENT (editor->priv->target_client),
+			E_BOOK_BACKEND_PROPERTY_SUPPORTED_FIELDS,
+			NULL, supported_fields_cb, editor);
+
+		e_client_get_backend_property (
+			E_CLIENT (editor->priv->target_client),
+			E_BOOK_BACKEND_PROPERTY_REQUIRED_FIELDS,
+			NULL, required_fields_cb, editor);
+
+		if (!editor->priv->is_new_contact)
+			editor->priv->changed = TRUE;
+
+		writable = !e_client_is_readonly (E_CLIENT (editor->priv->target_client));
+
+		if (writable != editor->priv->target_editable) {
+			editor->priv->target_editable = writable;
+			changed = TRUE;
+		}
+
+		if (changed)
+			sensitize_all (editor);
+
+		break;
+	}
+
+	case PROP_CONTACT:
+		if (editor->priv->contact)
+			g_object_unref (editor->priv->contact);
+		editor->priv->contact = e_contact_duplicate (
+			E_CONTACT (g_value_get_object (value)));
+		fill_in_all (editor);
+		editor->priv->changed = FALSE;
+		break;
+
+	case PROP_IS_NEW_CONTACT:
+		editor->priv->is_new_contact = g_value_get_boolean (value);
+		break;
+
+	case PROP_EDITABLE: {
+		gboolean new_value = g_value_get_boolean (value);
+		gboolean changed = (editor->priv->target_editable != new_value);
+
+		editor->priv->target_editable = new_value;
+
+		if (changed)
+			sensitize_all (editor);
+		break;
+	}
+
+	case PROP_CHANGED: {
+		gboolean new_value = g_value_get_boolean (value);
+		gboolean changed = (editor->priv->changed != new_value);
+
+		editor->priv->changed = new_value;
+
+		if (changed)
+			sensitize_ok (editor);
+		break;
+	}
+	case PROP_WRITABLE_FIELDS:
+		g_slist_free_full (
+			editor->priv->writable_fields,
+			(GDestroyNotify) g_free);
+		editor->priv->writable_fields = g_slist_copy_deep (
+			g_value_get_pointer (value),
+			(GCopyFunc) g_strdup, NULL);
+
+		sensitize_all (editor);
+		break;
+	case PROP_REQUIRED_FIELDS:
+		g_slist_free_full (
+			editor->priv->required_fields,
+			(GDestroyNotify) g_free);
+		editor->priv->required_fields = g_slist_copy_deep (
+			g_value_get_pointer (value),
+			(GCopyFunc) g_strdup, NULL);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+		break;
+	}
+}
+
+static void
+e_contact_editor_get_property (GObject *object,
+                               guint property_id,
+                               GValue *value,
+                               GParamSpec *pspec)
+{
+	EContactEditor *e_contact_editor;
+
+	e_contact_editor = E_CONTACT_EDITOR (object);
+
+	switch (property_id) {
+	case PROP_SOURCE_CLIENT:
+		g_value_set_object (value, e_contact_editor->priv->source_client);
+		break;
+
+	case PROP_TARGET_CLIENT:
+		g_value_set_object (value, e_contact_editor->priv->target_client);
+		break;
+
+	case PROP_CONTACT:
+		extract_all (e_contact_editor);
+		g_value_set_object (value, e_contact_editor->priv->contact);
+		break;
+
+	case PROP_IS_NEW_CONTACT:
+		g_value_set_boolean (
+			value, e_contact_editor->priv->is_new_contact);
+		break;
+
+	case PROP_EDITABLE:
+		g_value_set_boolean (
+			value, e_contact_editor->priv->target_editable);
+		break;
+
+	case PROP_CHANGED:
+		g_value_set_boolean (
+			value, e_contact_editor->priv->changed);
+		break;
+
+	case PROP_WRITABLE_FIELDS:
+		g_value_set_pointer (value, e_contact_editor->priv->writable_fields);
+		break;
+	case PROP_REQUIRED_FIELDS:
+		g_value_set_pointer (value, e_contact_editor->priv->required_fields);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+		break;
+	}
+}
+
+/**
+ * e_contact_editor_raise:
+ * @config: The %EContactEditor object.
+ *
+ * Raises the dialog associated with this %EContactEditor object.
+ */
+static void
+e_contact_editor_raise (EABEditor *editor)
+{
+	EContactEditor *ce = E_CONTACT_EDITOR (editor);
+	GdkWindow *window;
+
+	window = gtk_widget_get_window (ce->priv->app);
+
+	if (window != NULL)
+		gdk_window_raise (window);
+}
+
+/**
+ * e_contact_editor_show:
+ * @ce: The %EContactEditor object.
+ *
+ * Shows the dialog associated with this %EContactEditor object.
+ */
+static void
+e_contact_editor_show (EABEditor *editor)
+{
+	EContactEditor *ce = E_CONTACT_EDITOR (editor);
+	gtk_widget_show (ce->priv->app);
+}
diff -urN a/src/addressbook/gui/widgets/eab-contact-display.c b/src/addressbook/gui/widgets/eab-contact-display.c
--- a/src/addressbook/gui/widgets/eab-contact-display.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/addressbook/gui/widgets/eab-contact-display.c	2022-01-08 18:47:17.601546307 -0800
@@ -183,7 +183,7 @@
 	{ "contact-mailto-copy",
 	  "edit-copy",
 	  N_("Copy _Email Address"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the email address to the clipboard"),
 	  G_CALLBACK (action_contact_mailto_copy_cb) },
 
diff -urN a/src/calendar/gui/ea-cal-view.c b/src/calendar/gui/ea-cal-view.c
--- a/src/calendar/gui/ea-cal-view.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/calendar/gui/ea-cal-view.c	2022-01-08 18:47:17.601546307 -0800
@@ -371,19 +371,19 @@
 	 switch (index) {
 	 case 0:
 		 /* New Appointment */
-		 return "<Alt>fna;<Control>n";
+		 return "<Alt>fna;<Super>n";
 	 case 1:
 		 /* New Event */
-		 return "<Alt>fnd;<Shift><Control>d";
+		 return "<Alt>fnd;<Shift><Super>d";
 	 case 2:
 		 /* New Meeting */
-		 return "<Alt>fne;<Shift><Control>e";
+		 return "<Alt>fne;<Shift><Super>e";
 	 case 3:
 		 /* Go to today */
-		 return "<Alt>vt;<Alt><Control>t";
+		 return "<Alt>vt;<Alt><Super>t";
 	 case 4:
 		 /* Go to date */
-		 return "<Alt>vd;<Alt><Control>g";
+		 return "<Alt>vd;<Alt><Super>g";
 	 default:
 		 break;
 	 }
diff -urN a/src/calendar/gui/e-comp-editor.c b/src/calendar/gui/e-comp-editor.c
--- a/src/calendar/gui/e-comp-editor.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor.c	2022-01-08 18:47:17.601546307 -0800
@@ -2104,21 +2104,21 @@
 		{ "close",
 		  "window-close",
 		  N_("_Close"),
-		  "<Control>w",
+		  "<Super>w",
 		  N_("Close the current window"),
 		  G_CALLBACK (action_close_cb) },
 
 		{ "copy-clipboard",
 		  "edit-copy",
 		  N_("_Copy"),
-		  "<Control>c",
+		  "<Super>c",
 		  N_("Copy the selection"),
 		  NULL },  /* Handled by EFocusTracker */
 
 		{ "cut-clipboard",
 		  "edit-cut",
 		  N_("Cu_t"),
-		  "<Control>x",
+		  "<Super>x",
 		  N_("Cut the selection"),
 		  NULL },  /* Handled by EFocusTracker */
 
@@ -2139,14 +2139,14 @@
 		{ "paste-clipboard",
 		  "edit-paste",
 		  N_("_Paste"),
-		  "<Control>v",
+		  "<Super>v",
 		  N_("Paste the clipboard"),
 		  NULL },  /* Handled by EFocusTracker */
 
 		{ "print",
 		  "document-print",
 		  N_("_Print…"),
-		  "<Control>p",
+		  "<Super>p",
 		  NULL,
 		  G_CALLBACK (action_print_cb) },
 
@@ -2160,21 +2160,21 @@
 		{ "select-all",
 		  "edit-select-all",
 		  N_("Select _All"),
-		  "<Control>a",
+		  "<Super>a",
 		  N_("Select all text"),
 		  NULL },  /* Handled by EFocusTracker */
 
 		{ "undo",
 		  "edit-undo",
 		  N_("_Undo"),
-		  "<Control>z",
+		  "<Super>z",
 		  N_("Undo"),
 		  NULL },  /* Handled by EFocusTracker */
 
 		{ "redo",
 		  "edit-redo",
 		  N_("_Redo"),
-		  "<Control>y",
+		  "<Super>y",
 		  N_("Redo"),
 		  NULL },  /* Handled by EFocusTracker */
 
@@ -2235,14 +2235,14 @@
 		{ "save",
 		  "document-save",
 		  N_("_Save"),
-		  "<Control>s",
+		  "<Super>s",
 		  N_("Save current changes"),
 		  G_CALLBACK (action_save_cb) },
 
 		{ "save-and-close",
 		  NULL,
 		  N_("Save and Close"),
-		  "<Control>Return",
+		  "<Alt><Super>S",
 		  N_("Save current changes and close editor"),
 		  G_CALLBACK (action_save_and_close_cb) }
 	};
diff -urN a/src/calendar/gui/e-comp-editor-event.c b/src/calendar/gui/e-comp-editor-event.c
--- a/src/calendar/gui/e-comp-editor-event.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor-event.c	2022-01-08 18:47:17.601546307 -0800
@@ -737,7 +737,7 @@
 		{ "all-day-event",
 		  "stock_new-24h-appointment",
 		  N_("All _Day Event"),
-		  "<Control>Y",
+		  "<Super>Y",
 		  N_("Toggles whether to have All Day Event"),
 		  NULL,
 		  FALSE },
diff -urN a/src/calendar/gui/e-comp-editor-event.c.orig b/src/calendar/gui/e-comp-editor-event.c.orig
--- a/src/calendar/gui/e-comp-editor-event.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor-event.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,1035 @@
+/*
+ * Copyright (C) 2015 Red Hat, Inc. (www.redhat.com)
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "evolution-config.h"
+
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include <e-util/e-util.h>
+
+#include "calendar-config.h"
+#include "comp-util.h"
+#include "e-comp-editor.h"
+#include "e-comp-editor-page.h"
+#include "e-comp-editor-page-attachments.h"
+#include "e-comp-editor-page-general.h"
+#include "e-comp-editor-page-recurrence.h"
+#include "e-comp-editor-page-reminders.h"
+#include "e-comp-editor-page-schedule.h"
+#include "e-comp-editor-property-parts.h"
+#include "e-timezone-entry.h"
+
+#include "e-comp-editor-event.h"
+
+struct _ECompEditorEventPrivate {
+	ECompEditorPage *page_general;
+	ECompEditorPropertyPart *dtstart;
+	ECompEditorPropertyPart *dtend;
+	ECompEditorPropertyPart *categories;
+	ECompEditorPropertyPart *timezone;
+	ECompEditorPropertyPart *transparency;
+	ECompEditorPropertyPart *description;
+	GtkWidget *all_day_check;
+
+	gpointer in_the_past_alert;
+	gpointer insensitive_info_alert;
+};
+
+G_DEFINE_TYPE (ECompEditorEvent, e_comp_editor_event, E_TYPE_COMP_EDITOR)
+
+static void
+ece_event_action_classification_cb (GtkRadioAction *action,
+				    GtkRadioAction *current,
+				    ECompEditorEvent *event_editor)
+{
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+
+	e_comp_editor_set_changed (E_COMP_EDITOR (event_editor), TRUE);
+}
+
+static void
+ece_event_update_times (ECompEditorEvent *event_editor,
+			EDateEdit *date_edit,
+			gboolean change_end_datetime)
+{
+	guint flags;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+	g_return_if_fail (E_IS_DATE_EDIT (date_edit));
+
+	if (e_date_edit_has_focus (date_edit) ||
+	    !e_date_edit_date_is_valid (date_edit) ||
+	    !e_date_edit_time_is_valid (date_edit))
+		return;
+
+	if (!e_comp_editor_get_updating (E_COMP_EDITOR (event_editor))) {
+		e_comp_editor_ensure_start_before_end (E_COMP_EDITOR (event_editor),
+			event_editor->priv->dtstart,
+			event_editor->priv->dtend,
+			change_end_datetime);
+		e_comp_editor_ensure_same_value_type (E_COMP_EDITOR (event_editor),
+			change_end_datetime ? event_editor->priv->dtstart : event_editor->priv->dtend,
+			change_end_datetime ? event_editor->priv->dtend : event_editor->priv->dtstart);
+	}
+
+	flags = e_comp_editor_get_flags (E_COMP_EDITOR (event_editor));
+
+	if ((flags & E_COMP_EDITOR_FLAG_IS_NEW) != 0) {
+		ICalTime *start_tt;
+
+		start_tt = e_comp_editor_property_part_datetime_get_value (
+			E_COMP_EDITOR_PROPERTY_PART_DATETIME (event_editor->priv->dtstart));
+
+		if (cal_comp_util_compare_time_with_today (start_tt) < 0) {
+			if (!event_editor->priv->in_the_past_alert) {
+				EAlert *alert;
+
+				alert = e_comp_editor_add_warning (E_COMP_EDITOR (event_editor),
+					_("Event’s time is in the past"), NULL);
+
+				event_editor->priv->in_the_past_alert = alert;
+
+				if (alert)
+					g_object_add_weak_pointer (G_OBJECT (alert), &event_editor->priv->in_the_past_alert);
+
+				g_clear_object (&alert);
+			}
+		} else if (event_editor->priv->in_the_past_alert) {
+			e_alert_response (event_editor->priv->in_the_past_alert, GTK_RESPONSE_OK);
+		}
+
+		g_clear_object (&start_tt);
+	}
+}
+
+static void
+ece_event_dtstart_changed_cb (EDateEdit *date_edit,
+			      ECompEditorEvent *event_editor)
+{
+	g_return_if_fail (E_IS_DATE_EDIT (date_edit));
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+
+	if (!e_date_edit_has_focus (date_edit))
+		ece_event_update_times (event_editor, date_edit, TRUE);
+}
+
+static void
+ece_event_dtend_changed_cb (EDateEdit *date_edit,
+			    ECompEditorEvent *event_editor)
+{
+	g_return_if_fail (E_IS_DATE_EDIT (date_edit));
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+
+	if (!e_date_edit_has_focus (date_edit))
+		ece_event_update_times (event_editor, date_edit, FALSE);
+}
+
+static void
+ece_event_all_day_toggled_cb (ECompEditorEvent *event_editor)
+{
+	GtkWidget *edit_widget;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->dtstart);
+
+	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (event_editor->priv->all_day_check))) {
+		gint hour, minute;
+
+		if (!e_date_edit_get_time_of_day (E_DATE_EDIT (edit_widget), &hour, &minute))
+			e_date_edit_set_time_of_day (E_DATE_EDIT (edit_widget), 0, 0);
+	}
+
+	ece_event_update_times (event_editor, E_DATE_EDIT (edit_widget), TRUE);
+
+	e_comp_editor_ensure_changed (E_COMP_EDITOR (event_editor));
+}
+
+static void
+ece_event_sensitize_widgets (ECompEditor *comp_editor,
+			     gboolean force_insensitive)
+{
+	ECompEditorEvent *event_editor;
+	gboolean is_organizer;
+	GtkAction *action;
+	GtkWidget *widget;
+	guint32 flags;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (comp_editor));
+
+	E_COMP_EDITOR_CLASS (e_comp_editor_event_parent_class)->sensitize_widgets (comp_editor, force_insensitive);
+
+	flags = e_comp_editor_get_flags (comp_editor);
+	is_organizer = (flags & (E_COMP_EDITOR_FLAG_IS_NEW | E_COMP_EDITOR_FLAG_ORGANIZER_IS_USER)) != 0;
+	event_editor = E_COMP_EDITOR_EVENT (comp_editor);
+
+	gtk_widget_set_sensitive (event_editor->priv->all_day_check, !force_insensitive);
+
+	#define sensitize_part(x) G_STMT_START { \
+		widget = e_comp_editor_property_part_get_label_widget (x); \
+		if (widget) \
+			gtk_widget_set_sensitive (widget, !force_insensitive); \
+		\
+		widget = e_comp_editor_property_part_get_edit_widget (x); \
+		if (widget) \
+			gtk_widget_set_sensitive (widget, !force_insensitive); \
+	} G_STMT_END
+
+	sensitize_part (event_editor->priv->dtstart);
+	sensitize_part (event_editor->priv->dtend);
+	sensitize_part (event_editor->priv->timezone);
+
+	#undef sensitize_part
+
+	action = e_comp_editor_get_action (comp_editor, "all-day-event");
+	gtk_action_set_sensitive (action, !force_insensitive);
+
+	action = e_comp_editor_get_action (comp_editor, "classification-menu");
+	gtk_action_set_sensitive (action, !force_insensitive);
+
+	if (event_editor->priv->insensitive_info_alert)
+		e_alert_response (event_editor->priv->insensitive_info_alert, GTK_RESPONSE_OK);
+
+	if (force_insensitive || !is_organizer) {
+		ECalClient *client;
+		const gchar *message = NULL;
+
+		client = e_comp_editor_get_target_client (comp_editor);
+		if (!client)
+			message = _("Event cannot be edited, because the selected calendar could not be opened");
+		else if (e_client_is_readonly (E_CLIENT (client)))
+			message = _("Event cannot be edited, because the selected calendar is read only");
+		else if (!is_organizer)
+			message = _("Changes made to the event will not be sent to the attendees, because you are not the organizer");
+
+		if (message) {
+			EAlert *alert;
+
+			alert = e_comp_editor_add_information (comp_editor, message, NULL);
+
+			event_editor->priv->insensitive_info_alert = alert;
+
+			if (alert)
+				g_object_add_weak_pointer (G_OBJECT (alert), &event_editor->priv->insensitive_info_alert);
+
+			g_clear_object (&alert);
+		}
+	}
+}
+
+static ICalTimezone *
+ece_event_get_timezone_from_property (ECompEditor *comp_editor,
+				      ICalProperty *property)
+{
+	ECalClient *client;
+	ICalParameter *param;
+	ICalTimezone *zone = NULL;
+	const gchar *tzid;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR (comp_editor), NULL);
+
+	if (!property)
+		return NULL;
+
+	param = i_cal_property_get_first_parameter (property, I_CAL_TZID_PARAMETER);
+	if (!param)
+		return NULL;
+
+	tzid = i_cal_parameter_get_tzid (param);
+	if (!tzid || !*tzid) {
+		g_object_unref (param);
+		return NULL;
+	}
+
+	if (g_ascii_strcasecmp (tzid, "UTC") == 0) {
+		g_object_unref (param);
+		return i_cal_timezone_get_utc_timezone ();
+	}
+
+	client = e_comp_editor_get_source_client (comp_editor);
+	/* It should be already fetched for the UI, thus this should be non-blocking. */
+	if (client && e_cal_client_get_timezone_sync (client, tzid, &zone, NULL, NULL) && zone) {
+		g_object_unref (param);
+		return zone;
+	}
+
+	zone = i_cal_timezone_get_builtin_timezone_from_tzid (tzid);
+	if (!zone)
+		zone = i_cal_timezone_get_builtin_timezone (tzid);
+
+	g_object_unref (param);
+
+	return zone;
+}
+
+static void
+ece_event_update_timezone (ECompEditorEvent *event_editor,
+			   ICalTime **out_dtstart,
+			   ICalTime **out_dtend)
+{
+	ECompEditor *comp_editor;
+	ICalTime *dtstart = NULL, *dtend = NULL;
+	ICalComponent *component;
+	ICalProperty *prop;
+	ICalTimezone *zone = NULL;
+	gboolean has_property = FALSE, is_date_value = FALSE;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+
+	comp_editor = E_COMP_EDITOR (event_editor);
+
+	component = e_comp_editor_get_component (comp_editor);
+	if (!component) {
+		if (out_dtstart)
+			*out_dtstart = NULL;
+
+		if (out_dtend)
+			*out_dtend = NULL;
+
+		return;
+	}
+
+	if (e_cal_util_component_has_property (component, I_CAL_DTSTART_PROPERTY)) {
+		has_property = TRUE;
+
+		dtstart = i_cal_component_get_dtstart (component);
+		if (dtstart && i_cal_time_is_valid_time (dtstart)) {
+			if (i_cal_time_is_date (dtstart)) {
+				zone = NULL;
+				is_date_value = TRUE;
+			} else if (i_cal_time_is_utc (dtstart)) {
+				zone = i_cal_timezone_get_utc_timezone ();
+			} else {
+				prop = i_cal_component_get_first_property (component, I_CAL_DTSTART_PROPERTY);
+				zone = ece_event_get_timezone_from_property (comp_editor, prop);
+				g_clear_object (&prop);
+			}
+		}
+	}
+
+	if (e_cal_util_component_has_property (component, I_CAL_DTEND_PROPERTY)) {
+		has_property = TRUE;
+
+		dtend = i_cal_component_get_dtend (component);
+		if (!zone && i_cal_time_is_valid_time (dtend)) {
+			if (i_cal_time_is_date (dtend)) {
+				zone = NULL;
+				is_date_value = TRUE;
+			} else if (i_cal_time_is_utc (dtend)) {
+				zone = i_cal_timezone_get_utc_timezone ();
+			} else {
+				prop = i_cal_component_get_first_property (component, I_CAL_DTEND_PROPERTY);
+				zone = ece_event_get_timezone_from_property (comp_editor, prop);
+				g_clear_object (&prop);
+			}
+		}
+	}
+
+	if (!zone && e_cal_util_component_has_property (component, I_CAL_DUE_PROPERTY)) {
+		ICalTime *itt;
+
+		has_property = TRUE;
+
+		itt = i_cal_component_get_due (component);
+		if (itt && i_cal_time_is_valid_time (itt)) {
+			if (i_cal_time_is_date (itt)) {
+				zone = NULL;
+				is_date_value = TRUE;
+			} else if (i_cal_time_is_utc (itt)) {
+				zone = i_cal_timezone_get_utc_timezone ();
+			} else {
+				prop = i_cal_component_get_first_property (component, I_CAL_DUE_PROPERTY);
+				zone = ece_event_get_timezone_from_property (comp_editor, prop);
+				g_clear_object (&prop);
+			}
+		}
+
+		g_clear_object (&itt);
+	}
+
+	if (has_property) {
+		GtkWidget *edit_widget;
+		ICalTimezone *cfg_zone;
+
+		edit_widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->timezone);
+
+		if (!zone && is_date_value)
+			e_timezone_entry_set_timezone (E_TIMEZONE_ENTRY (edit_widget), calendar_config_get_icaltimezone ());
+		else
+			e_timezone_entry_set_timezone (E_TIMEZONE_ENTRY (edit_widget), zone);
+
+		cfg_zone = calendar_config_get_icaltimezone ();
+
+		if (zone && cfg_zone && zone != cfg_zone &&
+		    (g_strcmp0 (i_cal_timezone_get_location (zone), i_cal_timezone_get_location (cfg_zone)) != 0 ||
+		     g_strcmp0 (i_cal_timezone_get_tzid (zone), i_cal_timezone_get_tzid (cfg_zone)) != 0)) {
+			/* Show timezone part */
+			GtkAction *action;
+
+			action = e_comp_editor_get_action (comp_editor, "view-timezone");
+			gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (action), TRUE);
+		}
+	}
+
+	if (out_dtstart)
+		*out_dtstart = dtstart;
+	else
+		g_clear_object (&dtstart);
+
+	if (out_dtend)
+		*out_dtend = dtend;
+	else
+		g_clear_object (&dtend);
+}
+
+static void
+ece_event_fill_widgets (ECompEditor *comp_editor,
+			ICalComponent *component)
+{
+	ECompEditorEvent *event_editor;
+	ICalTime *dtstart, *dtend;
+	ICalProperty *prop;
+	gboolean all_day_event = FALSE;
+	GtkAction *action;
+	guint32 flags;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (comp_editor));
+	g_return_if_fail (component != NULL);
+
+	event_editor = E_COMP_EDITOR_EVENT (comp_editor);
+
+	flags = e_comp_editor_get_flags (comp_editor);
+	dtstart = NULL;
+	dtend = NULL;
+
+	/* Set timezone before the times, because they are converted into this timezone */
+	ece_event_update_timezone (event_editor, &dtstart, &dtend);
+
+	E_COMP_EDITOR_CLASS (e_comp_editor_event_parent_class)->fill_widgets (comp_editor, component);
+
+	if (dtstart && i_cal_time_is_valid_time (dtstart) && !i_cal_time_is_null_time (dtstart) &&
+	    (!dtend || !i_cal_time_is_valid_time (dtend) || i_cal_time_is_null_time (dtend))) {
+		g_clear_object (&dtend);
+		dtend = i_cal_time_clone (dtstart);
+		if (i_cal_time_is_date (dtstart))
+			i_cal_time_adjust (dtend, 1, 0, 0, 0);
+	}
+
+	if (dtend && i_cal_time_is_valid_time (dtend) && !i_cal_time_is_null_time (dtend)) {
+		if (i_cal_time_is_date (dtstart) && i_cal_time_is_date (dtend)) {
+			all_day_event = TRUE;
+			if (i_cal_time_compare_date_only (dtend, dtstart) > 0) {
+				i_cal_time_adjust (dtend, -1, 0, 0, 0);
+			}
+		}
+
+		e_comp_editor_property_part_datetime_set_value (
+			E_COMP_EDITOR_PROPERTY_PART_DATETIME (event_editor->priv->dtend), dtend);
+	}
+
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (event_editor->priv->all_day_check), all_day_event);
+
+	prop = i_cal_component_get_first_property (component, I_CAL_CLASS_PROPERTY);
+	if (prop && i_cal_property_get_class (prop) == I_CAL_CLASS_PRIVATE)
+		action = e_comp_editor_get_action (comp_editor, "classify-private");
+	else if (prop && i_cal_property_get_class (prop) == I_CAL_CLASS_CONFIDENTIAL)
+		action = e_comp_editor_get_action (comp_editor, "classify-confidential");
+	else if (!(flags & E_COMP_EDITOR_FLAG_IS_NEW))
+		action = e_comp_editor_get_action (comp_editor, "classify-public");
+	else {
+		GSettings *settings;
+
+		settings = e_util_ref_settings ("org.gnome.evolution.calendar");
+
+		if (g_settings_get_boolean (settings, "classify-private")) {
+			action = e_comp_editor_get_action (comp_editor, "classify-private");
+		} else {
+			action = e_comp_editor_get_action (comp_editor, "classify-public");
+		}
+
+		g_object_unref (settings);
+	}
+
+	gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (action), TRUE);
+
+	g_clear_object (&dtstart);
+	g_clear_object (&dtend);
+	g_clear_object (&prop);
+}
+
+static gboolean
+ece_event_client_needs_all_day_as_time (ECompEditor *comp_editor)
+{
+	ECalClient *client;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR (comp_editor), FALSE);
+
+	client = e_comp_editor_get_target_client (comp_editor);
+
+	return client && e_client_check_capability (E_CLIENT (client), E_CAL_STATIC_CAPABILITY_ALL_DAY_EVENT_AS_TIME);
+}
+
+static gboolean
+ece_event_fill_component (ECompEditor *comp_editor,
+			  ICalComponent *component)
+{
+	ECompEditorEvent *event_editor;
+	gboolean date_valid, time_valid;
+	ICalProperty *dtstart_prop, *dtend_prop;
+	ICalProperty *prop;
+	ICalProperty_Class class_value;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR (comp_editor), FALSE);
+	g_return_val_if_fail (I_CAL_IS_COMPONENT (component), FALSE);
+
+	if (!E_COMP_EDITOR_CLASS (e_comp_editor_event_parent_class)->fill_component (comp_editor, component))
+		return FALSE;
+
+	event_editor = E_COMP_EDITOR_EVENT (comp_editor);
+
+	if (!e_comp_editor_property_part_datetime_check_validity (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (event_editor->priv->dtstart), &date_valid, &time_valid)) {
+		const gchar *error_message = NULL;
+
+		if (!date_valid)
+			error_message = g_strdup (_("Start date is not a valid date"));
+		else if (!time_valid)
+			error_message = g_strdup (_("Start time is not a valid time"));
+
+		e_comp_editor_set_validation_error (comp_editor, event_editor->priv->page_general,
+			e_comp_editor_property_part_get_edit_widget (event_editor->priv->dtstart),
+			error_message ? error_message : _("Unknown error"));
+
+		return FALSE;
+	}
+
+	if (!e_comp_editor_property_part_datetime_check_validity (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (event_editor->priv->dtend), &date_valid, &time_valid)) {
+		const gchar *error_message = NULL;
+
+		if (!date_valid)
+			error_message = g_strdup (_("End date is not a valid date"));
+		else if (!time_valid)
+			error_message = g_strdup (_("End time is not a valid time"));
+
+		e_comp_editor_set_validation_error (comp_editor, event_editor->priv->page_general,
+			e_comp_editor_property_part_get_edit_widget (event_editor->priv->dtend),
+			error_message ? error_message : _("Unknown error"));
+
+		return FALSE;
+	}
+
+	dtstart_prop = i_cal_component_get_first_property (component, I_CAL_DTSTART_PROPERTY);
+	dtend_prop = i_cal_component_get_first_property (component, I_CAL_DTEND_PROPERTY);
+
+	if (dtstart_prop && dtend_prop) {
+		ICalTime *dtstart, *dtend;
+		gboolean set_dtstart = FALSE, set_dtend = FALSE;
+
+		dtstart = i_cal_property_get_dtstart (dtstart_prop);
+		dtend = i_cal_property_get_dtend (dtend_prop);
+
+		if (dtstart && i_cal_time_is_date (dtstart) &&
+		    dtend && i_cal_time_is_date (dtend)) {
+			/* Add 1 day to DTEND, as it is not inclusive. */
+			i_cal_time_adjust (dtend, 1, 0, 0, 0);
+			set_dtend = TRUE;
+
+			if (ece_event_client_needs_all_day_as_time (comp_editor)) {
+				ECompEditorEvent *event_editor = E_COMP_EDITOR_EVENT (comp_editor);
+				GtkWidget *timezone_entry;
+				ICalTimezone *zone;
+
+				timezone_entry = e_comp_editor_property_part_get_edit_widget (event_editor->priv->timezone);
+				zone = e_timezone_entry_get_timezone (E_TIMEZONE_ENTRY (timezone_entry));
+
+				cal_comp_util_ensure_allday_timezone (dtstart, zone);
+				cal_comp_util_ensure_allday_timezone (dtend, zone);
+
+				set_dtstart = TRUE;
+			}
+		}
+
+		if (set_dtstart) {
+			/* Remove the VALUE parameter, to correspond to the actual value being set */
+			i_cal_property_remove_parameter_by_kind (dtstart_prop, I_CAL_VALUE_PARAMETER);
+
+			i_cal_property_set_dtstart (dtstart_prop, dtstart);
+			cal_comp_util_update_tzid_parameter (dtstart_prop, dtstart);
+		}
+
+		if (set_dtend) {
+			/* Remove the VALUE parameter, to correspond to the actual value being set */
+			i_cal_property_remove_parameter_by_kind (dtend_prop, I_CAL_VALUE_PARAMETER);
+
+			i_cal_property_set_dtend (dtend_prop, dtend);
+			cal_comp_util_update_tzid_parameter (dtend_prop, dtend);
+		}
+
+		g_clear_object (&dtstart);
+		g_clear_object (&dtend);
+	}
+
+	g_clear_object (&dtstart_prop);
+	g_clear_object (&dtend_prop);
+
+	if (gtk_toggle_action_get_active (GTK_TOGGLE_ACTION (
+		e_comp_editor_get_action (comp_editor, "classify-private"))))
+		class_value = I_CAL_CLASS_PRIVATE;
+	else if (gtk_toggle_action_get_active (GTK_TOGGLE_ACTION (
+		e_comp_editor_get_action (comp_editor, "classify-confidential"))))
+		class_value = I_CAL_CLASS_CONFIDENTIAL;
+	else
+		class_value = I_CAL_CLASS_PUBLIC;
+
+	prop = i_cal_component_get_first_property (component, I_CAL_CLASS_PROPERTY);
+	if (prop) {
+		i_cal_property_set_class (prop, class_value);
+		g_object_unref (prop);
+	} else {
+		prop = i_cal_property_new_class (class_value);
+		i_cal_component_take_property (component, prop);
+	}
+
+	return TRUE;
+}
+
+static void
+ece_event_notify_source_client_cb (GObject *object,
+				   GParamSpec *param,
+				   gpointer user_data)
+{
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (object));
+
+	ece_event_update_timezone (E_COMP_EDITOR_EVENT (object), NULL, NULL);
+}
+
+static void
+ece_event_notify_target_client_cb (GObject *object,
+				   GParamSpec *param,
+				   gpointer user_data)
+{
+	ECompEditorEvent *event_editor;
+	GtkAction *action;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (object));
+
+	event_editor = E_COMP_EDITOR_EVENT (object);
+	action = e_comp_editor_get_action (E_COMP_EDITOR (event_editor), "view-timezone");
+
+	/* These influence whether the timezone part is visible and they
+	   depend on the target's client ece_event_client_needs_all_day_as_time() */
+	g_object_notify (G_OBJECT (action), "active");
+	g_object_notify (G_OBJECT (event_editor->priv->all_day_check), "active");
+}
+
+static gboolean
+transform_action_to_timezone_visible_cb (GBinding *binding,
+					 const GValue *from_value,
+					 GValue *to_value,
+					 gpointer user_data)
+{
+	ECompEditorEvent *event_editor = user_data;
+	GtkToggleButton *all_day_check = GTK_TOGGLE_BUTTON (event_editor->priv->all_day_check);
+
+	g_value_set_boolean (to_value,
+		g_value_get_boolean (from_value) &&
+		(!gtk_toggle_button_get_active (all_day_check) || ece_event_client_needs_all_day_as_time (E_COMP_EDITOR (event_editor))));
+
+	return TRUE;
+}
+
+static gboolean
+transform_toggle_to_timezone_visible_cb (GBinding *binding,
+					 const GValue *from_value,
+					 GValue *to_value,
+					 gpointer user_data)
+{
+	ECompEditor *comp_editor = user_data;
+	GtkToggleAction *action = GTK_TOGGLE_ACTION (e_comp_editor_get_action (comp_editor, "view-timezone"));
+
+	g_value_set_boolean (to_value,
+		gtk_toggle_action_get_active (action) &&
+		(!g_value_get_boolean (from_value) || ece_event_client_needs_all_day_as_time (comp_editor)));
+
+	return TRUE;
+}
+
+static gboolean
+transform_all_day_check_to_action_sensitive_cb (GBinding *binding,
+						const GValue *from_value,
+						GValue *to_value,
+						gpointer user_data)
+{
+	ECompEditor *comp_editor = user_data;
+
+	g_value_set_boolean (to_value,
+		!g_value_get_boolean (from_value) ||
+		ece_event_client_needs_all_day_as_time (comp_editor));
+
+	return TRUE;
+}
+
+static void
+ece_event_setup_ui (ECompEditorEvent *event_editor)
+{
+	const gchar *ui =
+		"<ui>"
+		"  <menubar action='main-menu'>"
+		"    <menu action='view-menu'>"
+		"      <placeholder name='parts'>"
+		"        <menuitem action='view-timezone'/>"
+		"        <menuitem action='view-categories'/>"
+		"      </placeholder>"
+		"    </menu>"
+		"    <menu action='options-menu'>"
+		"      <placeholder name='toggles'>"
+		"        <menuitem action='all-day-event'/>"
+		"        <menuitem action='show-time-busy'/>"
+		"        <menu action='classification-menu'>"
+		"          <menuitem action='classify-public'/>"
+		"          <menuitem action='classify-private'/>"
+		"          <menuitem action='classify-confidential'/>"
+		"        </menu>"
+		"      </placeholder>"
+		"    </menu>"
+		"  </menubar>"
+		"  <toolbar name='main-toolbar'>"
+		"    <placeholder name='content'>\n"
+		"      <toolitem action='all-day-event'/>\n"
+		"      <toolitem action='show-time-busy'/>\n"
+		"    </placeholder>"
+		"  </toolbar>"
+		"</ui>";
+
+	const GtkToggleActionEntry view_actions[] = {
+		{ "view-categories",
+		  NULL,
+		  N_("_Categories"),
+		  NULL,
+		  N_("Toggles whether to display categories"),
+		  NULL,
+		  FALSE },
+
+		{ "view-timezone",
+		  "stock_timezone",
+		  N_("Time _Zone"),
+		  NULL,
+		  N_("Toggles whether the time zone is displayed"),
+		  NULL,
+		  FALSE },
+
+		{ "all-day-event",
+		  "stock_new-24h-appointment",
+		  N_("All _Day Event"),
+		  "<Control>Y",
+		  N_("Toggles whether to have All Day Event"),
+		  NULL,
+		  FALSE },
+
+		{ "show-time-busy",
+		  "dialog-error",
+		  N_("Show Time as _Busy"),
+		  NULL,
+		  N_("Toggles whether to show time as busy"),
+		  NULL,
+		  FALSE }
+	};
+
+	const GtkRadioActionEntry classification_radio_entries[] = {
+
+		{ "classify-public",
+		  NULL,
+		  N_("Pu_blic"),
+		  NULL,
+		  N_("Classify as public"),
+		  I_CAL_CLASS_PUBLIC },
+
+		{ "classify-private",
+		  NULL,
+		  N_("_Private"),
+		  NULL,
+		  N_("Classify as private"),
+		  I_CAL_CLASS_PRIVATE },
+
+		{ "classify-confidential",
+		  NULL,
+		  N_("_Confidential"),
+		  NULL,
+		  N_("Classify as confidential"),
+		  I_CAL_CLASS_CONFIDENTIAL }
+	};
+
+	ECompEditor *comp_editor;
+	GSettings *settings;
+	GtkUIManager *ui_manager;
+	GtkAction *action;
+	GtkActionGroup *action_group;
+	GtkWidget *widget;
+	GError *error = NULL;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_EVENT (event_editor));
+
+	comp_editor = E_COMP_EDITOR (event_editor);
+	settings = e_comp_editor_get_settings (comp_editor);
+	ui_manager = e_comp_editor_get_ui_manager (comp_editor);
+	action_group = e_comp_editor_get_action_group (comp_editor, "individual");
+
+	gtk_action_group_add_toggle_actions (action_group,
+		view_actions, G_N_ELEMENTS (view_actions), event_editor);
+
+	gtk_action_group_add_radio_actions (
+		action_group, classification_radio_entries,
+		G_N_ELEMENTS (classification_radio_entries),
+		I_CAL_CLASS_PUBLIC,
+		G_CALLBACK (ece_event_action_classification_cb), event_editor);
+
+	gtk_ui_manager_add_ui_from_string (ui_manager, ui, -1, &error);
+
+	e_plugin_ui_register_manager (ui_manager, "org.gnome.evolution.event-editor", event_editor);
+	e_plugin_ui_enable_manager (ui_manager, "org.gnome.evolution.event-editor");
+
+	if (error) {
+		g_critical ("%s: %s", G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+
+	action = e_comp_editor_get_action (comp_editor, "view-categories");
+	e_binding_bind_property (
+		event_editor->priv->categories, "visible",
+		action, "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	g_settings_bind (
+		settings, "editor-show-categories",
+		action, "active",
+		G_SETTINGS_BIND_DEFAULT);
+
+	action = e_comp_editor_get_action (comp_editor, "view-timezone");
+	e_binding_bind_property_full (
+		action, "active",
+		event_editor->priv->timezone, "visible",
+		G_BINDING_DEFAULT,
+		transform_action_to_timezone_visible_cb,
+		NULL, /* not used */
+		event_editor, NULL);
+	e_binding_bind_property_full (
+		event_editor->priv->all_day_check, "active",
+		event_editor->priv->timezone, "visible",
+		G_BINDING_DEFAULT,
+		transform_toggle_to_timezone_visible_cb,
+		NULL, /* not used */
+		event_editor, NULL);
+	e_binding_bind_property_full (
+		event_editor->priv->all_day_check, "active",
+		action, "sensitive",
+		G_BINDING_SYNC_CREATE,
+		transform_all_day_check_to_action_sensitive_cb,
+		NULL, /* not used */
+		event_editor, NULL);
+	g_settings_bind (
+		settings, "editor-show-timezone",
+		action, "active",
+		G_SETTINGS_BIND_DEFAULT);
+
+	action = e_comp_editor_get_action (comp_editor, "all-day-event");
+	e_binding_bind_property (
+		event_editor->priv->all_day_check, "active",
+		action, "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+
+	widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->transparency);
+	action = e_comp_editor_get_action (comp_editor, "show-time-busy");
+	e_binding_bind_property (
+		widget, "active",
+		action, "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+}
+
+static void
+e_comp_editor_event_constructed (GObject *object)
+{
+	ECompEditor *comp_editor;
+	ECompEditorEvent *event_editor;
+	ECompEditorPage *page;
+	ECompEditorPropertyPart *part;
+	ECompEditorPropertyPart *summary;
+	EFocusTracker *focus_tracker;
+	GtkWidget *widget;
+
+	G_OBJECT_CLASS (e_comp_editor_event_parent_class)->constructed (object);
+
+	event_editor = E_COMP_EDITOR_EVENT (object);
+	comp_editor = E_COMP_EDITOR (event_editor);
+	focus_tracker = e_comp_editor_get_focus_tracker (comp_editor);
+
+	page = e_comp_editor_page_general_new (comp_editor,
+		_("_Calendar:"), E_SOURCE_EXTENSION_CALENDAR,
+		NULL, FALSE, 2);
+	event_editor->priv->page_general = page;
+
+	part = e_comp_editor_property_part_summary_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 2, 3, 1);
+	summary = part;
+
+	part = e_comp_editor_property_part_location_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 3, 3, 1);
+
+	part = e_comp_editor_property_part_dtstart_new (C_("ECompEditor", "_Start time:"), FALSE, FALSE);
+	e_comp_editor_page_add_property_part (page, part, 0, 4, 2, 1);
+	e_comp_editor_property_part_set_sensitize_handled (part, TRUE);
+	event_editor->priv->dtstart = part;
+
+	part = e_comp_editor_property_part_dtend_new (C_("ECompEditor", "_End time:"), FALSE, FALSE);
+	e_comp_editor_page_add_property_part (page, part, 0, 5, 2, 1);
+	e_comp_editor_property_part_set_sensitize_handled (part, TRUE);
+	event_editor->priv->dtend = part;
+
+	part = e_comp_editor_property_part_timezone_new ();
+	e_comp_editor_page_add_property_part (page, part, 0, 6, 3, 1);
+	e_comp_editor_property_part_set_sensitize_handled (part, TRUE);
+	event_editor->priv->timezone = part;
+
+	widget = gtk_check_button_new_with_mnemonic (C_("ECompEditor", "All da_y event"));
+	g_object_set (G_OBJECT (widget),
+		"hexpand", TRUE,
+		"halign", GTK_ALIGN_FILL,
+		"vexpand", FALSE,
+		"valign", GTK_ALIGN_START,
+		NULL);
+	gtk_grid_attach (GTK_GRID (page), widget, 2, 4, 1, 1);
+	gtk_widget_show (widget);
+	event_editor->priv->all_day_check = widget;
+
+	part = e_comp_editor_property_part_transparency_new ();
+	e_comp_editor_page_add_property_part (page, part, 2, 5, 1, 1);
+	event_editor->priv->transparency = part;
+
+	widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->transparency);
+	/* Transparency checkbox is not shown in the page, even it's packed there */
+	gtk_widget_hide (widget);
+
+	part = e_comp_editor_property_part_status_new (I_CAL_VEVENT_COMPONENT);
+	e_comp_editor_page_add_property_part (page, part, 0, 7, 3, 1);
+
+	widget = e_comp_editor_property_part_get_edit_widget (part);
+	gtk_widget_set_halign (widget, GTK_ALIGN_START);
+	gtk_widget_set_hexpand (widget, FALSE);
+
+	part = e_comp_editor_property_part_url_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 8, 3, 1);
+
+	part = e_comp_editor_property_part_categories_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 9, 3, 1);
+	event_editor->priv->categories = part;
+
+	part = e_comp_editor_property_part_description_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 10, 3, 1);
+	event_editor->priv->description = part;
+
+	widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->timezone);
+	e_comp_editor_property_part_datetime_attach_timezone_entry (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (event_editor->priv->dtstart),
+		E_TIMEZONE_ENTRY (widget));
+	g_signal_connect_swapped (event_editor->priv->dtstart, "lookup-timezone",
+		G_CALLBACK (e_comp_editor_lookup_timezone), event_editor);
+	e_comp_editor_property_part_datetime_attach_timezone_entry (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (event_editor->priv->dtend),
+		E_TIMEZONE_ENTRY (widget));
+	g_signal_connect_swapped (event_editor->priv->dtend, "lookup-timezone",
+		G_CALLBACK (e_comp_editor_lookup_timezone), event_editor);
+
+	e_comp_editor_set_time_parts (comp_editor, event_editor->priv->dtstart, event_editor->priv->dtend);
+
+	widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->dtstart);
+	e_binding_bind_property (
+		event_editor->priv->all_day_check, "active",
+		widget, "show-time",
+		G_BINDING_INVERT_BOOLEAN | G_BINDING_BIDIRECTIONAL);
+	g_signal_connect (widget, "changed", G_CALLBACK (ece_event_dtstart_changed_cb), event_editor);
+
+	widget = e_comp_editor_property_part_get_edit_widget (event_editor->priv->dtend);
+	e_binding_bind_property (
+		event_editor->priv->all_day_check, "active",
+		widget, "show-time",
+		G_BINDING_INVERT_BOOLEAN | G_BINDING_BIDIRECTIONAL);
+	g_signal_connect (widget, "changed", G_CALLBACK (ece_event_dtend_changed_cb), event_editor);
+
+	e_signal_connect_notify_swapped (event_editor->priv->all_day_check, "notify::active",
+		G_CALLBACK (ece_event_all_day_toggled_cb), event_editor);
+
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "General"), page);
+
+	page = e_comp_editor_page_reminders_new (comp_editor);
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Reminders"), page);
+
+	page = e_comp_editor_page_recurrence_new (comp_editor);
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Recurrence"), page);
+
+	page = e_comp_editor_page_attachments_new (comp_editor);
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Attachments"), page);
+
+	page = e_comp_editor_page_schedule_new (comp_editor,
+		e_comp_editor_page_general_get_meeting_store (
+		E_COMP_EDITOR_PAGE_GENERAL (event_editor->priv->page_general)));
+	e_binding_bind_property (
+		event_editor->priv->page_general, "show-attendees",
+		page, "visible",
+		G_BINDING_SYNC_CREATE);
+
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Schedule"), page);
+
+	ece_event_setup_ui (event_editor);
+
+	widget = e_comp_editor_property_part_get_edit_widget (summary);
+	e_binding_bind_property (widget, "text", comp_editor, "title-suffix", 0);
+	/* Do this as the last thing, because some widgets can call the function as well */
+	gtk_widget_grab_focus (widget);
+
+	g_signal_connect (comp_editor, "notify::source-client",
+		G_CALLBACK (ece_event_notify_source_client_cb), NULL);
+
+	g_signal_connect (comp_editor, "notify::target-client",
+		G_CALLBACK (ece_event_notify_target_client_cb), NULL);
+}
+
+static void
+e_comp_editor_event_init (ECompEditorEvent *event_editor)
+{
+	event_editor->priv = G_TYPE_INSTANCE_GET_PRIVATE (event_editor, E_TYPE_COMP_EDITOR_EVENT, ECompEditorEventPrivate);
+}
+
+static void
+e_comp_editor_event_class_init (ECompEditorEventClass *klass)
+{
+	GObjectClass *object_class;
+	ECompEditorClass *comp_editor_class;
+
+	g_type_class_add_private (klass, sizeof (ECompEditorEventPrivate));
+
+	object_class = G_OBJECT_CLASS (klass);
+	object_class->constructed = e_comp_editor_event_constructed;
+
+	comp_editor_class = E_COMP_EDITOR_CLASS (klass);
+	comp_editor_class->help_section = "calendar-usage-add-appointment";
+	comp_editor_class->title_format_with_attendees = _("Meeting — %s");
+	comp_editor_class->title_format_without_attendees = _("Appointment — %s");
+	comp_editor_class->icon_name = "appointment-new";
+	comp_editor_class->sensitize_widgets = ece_event_sensitize_widgets;
+	comp_editor_class->fill_widgets = ece_event_fill_widgets;
+	comp_editor_class->fill_component = ece_event_fill_component;
+}
diff -urN a/src/calendar/gui/e-comp-editor-page-attachments.c b/src/calendar/gui/e-comp-editor-page-attachments.c
--- a/src/calendar/gui/e-comp-editor-page-attachments.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor-page-attachments.c	2022-01-08 18:47:17.604879289 -0800
@@ -621,7 +621,7 @@
 		{ "attachments-attach",
 		  "mail-attachment",
 		  N_("_Attachment…"),
-		  "<Control>m",
+		  "<Super>m",
 		  N_("Attach a file"),
 		  G_CALLBACK (ecep_attachments_action_attach_cb) }
 	};
diff -urN a/src/calendar/gui/e-comp-editor-page-attachments.c.orig b/src/calendar/gui/e-comp-editor-page-attachments.c.orig
--- a/src/calendar/gui/e-comp-editor-page-attachments.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor-page-attachments.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,975 @@
+/*
+ * Copyright (C) 2015 Red Hat, Inc. (www.redhat.com)
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "evolution-config.h"
+
+#include <glib.h>
+#include <glib/gstdio.h>
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include <e-util/e-util.h>
+
+#include "comp-util.h"
+
+#include "e-comp-editor-page-attachments.h"
+
+#define NUM_VIEWS 2
+
+struct _ECompEditorPageAttachmentsPrivate {
+	GtkTreeModel *store;
+	GtkWidget *notebook;
+	GtkWidget *combo_box;
+	GtkWidget *controls_container;
+	GtkWidget *icon_view;
+	GtkWidget *tree_view;
+	GtkWidget *status_icon;
+	GtkWidget *status_label;
+
+	gulong store_row_inserted_handler_id;
+	gulong store_row_deleted_handler_id;
+
+	gint active_view;
+	GSList *temporary_files;
+};
+
+enum {
+	PROP_0,
+	PROP_ACTIVE_VIEW
+};
+
+G_DEFINE_TYPE (ECompEditorPageAttachments, e_comp_editor_page_attachments, E_TYPE_COMP_EDITOR_PAGE)
+
+static void
+ecep_attachments_action_attach_cb (GtkAction *action,
+				   ECompEditorPageAttachments *page_attachments)
+{
+	ECompEditor *comp_editor;
+	EAttachmentStore *store;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page_attachments));
+
+	comp_editor = e_comp_editor_page_ref_editor (E_COMP_EDITOR_PAGE (page_attachments));
+	store = E_ATTACHMENT_STORE (page_attachments->priv->store);
+
+	e_attachment_store_run_load_dialog (store, GTK_WINDOW (comp_editor));
+
+	g_clear_object (&comp_editor);
+}
+
+static void
+ecep_attachments_select_page_cb (GtkAction *action,
+				 ECompEditorPage *page)
+{
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page));
+
+	e_comp_editor_page_select (page);
+}
+
+static void
+temporary_file_free (gpointer ptr)
+{
+	gchar *temporary_file = ptr;
+
+	if (temporary_file) {
+		gchar *sep;
+
+		g_unlink (temporary_file);
+
+		sep = strrchr (temporary_file, G_DIR_SEPARATOR);
+		if (sep) {
+			*sep = '\0';
+			g_rmdir (temporary_file);
+		}
+
+		g_free (temporary_file);
+	}
+}
+
+static void
+ecep_attachments_update_status (ECompEditorPageAttachments *page_attachments)
+{
+	EAttachmentStore *store;
+	GtkLabel *label;
+	guint num_attachments;
+	guint64 total_size;
+	gchar *display_size;
+	gchar *markup;
+
+	store = E_ATTACHMENT_STORE (page_attachments->priv->store);
+	label = GTK_LABEL (page_attachments->priv->status_label);
+
+	num_attachments = e_attachment_store_get_num_attachments (store);
+	total_size = e_attachment_store_get_total_size (store);
+	display_size = g_format_size (total_size);
+
+	if (total_size > 0)
+		markup = g_strdup_printf (
+			"<b>%d</b> %s (%s)", num_attachments, g_dngettext (GETTEXT_PACKAGE,
+			"Attachment", "Attachments", num_attachments),
+			display_size);
+	else
+		markup = g_strdup_printf (
+			"<b>%d</b> %s", num_attachments, g_dngettext (GETTEXT_PACKAGE,
+			"Attachment", "Attachments", num_attachments));
+	gtk_label_set_markup (label, markup);
+	g_free (markup);
+
+	g_free (display_size);
+}
+
+static void
+ecep_attachments_attachment_loaded_cb (EAttachment *attachment,
+				       GAsyncResult *result,
+				       ECompEditorPageAttachments *page_attachments)
+{
+	GFileInfo *file_info;
+	const gchar *display_name;
+	GError *error = NULL;
+
+	/* Prior to 2.27.2, attachment files were named:
+	 *
+	 *     <component-uid> '-' <actual-filename>
+	 *     -------------------------------------
+	 *              (one long filename)
+	 *
+	 * Here we fix the display name if this form is detected so we
+	 * don't show the component UID in the user interface.  If the
+	 * user saves changes in the editor, the attachment will be
+	 * written to disk as:
+	 *
+	 *     <component-uid> / <actual-filename>
+	 *     ---------------   -----------------
+	 *       (directory)      (original name)
+	 *
+	 * So this is a lazy migration from the old form to the new.
+	 */
+
+	file_info = e_attachment_ref_file_info (attachment);
+	if (file_info) {
+		const gchar *uid;
+		const gchar *prefer_filename;
+
+		display_name = g_file_info_get_display_name (file_info);
+		uid = g_object_get_data (G_OBJECT (attachment), "uid");
+		prefer_filename = g_object_get_data (G_OBJECT (attachment), "prefer-filename");
+
+		if (prefer_filename && *prefer_filename) {
+			g_file_info_set_display_name (file_info, prefer_filename);
+			g_object_notify (G_OBJECT (attachment), "file-info");
+		} else if (g_str_has_prefix (display_name, uid)) {
+			gchar *new_name;
+
+			new_name = g_strdup (display_name + strlen (uid) + 1);
+			g_file_info_set_display_name (file_info, new_name);
+			g_object_notify (G_OBJECT (attachment), "file-info");
+			g_free (new_name);
+		}
+	}
+
+	if (!e_attachment_load_finish (attachment, result, &error)) {
+		g_signal_emit_by_name (attachment, "load-failed", NULL);
+
+		/* Ignore cancellations. */
+		if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+			ECompEditor *comp_editor;
+			EAlert *alert;
+			gchar *primary_text;
+
+			comp_editor = e_comp_editor_page_ref_editor (E_COMP_EDITOR_PAGE (page_attachments));
+
+			if (file_info)
+				display_name = g_file_info_get_display_name (file_info);
+			else
+				display_name = NULL;
+
+			if (display_name != NULL)
+				primary_text = g_strdup_printf (_("Could not load “%s”"), display_name);
+			else
+				primary_text = g_strdup (_("Could not load the attachment"));
+
+			alert = e_comp_editor_add_error (comp_editor, primary_text,
+				error ? error->message : _("Unknown error"));
+
+			g_clear_object (&comp_editor);
+			g_clear_object (&alert);
+			g_free (primary_text);
+		}
+	}
+
+	g_clear_object (&file_info);
+	g_clear_error (&error);
+}
+
+static void
+ecep_attachments_sensitize_widgets (ECompEditorPage *page,
+				    gboolean force_insensitive)
+{
+	ECompEditor *comp_editor;
+	GtkAction *action;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page));
+
+	E_COMP_EDITOR_PAGE_CLASS (e_comp_editor_page_attachments_parent_class)->sensitize_widgets (page, force_insensitive);
+
+	comp_editor = e_comp_editor_page_ref_editor (page);
+
+	action = e_comp_editor_get_action (comp_editor, "attachments-attach");
+	gtk_action_set_sensitive (action, !force_insensitive);
+
+	g_clear_object (&comp_editor);
+}
+
+static void
+ecep_attachments_fill_widgets (ECompEditorPage *page,
+			       ICalComponent *component)
+{
+	ECompEditorPageAttachments *page_attachments;
+	EAttachmentStore *store;
+	ICalProperty *prop;
+	const gchar *uid;
+	gint index;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page));
+	g_return_if_fail (I_CAL_IS_COMPONENT (component));
+
+	E_COMP_EDITOR_PAGE_CLASS (e_comp_editor_page_attachments_parent_class)->fill_widgets (page, component);
+
+	page_attachments = E_COMP_EDITOR_PAGE_ATTACHMENTS (page);
+	store = E_ATTACHMENT_STORE (page_attachments->priv->store);
+
+	uid = i_cal_component_get_uid (component);
+
+	g_slist_free_full (page_attachments->priv->temporary_files, temporary_file_free);
+	page_attachments->priv->temporary_files = NULL;
+
+	e_attachment_store_remove_all (store);
+
+	for (prop = i_cal_component_get_first_property (component, I_CAL_ATTACH_PROPERTY), index = 0;
+	     prop;
+	     g_object_unref (prop), prop = i_cal_component_get_next_property (component, I_CAL_ATTACH_PROPERTY), index++) {
+		ICalParameter *param;
+		ICalAttach *attach;
+		gchar *uri = NULL, *filename = NULL;
+
+		attach = i_cal_property_get_attach (prop);
+		if (!attach)
+			continue;
+
+		param = i_cal_property_get_first_parameter (prop, I_CAL_FILENAME_PARAMETER);
+		if (param) {
+			filename = g_strdup (i_cal_parameter_get_filename (param));
+			if (!filename || !*filename) {
+				g_free (filename);
+				filename = NULL;
+			}
+
+			g_clear_object (&param);
+		}
+
+		if (i_cal_attach_get_is_url (attach)) {
+			const gchar *data;
+
+			data = i_cal_attach_get_url (attach);
+			uri = i_cal_value_decode_ical_string (data);
+		} else {
+			gchar *temporary_filename = NULL;
+			ICalParameter *encoding_par = i_cal_property_get_first_parameter (prop, I_CAL_ENCODING_PARAMETER);
+			if (encoding_par) {
+				gchar *str_value = i_cal_property_get_value_as_string (prop);
+
+				if (str_value) {
+					ICalParameterEncoding encoding = i_cal_parameter_get_encoding (encoding_par);
+					guint8 *data = NULL;
+					gsize data_len = 0;
+
+					switch (encoding) {
+					case I_CAL_ENCODING_8BIT:
+						data = (guint8 *) str_value;
+						data_len = strlen (str_value);
+						str_value = NULL;
+						break;
+					case I_CAL_ENCODING_BASE64:
+						data = g_base64_decode (str_value, &data_len);
+						break;
+					default:
+						break;
+					}
+
+					if (data) {
+						gchar *dir, *id_str;
+						gchar *rid;
+
+						rid = e_cal_util_component_get_recurid_as_string (component);
+						if (rid && !*rid) {
+							g_free (rid);
+							rid = NULL;
+						}
+
+						id_str = g_strconcat (uid, rid ? "-" : NULL, rid, NULL);
+
+						dir = g_build_filename (e_get_user_cache_dir (), "tmp", "calendar", id_str, NULL);
+
+						g_free (rid);
+						g_free (id_str);
+
+						if (g_mkdir_with_parents (dir, 0700) >= 0) {
+							for (param = i_cal_property_get_first_parameter (prop, I_CAL_X_PARAMETER);
+							     param && !filename;
+							     g_object_unref (param), param = i_cal_property_get_next_parameter (prop, I_CAL_X_PARAMETER)) {
+								if (e_util_strstrcase (i_cal_parameter_get_xname (param), "NAME") &&
+								    i_cal_parameter_get_xvalue (param) &&
+								    *i_cal_parameter_get_xvalue (param)) {
+									filename = g_strdup (i_cal_parameter_get_xvalue (param));
+									if (!filename || !*filename) {
+										g_free (filename);
+										filename = NULL;
+									}
+								}
+							}
+
+							g_clear_object (&param);
+
+							if (!filename)
+								filename = g_strdup_printf ("%d.dat", index);
+
+							temporary_filename = g_build_filename (dir, filename, NULL);
+							if (!g_file_set_contents (temporary_filename, (const gchar *) data, data_len, NULL)) {
+								g_free (temporary_filename);
+								temporary_filename = NULL;
+							}
+						}
+
+						g_free (dir);
+					}
+
+					g_free (str_value);
+					g_free (data);
+				}
+
+				g_object_unref (encoding_par);
+			}
+
+			if (temporary_filename) {
+				uri = g_filename_to_uri (temporary_filename, NULL, NULL);
+				page_attachments->priv->temporary_files = g_slist_prepend (page_attachments->priv->temporary_files, temporary_filename);
+			}
+		}
+
+		if (uri) {
+			EAttachment *attachment;
+
+			attachment = e_attachment_new_for_uri (uri);
+			e_attachment_store_add_attachment (store, attachment);
+			g_object_set_data_full (G_OBJECT (attachment), "uid", g_strdup (uid), g_free);
+			if (filename)
+				g_object_set_data_full (G_OBJECT (attachment), "prefer-filename", g_strdup (filename), g_free);
+			e_attachment_load_async (
+				attachment, (GAsyncReadyCallback)
+				ecep_attachments_attachment_loaded_cb, page_attachments);
+			g_object_unref (attachment);
+		}
+
+		g_object_unref (attach);
+		g_free (filename);
+		g_free (uri);
+	}
+}
+
+static gboolean
+ecep_attachments_fill_component (ECompEditorPage *page,
+				 ICalComponent *component)
+{
+	ECompEditorPageAttachments *page_attachments;
+	ECompEditor *comp_editor;
+	GList *attachments, *link;
+	ICalProperty *prop;
+	gboolean success = TRUE;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page), FALSE);
+	g_return_val_if_fail (I_CAL_IS_COMPONENT (component), FALSE);
+
+	comp_editor = e_comp_editor_page_ref_editor (page);
+	page_attachments = E_COMP_EDITOR_PAGE_ATTACHMENTS (page);
+
+	if (e_attachment_store_get_num_loading (E_ATTACHMENT_STORE (page_attachments->priv->store)) > 0) {
+		e_comp_editor_set_validation_error (comp_editor, page, NULL,
+			_("Some attachments are still being downloaded. Please wait until the download is finished."));
+		g_clear_object (&comp_editor);
+		return FALSE;
+	}
+
+	e_cal_util_component_remove_property_by_kind (component, I_CAL_ATTACH_PROPERTY, TRUE);
+
+	attachments = e_attachment_store_get_attachments (E_ATTACHMENT_STORE (page_attachments->priv->store));
+	for (link = attachments; link; link = g_list_next (link)) {
+		EAttachment *attachment = link->data;
+		ICalAttach *attach;
+		gchar *buf, *uri, *description;
+		GFile *file;
+		GFileInfo *file_info;
+
+		if (!attachment)
+			continue;
+
+		description = e_attachment_dup_description (attachment);
+
+		file = e_attachment_ref_file (attachment);
+		if (!file) {
+			gchar *error_message;
+
+			success = FALSE;
+
+			error_message = g_strdup_printf (
+				_("Attachment “%s” cannot be found, remove it from the list, please"),
+				description);
+
+			e_comp_editor_set_validation_error (comp_editor, page, NULL, error_message);
+
+			g_free (description);
+			g_free (error_message);
+			break;
+		}
+
+		uri = g_file_get_uri (file);
+		if (!uri) {
+			gchar *error_message;
+
+			success = FALSE;
+
+			error_message = g_strdup_printf (
+				_("Attachment “%s” doesn’t have valid URI, remove it from the list, please"),
+				description);
+
+			e_comp_editor_set_validation_error (comp_editor, page, NULL, error_message);
+
+			g_free (description);
+			g_free (error_message);
+			g_object_unref (file);
+			break;
+		}
+
+		g_object_unref (file);
+		g_free (description);
+
+		buf = i_cal_value_encode_ical_string (uri);
+		attach = i_cal_attach_new_from_url (buf);
+		prop = i_cal_property_new_attach (attach);
+
+		file_info = e_attachment_ref_file_info (attachment);
+		if (file_info) {
+			const gchar *display_name = g_file_info_get_display_name (file_info);
+
+			if (display_name && *display_name) {
+				ICalParameter *param;
+
+				param = i_cal_parameter_new_filename (display_name);
+				i_cal_property_take_parameter (prop, param);
+			}
+
+			g_object_unref (file_info);
+		}
+
+		i_cal_component_take_property (component, prop);
+
+		g_object_unref (attach);
+		g_free (buf);
+		g_free (uri);
+	}
+
+	g_list_free_full (attachments, g_object_unref);
+	g_clear_object (&comp_editor);
+
+	return success && E_COMP_EDITOR_PAGE_CLASS (e_comp_editor_page_attachments_parent_class)->fill_component (page, component);
+}
+
+static gboolean
+ecep_attachments_drag_motion (GtkWidget *widget,
+			      GdkDragContext *context,
+			      gint x,
+			      gint y,
+			      guint time)
+{
+	ECompEditorPageAttachments *page_attachments;
+	EAttachmentView *attachment_view;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (widget), FALSE);
+
+	page_attachments = E_COMP_EDITOR_PAGE_ATTACHMENTS (widget);
+	attachment_view = E_ATTACHMENT_VIEW (page_attachments->priv->icon_view);
+
+	return e_attachment_view_drag_motion (attachment_view, context, x, y, time);
+}
+
+static void
+ecep_attachments_drag_data_received (GtkWidget *widget,
+				     GdkDragContext *context,
+				     gint x,
+				     gint y,
+				     GtkSelectionData *selection,
+				     guint info,
+				     guint time)
+{
+	ECompEditorPageAttachments *page_attachments;
+	EAttachmentView *attachment_view;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (widget));
+
+	page_attachments = E_COMP_EDITOR_PAGE_ATTACHMENTS (widget);
+	attachment_view = E_ATTACHMENT_VIEW (page_attachments->priv->icon_view);
+
+	/* Forward the data to the attachment view.  Note that calling
+	 * e_attachment_view_drag_data_received() will not work because
+	 * that function only handles the case where all the other drag
+	 * handlers have failed. */
+
+	/* XXX Dirty hack for forwarding drop events. */
+	g_signal_emit_by_name (
+		attachment_view, "drag-data-received",
+		context, x, y, selection, info, time);
+}
+
+static void
+ecep_attachments_set_property (GObject *object,
+			       guint property_id,
+			       const GValue *value,
+			       GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_ACTIVE_VIEW:
+			e_comp_editor_page_attachments_set_active_view (
+				E_COMP_EDITOR_PAGE_ATTACHMENTS (object),
+				g_value_get_int (value));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+ecep_attachments_get_property (GObject *object,
+                               guint property_id,
+                               GValue *value,
+                               GParamSpec *pspec)
+{
+	switch (property_id) {
+		case PROP_ACTIVE_VIEW:
+			g_value_set_int (
+				value,
+				e_comp_editor_page_attachments_get_active_view (
+				E_COMP_EDITOR_PAGE_ATTACHMENTS (object)));
+			return;
+	}
+
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+}
+
+static void
+ecep_attachments_dispose (GObject *object)
+{
+	ECompEditorPageAttachments *page_attachments;
+
+	page_attachments = E_COMP_EDITOR_PAGE_ATTACHMENTS (object);
+
+	if (page_attachments->priv->store) {
+		gpointer store = page_attachments->priv->store;
+
+		e_signal_disconnect_notify_handler (store, &page_attachments->priv->store_row_inserted_handler_id);
+		e_signal_disconnect_notify_handler (store, &page_attachments->priv->store_row_deleted_handler_id);
+	}
+
+	g_clear_object (&page_attachments->priv->store);
+
+	g_slist_free_full (page_attachments->priv->temporary_files, temporary_file_free);
+	page_attachments->priv->temporary_files = NULL;
+
+	G_OBJECT_CLASS (e_comp_editor_page_attachments_parent_class)->dispose (object);
+}
+
+static void
+ecep_attachments_setup_ui (ECompEditorPageAttachments *page_attachments)
+{
+	const gchar *ui =
+		"<ui>"
+		"  <menubar action='main-menu'>"
+		"    <menu action='insert-menu'>"
+		"      <menuitem action='attachments-attach'/>"
+		"    </menu>"
+		"    <menu action='options-menu'>"
+		"      <placeholder name='tabs'>"
+		"        <menuitem action='page-attachments'/>"
+		"      </placeholder>"
+		"    </menu>"
+		"  </menubar>"
+		"</ui>";
+
+	GtkActionEntry editable_entries[] = {
+		{ "attachments-attach",
+		  "mail-attachment",
+		  N_("_Attachment…"),
+		  "<Control>m",
+		  N_("Attach a file"),
+		  G_CALLBACK (ecep_attachments_action_attach_cb) }
+	};
+
+	GtkActionEntry options_entries[] = {
+		{ "page-attachments",
+		  "mail-attachment",
+		  N_("_Attachments"),
+		  NULL,
+		  N_("Show attachments"),
+		  G_CALLBACK (ecep_attachments_select_page_cb) }
+	};
+
+	ECompEditor *comp_editor;
+	GtkUIManager *ui_manager;
+	GtkActionGroup *action_group;
+	GtkAction *action;
+	GError *error = NULL;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page_attachments));
+
+	comp_editor = e_comp_editor_page_ref_editor (E_COMP_EDITOR_PAGE (page_attachments));
+	ui_manager = e_comp_editor_get_ui_manager (comp_editor);
+	action_group = e_comp_editor_get_action_group (comp_editor, "editable");
+
+	gtk_action_group_add_actions (
+		action_group, editable_entries,
+		G_N_ELEMENTS (editable_entries), page_attachments);
+
+	action = gtk_action_group_get_action (action_group, "attachments-attach");
+
+	e_binding_bind_property (
+		page_attachments, "visible",
+		action, "visible",
+		G_BINDING_SYNC_CREATE);
+
+	action_group = e_comp_editor_get_action_group (comp_editor, "individual");
+
+	gtk_action_group_add_actions (
+		action_group, options_entries,
+		G_N_ELEMENTS (options_entries), page_attachments);
+
+	action = gtk_action_group_get_action (action_group, "page-attachments");
+
+	e_binding_bind_property (
+		page_attachments, "visible",
+		action, "visible",
+		G_BINDING_SYNC_CREATE);
+
+	gtk_ui_manager_add_ui_from_string (ui_manager, ui, -1, &error);
+	if (error != NULL) {
+		g_warning ("%s: Failed to add UI from string: %s", G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+
+	g_clear_object (&comp_editor);
+}
+
+static void
+ecep_attachments_constructed (GObject *object)
+{
+	ECompEditorPageAttachments *page_attachments;
+	ECompEditor *comp_editor;
+	GSettings *settings;
+	GtkSizeGroup *size_group;
+	GtkWidget *container;
+	GtkWidget *widget;
+	GtkAction *action;
+
+	G_OBJECT_CLASS (e_comp_editor_page_attachments_parent_class)->constructed (object);
+
+	page_attachments = E_COMP_EDITOR_PAGE_ATTACHMENTS (object);
+
+	page_attachments->priv->store = e_attachment_store_new ();
+
+	page_attachments->priv->store_row_inserted_handler_id =
+		g_signal_connect_swapped (page_attachments->priv->store, "row-inserted",
+			G_CALLBACK (e_comp_editor_page_emit_changed), page_attachments);
+	page_attachments->priv->store_row_deleted_handler_id =
+		g_signal_connect_swapped (page_attachments->priv->store, "row-deleted",
+			G_CALLBACK (e_comp_editor_page_emit_changed), page_attachments);
+
+	/* Keep the expander label and combo box the same height. */
+	size_group = gtk_size_group_new (GTK_SIZE_GROUP_VERTICAL);
+
+	/* Construct the Attachment Views */
+
+	widget = gtk_notebook_new ();
+	gtk_notebook_set_show_tabs (GTK_NOTEBOOK (widget), FALSE);
+	gtk_grid_attach (GTK_GRID (page_attachments), widget, 0, 1, 1, 1);
+	page_attachments->priv->notebook = widget;
+	gtk_widget_show (widget);
+
+	g_object_set (G_OBJECT (widget),
+		"hexpand", TRUE,
+		"halign", GTK_ALIGN_FILL,
+		"vexpand", TRUE,
+		"valign", GTK_ALIGN_FILL,
+		NULL);
+
+	container = page_attachments->priv->notebook;
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (widget),
+		GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (widget), GTK_SHADOW_IN);
+	gtk_notebook_append_page (GTK_NOTEBOOK (container), widget, NULL);
+	gtk_widget_show (widget);
+
+	container = widget;
+
+	widget = e_attachment_icon_view_new ();
+	gtk_widget_set_can_focus (widget, TRUE);
+	gtk_icon_view_set_model (GTK_ICON_VIEW (widget), page_attachments->priv->store);
+	gtk_container_add (GTK_CONTAINER (container), widget);
+	page_attachments->priv->icon_view = widget;
+	g_object_set (G_OBJECT (widget),
+		"hexpand", TRUE,
+		"halign", GTK_ALIGN_FILL,
+		"vexpand", TRUE,
+		"valign", GTK_ALIGN_FILL,
+		NULL);
+	gtk_widget_show (widget);
+
+	container = page_attachments->priv->notebook;
+
+	widget = gtk_scrolled_window_new (NULL, NULL);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (widget),
+		GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (widget), GTK_SHADOW_IN);
+	gtk_notebook_append_page (GTK_NOTEBOOK (container), widget, NULL);
+	gtk_widget_show (widget);
+
+	container = widget;
+
+	widget = e_attachment_tree_view_new ();
+	gtk_widget_set_can_focus (widget, TRUE);
+	gtk_tree_view_set_model (GTK_TREE_VIEW (widget), page_attachments->priv->store);
+	gtk_container_add (GTK_CONTAINER (container), widget);
+	page_attachments->priv->tree_view = widget;
+	g_object_set (G_OBJECT (widget),
+		"hexpand", TRUE,
+		"halign", GTK_ALIGN_FILL,
+		"vexpand", TRUE,
+		"valign", GTK_ALIGN_FILL,
+		NULL);
+	gtk_widget_show (widget);
+
+	/* Construct the Controls */
+
+	widget = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
+	gtk_grid_attach (GTK_GRID (page_attachments), widget, 0, 0, 1, 1);
+	gtk_widget_show (widget);
+	page_attachments->priv->controls_container = widget;
+
+	container = widget;
+
+	widget = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+	gtk_widget_set_margin_right (widget, 6);
+	gtk_widget_set_margin_left (widget, 6);
+	gtk_box_pack_end (GTK_BOX (container), widget, FALSE, FALSE, 0);
+	gtk_widget_show (widget);
+
+	container = widget;
+
+	/* The "Add Attachment" button proxies the "add" action from
+	 * one of the two attachment views.  Doesn't matter which. */
+	widget = gtk_button_new ();
+	action = e_attachment_view_get_action (E_ATTACHMENT_VIEW (page_attachments->priv->icon_view), "add");
+	gtk_button_set_image (GTK_BUTTON (widget), gtk_image_new ());
+	gtk_activatable_set_related_action (GTK_ACTIVATABLE (widget), action);
+	gtk_box_pack_end (GTK_BOX (container), widget, FALSE, FALSE, 0);
+	gtk_widget_show (widget);
+
+	widget = gtk_combo_box_text_new ();
+	gtk_size_group_add_widget (size_group, widget);
+	gtk_combo_box_text_append_text (
+		GTK_COMBO_BOX_TEXT (widget), _("Icon View"));
+	gtk_combo_box_text_append_text (
+		GTK_COMBO_BOX_TEXT (widget), _("List View"));
+	gtk_box_pack_end (GTK_BOX (container), widget, FALSE, FALSE, 0);
+	page_attachments->priv->combo_box = widget;
+	gtk_widget_show (widget);
+
+	widget = gtk_image_new_from_icon_name (
+		"mail-attachment", GTK_ICON_SIZE_MENU);
+	gtk_box_pack_start (GTK_BOX (container), widget, FALSE, FALSE, 0);
+	page_attachments->priv->status_icon = widget;
+	gtk_widget_show (widget);
+
+	widget = gtk_label_new (NULL);
+	gtk_label_set_use_markup (GTK_LABEL (widget), TRUE);
+	gtk_box_pack_start (GTK_BOX (container), widget, FALSE, FALSE, 0);
+	page_attachments->priv->status_label = widget;
+	gtk_widget_show (widget);
+
+	e_signal_connect_notify_swapped (
+		page_attachments->priv->store, "notify::num-attachments",
+		G_CALLBACK (ecep_attachments_update_status), page_attachments);
+
+	e_signal_connect_notify_swapped (
+		page_attachments->priv->store, "notify::total-size",
+		G_CALLBACK (ecep_attachments_update_status), page_attachments);
+
+	g_object_unref (size_group);
+
+	ecep_attachments_update_status (page_attachments);
+
+	e_binding_bind_property (
+		object, "active-view",
+		page_attachments->priv->combo_box, "active",
+		G_BINDING_BIDIRECTIONAL |
+		G_BINDING_SYNC_CREATE);
+
+	e_binding_bind_property (
+		object, "active-view",
+		page_attachments->priv->notebook, "page",
+		G_BINDING_BIDIRECTIONAL |
+		G_BINDING_SYNC_CREATE);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.shell");
+
+	g_settings_bind (
+		settings, "attachment-view",
+		object, "active-view",
+		G_SETTINGS_BIND_DEFAULT);
+
+	g_clear_object (&settings);
+
+	ecep_attachments_setup_ui (page_attachments);
+
+	comp_editor = e_comp_editor_page_ref_editor (E_COMP_EDITOR_PAGE (page_attachments));
+	action = e_comp_editor_get_action (comp_editor, "attachments-attach");
+
+	e_binding_bind_property (
+		action, "sensitive",
+		page_attachments->priv->icon_view, "editable",
+		G_BINDING_SYNC_CREATE);
+
+	e_binding_bind_property (
+		action, "sensitive",
+		page_attachments->priv->tree_view, "editable",
+		G_BINDING_SYNC_CREATE);
+
+	g_clear_object (&comp_editor);
+}
+
+static void
+e_comp_editor_page_attachments_init (ECompEditorPageAttachments *page_attachments)
+{
+	page_attachments->priv = G_TYPE_INSTANCE_GET_PRIVATE (page_attachments,
+		E_TYPE_COMP_EDITOR_PAGE_ATTACHMENTS,
+		ECompEditorPageAttachmentsPrivate);
+}
+
+static void
+e_comp_editor_page_attachments_class_init (ECompEditorPageAttachmentsClass *klass)
+{
+	ECompEditorPageClass *page_class;
+	GtkWidgetClass *widget_class;
+	GObjectClass *object_class;
+
+	g_type_class_add_private (klass, sizeof (ECompEditorPageAttachmentsPrivate));
+
+	page_class = E_COMP_EDITOR_PAGE_CLASS (klass);
+	page_class->sensitize_widgets = ecep_attachments_sensitize_widgets;
+	page_class->fill_widgets = ecep_attachments_fill_widgets;
+	page_class->fill_component = ecep_attachments_fill_component;
+
+	widget_class = GTK_WIDGET_CLASS (klass);
+	widget_class->drag_motion = ecep_attachments_drag_motion;
+	widget_class->drag_data_received = ecep_attachments_drag_data_received;
+
+	object_class = G_OBJECT_CLASS (klass);
+	object_class->set_property = ecep_attachments_set_property;
+	object_class->get_property = ecep_attachments_get_property;
+	object_class->dispose = ecep_attachments_dispose;
+	object_class->constructed = ecep_attachments_constructed;
+
+	g_object_class_install_property (
+		object_class,
+		PROP_ACTIVE_VIEW,
+		g_param_spec_int (
+			"active-view",
+			"Active View",
+			NULL,
+			0,
+			NUM_VIEWS,
+			0,
+			G_PARAM_READWRITE |
+			G_PARAM_CONSTRUCT |
+			G_PARAM_STATIC_STRINGS));
+}
+
+ECompEditorPage *
+e_comp_editor_page_attachments_new (ECompEditor *editor)
+{
+	g_return_val_if_fail (E_IS_COMP_EDITOR (editor), NULL);
+
+	return g_object_new (E_TYPE_COMP_EDITOR_PAGE_ATTACHMENTS,
+		"editor", editor,
+		NULL);
+}
+
+gint
+e_comp_editor_page_attachments_get_active_view (ECompEditorPageAttachments *page_attachments)
+{
+	g_return_val_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page_attachments), 0);
+
+	return page_attachments->priv->active_view;
+}
+
+void
+e_comp_editor_page_attachments_set_active_view (ECompEditorPageAttachments *page_attachments,
+						gint view)
+{
+	EAttachmentView *source;
+	EAttachmentView *target;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page_attachments));
+	g_return_if_fail (view >= 0 && view < NUM_VIEWS);
+
+	if (view == page_attachments->priv->active_view)
+		return;
+
+	page_attachments->priv->active_view = view;
+
+	/* Synchronize the item selection of the view we're
+	 * switching TO with the view we're switching FROM. */
+	if (view == 0) {
+		/* from tree view to icon view */
+		source = E_ATTACHMENT_VIEW (page_attachments->priv->tree_view);
+		target = E_ATTACHMENT_VIEW (page_attachments->priv->icon_view);
+	} else {
+		/* from icon view to tree view */
+		source = E_ATTACHMENT_VIEW (page_attachments->priv->icon_view);
+		target = E_ATTACHMENT_VIEW (page_attachments->priv->tree_view);
+	}
+
+	e_attachment_view_sync_selection (source, target);
+
+	g_object_notify (G_OBJECT (page_attachments), "active-view");
+}
+
+EAttachmentStore *
+e_comp_editor_page_attachments_get_store (ECompEditorPageAttachments *page_attachments)
+{
+	g_return_val_if_fail (E_IS_COMP_EDITOR_PAGE_ATTACHMENTS (page_attachments), NULL);
+
+	return E_ATTACHMENT_STORE (page_attachments->priv->store);
+}
diff -urN a/src/calendar/gui/e-comp-editor-task.c b/src/calendar/gui/e-comp-editor-task.c
--- a/src/calendar/gui/e-comp-editor-task.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor-task.c	2022-01-08 18:47:17.604879289 -0800
@@ -779,7 +779,7 @@
 		{ "all-day-task",
 		  "stock_new-24h-appointment",
 		  N_("All _Day Task"),
-		  "<Control>Y",
+		  "<Super>Y",
 		  N_("Toggles whether to have All Day Task"),
 		  NULL,
 		  FALSE }
diff -urN a/src/calendar/gui/e-comp-editor-task.c.orig b/src/calendar/gui/e-comp-editor-task.c.orig
--- a/src/calendar/gui/e-comp-editor-task.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/calendar/gui/e-comp-editor-task.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,1016 @@
+/*
+ * Copyright (C) 2015 Red Hat, Inc. (www.redhat.com)
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "evolution-config.h"
+
+#include <glib/gi18n-lib.h>
+#include <gtk/gtk.h>
+
+#include <e-util/e-util.h>
+
+#include "calendar-config.h"
+#include "comp-util.h"
+#include "e-comp-editor.h"
+#include "e-comp-editor-page.h"
+#include "e-comp-editor-page-attachments.h"
+#include "e-comp-editor-page-general.h"
+#include "e-comp-editor-page-recurrence.h"
+#include "e-comp-editor-page-reminders.h"
+#include "e-comp-editor-property-part.h"
+#include "e-comp-editor-property-parts.h"
+
+#include "e-comp-editor-task.h"
+
+struct _ECompEditorTaskPrivate {
+	ECompEditorPage *page_general;
+	ECompEditorPage *recurrence_page;
+	ECompEditorPage *reminders_page;
+	ECompEditorPropertyPart *categories;
+	ECompEditorPropertyPart *dtstart;
+	ECompEditorPropertyPart *due_date;
+	ECompEditorPropertyPart *completed_date;
+	ECompEditorPropertyPart *percentcomplete;
+	ECompEditorPropertyPart *status;
+	ECompEditorPropertyPart *timezone;
+	ECompEditorPropertyPart *description;
+
+	gpointer in_the_past_alert;
+	gpointer insensitive_info_alert;
+	gboolean dtstart_is_unset;
+	gboolean due_is_unset;
+};
+
+G_DEFINE_TYPE (ECompEditorTask, e_comp_editor_task, E_TYPE_COMP_EDITOR)
+
+static ICalTimezone *
+ece_task_get_timezone_from_property (ECompEditor *comp_editor,
+				     ICalProperty *property)
+{
+	ECalClient *client;
+	ICalParameter *param;
+	ICalTimezone *zone = NULL;
+	const gchar *tzid;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR (comp_editor), NULL);
+
+	if (!property)
+		return NULL;
+
+	param = i_cal_property_get_first_parameter (property, I_CAL_TZID_PARAMETER);
+	if (!param)
+		return NULL;
+
+	tzid = i_cal_parameter_get_tzid (param);
+	if (!tzid || !*tzid) {
+		g_clear_object (&param);
+		return NULL;
+	}
+
+	if (g_ascii_strcasecmp (tzid, "UTC") == 0) {
+		g_clear_object (&param);
+		return i_cal_timezone_get_utc_timezone ();
+	}
+
+	client = e_comp_editor_get_source_client (comp_editor);
+	/* It should be already fetched for the UI, thus this should be non-blocking. */
+	if (client && e_cal_client_get_timezone_sync (client, tzid, &zone, NULL, NULL) && zone) {
+		g_clear_object (&param);
+		return zone;
+	}
+
+	zone = i_cal_timezone_get_builtin_timezone_from_tzid (tzid);
+	if (!zone)
+		zone = i_cal_timezone_get_builtin_timezone (tzid);
+
+	g_clear_object (&param);
+
+	return zone;
+}
+
+static ICalTime *
+ece_task_get_completed (ICalComponent *comp)
+{
+	ICalProperty *prop;
+	ICalTime *tt;
+
+	g_return_val_if_fail (I_CAL_IS_COMPONENT (comp), NULL);
+
+	prop = i_cal_component_get_first_property (comp, I_CAL_COMPLETED_PROPERTY);
+	if (!prop)
+		return NULL;
+
+	tt = i_cal_property_get_completed (prop);
+
+	g_object_unref (prop);
+
+	return tt;
+}
+
+static void
+ece_task_update_timezone (ECompEditorTask *task_editor,
+			  gboolean *force_allday)
+{
+	struct _props_data {
+		ICalPropertyKind kind;
+		ICalTime * (*get_func) (ICalComponent *comp);
+	} properties[] = {
+		{ I_CAL_DTSTART_PROPERTY, i_cal_component_get_dtstart },
+		{ I_CAL_DUE_PROPERTY, i_cal_component_get_due },
+		{ I_CAL_COMPLETED_PROPERTY, ece_task_get_completed }
+	};
+	ECompEditor *comp_editor;
+	ICalComponent *component;
+	ICalTimezone *zone = NULL;
+	gboolean has_property = FALSE;
+	gint ii;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	if (force_allday)
+		*force_allday = FALSE;
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+
+	component = e_comp_editor_get_component (comp_editor);
+	if (!component)
+		return;
+
+	for (ii = 0; !has_property && ii < G_N_ELEMENTS (properties); ii++) {
+		if (e_cal_util_component_has_property (component, properties[ii].kind)) {
+			ICalTime *dt;
+
+			has_property = TRUE;
+
+			dt = properties[ii].get_func (component);
+			if (dt && i_cal_time_is_valid_time (dt)) {
+				if (force_allday && i_cal_time_is_date (dt))
+					*force_allday = TRUE;
+
+				if (i_cal_time_is_utc (dt)) {
+					zone = i_cal_timezone_get_utc_timezone ();
+				} else {
+					ICalProperty *prop;
+
+					prop = i_cal_component_get_first_property (component, properties[ii].kind);
+					zone = ece_task_get_timezone_from_property (comp_editor, prop);
+					g_clear_object (&prop);
+				}
+			}
+
+			g_clear_object (&dt);
+		}
+	}
+
+	if (has_property) {
+		GtkWidget *edit_widget;
+		ICalTimezone *cfg_zone;
+
+		edit_widget = e_comp_editor_property_part_get_edit_widget (task_editor->priv->timezone);
+
+		e_timezone_entry_set_timezone (E_TIMEZONE_ENTRY (edit_widget), zone);
+
+		cfg_zone = calendar_config_get_icaltimezone ();
+
+		if (zone && cfg_zone && zone != cfg_zone &&
+		    (g_strcmp0 (i_cal_timezone_get_location (zone), i_cal_timezone_get_location (cfg_zone)) != 0 ||
+		     g_strcmp0 (i_cal_timezone_get_tzid (zone), i_cal_timezone_get_tzid (cfg_zone)) != 0)) {
+			/* Show timezone part */
+			GtkAction *action;
+
+			action = e_comp_editor_get_action (comp_editor, "view-timezone");
+			gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (action), TRUE);
+		}
+	}
+}
+
+static void
+ece_task_notify_source_client_cb (GObject *object,
+				  GParamSpec *param,
+				  gpointer user_data)
+{
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (object));
+
+	ece_task_update_timezone (E_COMP_EDITOR_TASK (object), NULL);
+}
+
+static void
+ece_task_notify_target_client_cb (GObject *object,
+				  GParamSpec *param,
+				  gpointer user_data)
+{
+	ECompEditorTask *task_editor;
+	ECompEditor *comp_editor;
+	ECalClient *cal_client;
+	GtkWidget *edit_widget;
+	GtkAction *action;
+	gboolean date_only;
+	gboolean was_allday;
+	gboolean can_recur;
+	gboolean can_reminders;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (object));
+
+	task_editor = E_COMP_EDITOR_TASK (object);
+	comp_editor = E_COMP_EDITOR (task_editor);
+	cal_client = e_comp_editor_get_target_client (comp_editor);
+
+	action = e_comp_editor_get_action (comp_editor, "all-day-task");
+	was_allday = gtk_toggle_action_get_active (GTK_TOGGLE_ACTION (action));
+
+	date_only = !cal_client || e_client_check_capability (E_CLIENT (cal_client), E_CAL_STATIC_CAPABILITY_TASK_DATE_ONLY);
+
+	e_comp_editor_property_part_datetime_set_date_only (E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->dtstart), date_only);
+	e_comp_editor_property_part_datetime_set_date_only (E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->due_date), date_only);
+	e_comp_editor_property_part_datetime_set_date_only (E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->completed_date), date_only);
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (task_editor->priv->timezone);
+	gtk_widget_set_sensitive (edit_widget, !date_only);
+
+	action = e_comp_editor_get_action (comp_editor, "view-timezone");
+	gtk_action_set_sensitive (action, !date_only);
+
+	action = e_comp_editor_get_action (comp_editor, "all-day-task");
+	gtk_action_set_visible (action, !date_only);
+
+	if (was_allday) {
+		action = e_comp_editor_get_action (comp_editor, "all-day-task");
+		gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (action), TRUE);
+	}
+
+	can_reminders = !cal_client || !e_client_check_capability (E_CLIENT (cal_client), E_CAL_STATIC_CAPABILITY_TASK_NO_ALARM);
+	gtk_widget_set_visible (GTK_WIDGET (task_editor->priv->reminders_page), can_reminders);
+
+	can_recur = !cal_client || e_client_check_capability (E_CLIENT (cal_client), E_CAL_STATIC_CAPABILITY_TASK_CAN_RECUR);
+	gtk_widget_set_visible (GTK_WIDGET (task_editor->priv->recurrence_page), can_recur);
+}
+
+static void
+ece_task_check_dates_in_the_past (ECompEditorTask *task_editor)
+{
+	guint32 flags;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	flags = e_comp_editor_get_flags (E_COMP_EDITOR (task_editor));
+
+	if (task_editor->priv->in_the_past_alert)
+		e_alert_response (task_editor->priv->in_the_past_alert, GTK_RESPONSE_OK);
+
+	if ((flags & E_COMP_EDITOR_FLAG_IS_NEW) != 0) {
+		GString *message = NULL;
+		ICalTime *dtstart_itt, *due_date_itt;
+
+		dtstart_itt = e_comp_editor_property_part_datetime_get_value (
+			E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->dtstart));
+		due_date_itt = e_comp_editor_property_part_datetime_get_value (
+			E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->due_date));
+
+		if (cal_comp_util_compare_time_with_today (dtstart_itt) < 0)
+			message = g_string_new (_("Task’s start date is in the past"));
+
+		if (cal_comp_util_compare_time_with_today (due_date_itt) < 0) {
+			if (message)
+				g_string_append_c (message, '\n');
+			else
+				message = g_string_new ("");
+
+			g_string_append (message, _("Task’s due date is in the past"));
+		}
+
+		if (message) {
+			EAlert *alert;
+
+			alert = e_comp_editor_add_warning (E_COMP_EDITOR (task_editor), message->str, NULL);
+
+			task_editor->priv->in_the_past_alert = alert;
+
+			if (alert)
+				g_object_add_weak_pointer (G_OBJECT (alert), &task_editor->priv->in_the_past_alert);
+
+			g_string_free (message, TRUE);
+			g_clear_object (&alert);
+		}
+
+		g_clear_object (&dtstart_itt);
+		g_clear_object (&due_date_itt);
+	}
+}
+
+static void
+ece_task_dtstart_changed_cb (EDateEdit *date_edit,
+			     ECompEditorTask *task_editor)
+{
+	ECompEditor *comp_editor;
+	gboolean was_unset;
+
+	g_return_if_fail (E_IS_DATE_EDIT (date_edit));
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	was_unset = task_editor->priv->dtstart_is_unset;
+	task_editor->priv->dtstart_is_unset = e_date_edit_get_time (date_edit) == (time_t) -1;
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+
+	if (e_comp_editor_get_updating (comp_editor))
+		return;
+
+	e_comp_editor_set_updating (comp_editor, TRUE);
+
+	e_comp_editor_ensure_start_before_end (E_COMP_EDITOR (task_editor),
+		task_editor->priv->dtstart, task_editor->priv->due_date,
+		TRUE);
+
+	/* When setting DTSTART for the first time, derive the type from the DUE,
+	   otherwise the DUE has changed the type to the DATE only. */
+	if (was_unset) {
+		e_comp_editor_ensure_same_value_type (E_COMP_EDITOR (task_editor),
+			task_editor->priv->due_date, task_editor->priv->dtstart);
+	} else {
+		e_comp_editor_ensure_same_value_type (E_COMP_EDITOR (task_editor),
+			task_editor->priv->dtstart, task_editor->priv->due_date);
+	}
+
+	e_comp_editor_set_updating (comp_editor, FALSE);
+
+	ece_task_check_dates_in_the_past (task_editor);
+}
+
+static void
+ece_task_due_date_changed_cb (EDateEdit *date_edit,
+			      ECompEditorTask *task_editor)
+{
+	ECompEditor *comp_editor;
+	gboolean was_unset;
+
+	g_return_if_fail (E_IS_DATE_EDIT (date_edit));
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	was_unset = task_editor->priv->due_is_unset;
+	task_editor->priv->due_is_unset = e_date_edit_get_time (date_edit) == (time_t) -1;
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+
+	if (e_comp_editor_get_updating (comp_editor))
+		return;
+
+	e_comp_editor_set_updating (comp_editor, TRUE);
+
+	e_comp_editor_ensure_start_before_end (E_COMP_EDITOR (task_editor),
+		task_editor->priv->dtstart, task_editor->priv->due_date,
+		FALSE);
+
+	/* When setting DUE for the first time, derive the type from the DTSTART,
+	   otherwise the DTSTART has changed the type to the DATE only. */
+	if (was_unset) {
+		e_comp_editor_ensure_same_value_type (E_COMP_EDITOR (task_editor),
+			task_editor->priv->dtstart, task_editor->priv->due_date);
+	} else {
+		e_comp_editor_ensure_same_value_type (E_COMP_EDITOR (task_editor),
+			task_editor->priv->due_date, task_editor->priv->dtstart);
+	}
+
+	e_comp_editor_set_updating (comp_editor, FALSE);
+
+	ece_task_check_dates_in_the_past (task_editor);
+}
+
+static void
+ece_task_completed_date_changed_cb (EDateEdit *date_edit,
+				    ECompEditorTask *task_editor)
+{
+	GtkSpinButton *percent_spin;
+	ECompEditor *comp_editor;
+	ICalTime *itt;
+	gint status;
+
+	g_return_if_fail (E_IS_DATE_EDIT (date_edit));
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+
+	if (e_comp_editor_get_updating (comp_editor))
+		return;
+
+	e_comp_editor_set_updating (comp_editor, TRUE);
+
+	status = e_comp_editor_property_part_picker_with_map_get_selected (
+		E_COMP_EDITOR_PROPERTY_PART_PICKER_WITH_MAP (task_editor->priv->status));
+	itt = e_comp_editor_property_part_datetime_get_value (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->completed_date));
+	percent_spin = GTK_SPIN_BUTTON (e_comp_editor_property_part_get_edit_widget (task_editor->priv->percentcomplete));
+
+	if (!itt || i_cal_time_is_null_time (itt)) {
+		if (status == I_CAL_STATUS_COMPLETED) {
+			e_comp_editor_property_part_picker_with_map_set_selected (
+				E_COMP_EDITOR_PROPERTY_PART_PICKER_WITH_MAP (task_editor->priv->status),
+				I_CAL_STATUS_NONE);
+
+			gtk_spin_button_set_value (percent_spin, 0);
+		}
+	} else {
+		if (status != I_CAL_STATUS_COMPLETED) {
+			e_comp_editor_property_part_picker_with_map_set_selected (
+				E_COMP_EDITOR_PROPERTY_PART_PICKER_WITH_MAP (task_editor->priv->status),
+				I_CAL_STATUS_COMPLETED);
+		}
+
+		gtk_spin_button_set_value (percent_spin, 100);
+	}
+
+	e_comp_editor_set_updating (comp_editor, FALSE);
+
+	g_clear_object (&itt);
+}
+
+static void
+ece_task_status_changed_cb (GtkComboBox *combo_box,
+			    ECompEditorTask *task_editor)
+{
+	ECompEditor *comp_editor;
+	GtkSpinButton *percent_spin;
+	EDateEdit *completed_date;
+	gint status;
+
+	g_return_if_fail (GTK_IS_COMBO_BOX (combo_box));
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+
+	if (e_comp_editor_get_updating (comp_editor))
+		return;
+
+	e_comp_editor_set_updating (comp_editor, TRUE);
+
+	percent_spin = GTK_SPIN_BUTTON (e_comp_editor_property_part_get_edit_widget (task_editor->priv->percentcomplete));
+	completed_date = E_DATE_EDIT (e_comp_editor_property_part_get_edit_widget (task_editor->priv->completed_date));
+	status = e_comp_editor_property_part_picker_with_map_get_selected (
+		E_COMP_EDITOR_PROPERTY_PART_PICKER_WITH_MAP (task_editor->priv->status));
+
+	if (status == I_CAL_STATUS_NONE) {
+		gtk_spin_button_set_value (percent_spin, 0);
+		e_date_edit_set_time (completed_date, (time_t) -1);
+	} else if (status == I_CAL_STATUS_INPROCESS) {
+		gint percent_complete = gtk_spin_button_get_value_as_int (percent_spin);
+
+		if (percent_complete <= 0 || percent_complete >= 100)
+			gtk_spin_button_set_value (percent_spin, 50);
+
+		e_date_edit_set_time (completed_date, (time_t) -1);
+	} else if (status == I_CAL_STATUS_COMPLETED) {
+		gtk_spin_button_set_value (percent_spin, 100);
+		e_date_edit_set_time (completed_date, time (NULL));
+	}
+
+	e_comp_editor_set_updating (comp_editor, FALSE);
+}
+
+static void
+ece_task_percentcomplete_value_changed_cb (GtkSpinButton *spin_button,
+					   ECompEditorTask *task_editor)
+{
+	ECompEditor *comp_editor;
+	GtkSpinButton *percent_spin;
+	EDateEdit *completed_date;
+	gint status, percent;
+	time_t ctime;
+
+	g_return_if_fail (GTK_IS_SPIN_BUTTON (spin_button));
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+
+	if (e_comp_editor_get_updating (comp_editor))
+		return;
+
+	e_comp_editor_set_updating (comp_editor, TRUE);
+
+	percent_spin = GTK_SPIN_BUTTON (e_comp_editor_property_part_get_edit_widget (task_editor->priv->percentcomplete));
+	completed_date = E_DATE_EDIT (e_comp_editor_property_part_get_edit_widget (task_editor->priv->completed_date));
+
+	percent = gtk_spin_button_get_value_as_int (percent_spin);
+	if (percent == 100) {
+		ctime = time (NULL);
+		status = I_CAL_STATUS_COMPLETED;
+	} else {
+		ctime = (time_t) -1;
+
+		if (percent == 0)
+			status = I_CAL_STATUS_NONE;
+		else
+			status = I_CAL_STATUS_INPROCESS;
+	}
+
+	e_comp_editor_property_part_picker_with_map_set_selected (
+		E_COMP_EDITOR_PROPERTY_PART_PICKER_WITH_MAP (task_editor->priv->status), status);
+	e_date_edit_set_time (completed_date, ctime);
+
+	e_comp_editor_set_updating (comp_editor, FALSE);
+}
+
+static void
+ece_task_sensitize_widgets (ECompEditor *comp_editor,
+			    gboolean force_insensitive)
+{
+	ECompEditorTask *task_editor;
+	GtkAction *action;
+	gboolean is_organizer;
+	guint32 flags;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (comp_editor));
+
+	E_COMP_EDITOR_CLASS (e_comp_editor_task_parent_class)->sensitize_widgets (comp_editor, force_insensitive);
+
+	flags = e_comp_editor_get_flags (comp_editor);
+	is_organizer = (flags & (E_COMP_EDITOR_FLAG_IS_NEW | E_COMP_EDITOR_FLAG_ORGANIZER_IS_USER)) != 0;
+	task_editor = E_COMP_EDITOR_TASK (comp_editor);
+
+	action = e_comp_editor_get_action (comp_editor, "all-day-task");
+	gtk_action_set_sensitive (action, !force_insensitive);
+
+	if (task_editor->priv->insensitive_info_alert)
+		e_alert_response (task_editor->priv->insensitive_info_alert, GTK_RESPONSE_OK);
+
+	if (force_insensitive || !is_organizer) {
+		ECalClient *client;
+		const gchar *message = NULL;
+
+		client = e_comp_editor_get_target_client (comp_editor);
+		if (!client)
+			message = _("Task cannot be edited, because the selected task list could not be opened");
+		else if (e_client_is_readonly (E_CLIENT (client)))
+			message = _("Task cannot be edited, because the selected task list is read only");
+		else if (!is_organizer)
+			message = _("Changes made to the task will not be sent to the attendees, because you are not the organizer");
+
+		if (message) {
+			EAlert *alert;
+
+			alert = e_comp_editor_add_information (comp_editor, message, NULL);
+
+			task_editor->priv->insensitive_info_alert = alert;
+
+			if (alert)
+				g_object_add_weak_pointer (G_OBJECT (alert), &task_editor->priv->insensitive_info_alert);
+
+			g_clear_object (&alert);
+		}
+	}
+
+	ece_task_check_dates_in_the_past (task_editor);
+}
+
+static void
+ece_task_fill_widgets (ECompEditor *comp_editor,
+		       ICalComponent *component)
+{
+	gboolean force_allday = FALSE;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (comp_editor));
+	g_return_if_fail (I_CAL_IS_COMPONENT (component));
+
+	ece_task_update_timezone (E_COMP_EDITOR_TASK (comp_editor), &force_allday);
+
+	E_COMP_EDITOR_CLASS (e_comp_editor_task_parent_class)->fill_widgets (comp_editor, component);
+
+	if (force_allday) {
+		GtkAction *action;
+
+		action = e_comp_editor_get_action (comp_editor, "all-day-task");
+		gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (action), TRUE);
+	}
+}
+
+static gboolean
+ece_task_fill_component (ECompEditor *comp_editor,
+			 ICalComponent *component)
+{
+	ECompEditorTask *task_editor;
+	ICalTime *itt;
+
+	g_return_val_if_fail (E_IS_COMP_EDITOR_TASK (comp_editor), FALSE);
+
+	task_editor = E_COMP_EDITOR_TASK (comp_editor);
+
+	if (!e_comp_editor_property_part_datetime_check_validity (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->dtstart), NULL, NULL)) {
+
+		e_comp_editor_set_validation_error (comp_editor,
+			task_editor->priv->page_general,
+			e_comp_editor_property_part_get_edit_widget (task_editor->priv->dtstart),
+			_("Start date is not a valid date"));
+
+		return FALSE;
+	}
+
+	if (e_cal_util_component_has_recurrences (component)) {
+		ICalTime *dtstart;
+
+		dtstart = e_comp_editor_property_part_datetime_get_value (E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->dtstart));
+
+		if (!dtstart || i_cal_time_is_null_time (dtstart) || !i_cal_time_is_valid_time (dtstart)) {
+			e_comp_editor_set_validation_error (comp_editor,
+				task_editor->priv->page_general,
+				e_comp_editor_property_part_get_edit_widget (task_editor->priv->dtstart),
+				_("Start date is required for recurring tasks"));
+
+			g_clear_object (&dtstart);
+
+			return FALSE;
+		}
+
+		g_clear_object (&dtstart);
+	}
+
+	if (!e_comp_editor_property_part_datetime_check_validity (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->due_date), NULL, NULL)) {
+
+		e_comp_editor_set_validation_error (comp_editor,
+			task_editor->priv->page_general,
+			e_comp_editor_property_part_get_edit_widget (task_editor->priv->due_date),
+			_("Due date is not a valid date"));
+
+		return FALSE;
+	}
+
+	if (!e_comp_editor_property_part_datetime_check_validity (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->completed_date), NULL, NULL)) {
+
+		e_comp_editor_set_validation_error (comp_editor,
+			task_editor->priv->page_general,
+			e_comp_editor_property_part_get_edit_widget (task_editor->priv->completed_date),
+			_("Completed date is not a valid date"));
+
+		return FALSE;
+	}
+
+	itt = e_comp_editor_property_part_datetime_get_value (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->completed_date));
+	if (cal_comp_util_compare_time_with_today (itt) > 0) {
+		e_comp_editor_set_validation_error (comp_editor,
+			task_editor->priv->page_general,
+			e_comp_editor_property_part_get_edit_widget (task_editor->priv->completed_date),
+			_("Completed date cannot be in the future"));
+
+		g_clear_object (&itt);
+
+		return FALSE;
+	}
+
+	g_clear_object (&itt);
+
+	if (!E_COMP_EDITOR_CLASS (e_comp_editor_task_parent_class)->fill_component (comp_editor, component))
+		return FALSE;
+
+	if (e_cal_util_component_has_recurrences (component)) {
+		ECalClient *cal_client;
+
+		cal_client = e_comp_editor_get_source_client (comp_editor);
+		if (!cal_client)
+			cal_client = e_comp_editor_get_target_client (comp_editor);
+
+		if (cal_client) {
+			if ((e_comp_editor_get_flags (comp_editor) & E_COMP_EDITOR_FLAG_IS_NEW) != 0) {
+				e_cal_util_init_recur_task_sync	(component, cal_client, NULL, NULL);
+			} else if (e_cal_util_component_has_property (component, I_CAL_COMPLETED_PROPERTY)) {
+				e_cal_util_mark_task_complete_sync (component, (time_t) -1, cal_client, NULL, NULL);
+			} else if (!e_cal_util_component_has_property (component, I_CAL_DUE_PROPERTY)) {
+				e_cal_util_init_recur_task_sync	(component, cal_client, NULL, NULL);
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+static void
+ece_task_all_day_notify_active_cb (GObject *object,
+				   GParamSpec *param,
+				   gpointer user_data)
+{
+	ECompEditorTask *task_editor = user_data;
+	gboolean active = FALSE, visible = FALSE;
+
+	g_object_get (object,
+		"active", &active,
+		"visible", &visible,
+		NULL);
+
+	if (!active && visible) {
+		EDateEdit *dtstart_date_edit;
+
+		dtstart_date_edit = E_DATE_EDIT (e_comp_editor_property_part_get_edit_widget (task_editor->priv->dtstart));
+
+		if (e_date_edit_get_time (dtstart_date_edit) != (time_t) -1) {
+			EDateEdit *due_date_edit;
+
+			due_date_edit = E_DATE_EDIT (e_comp_editor_property_part_get_edit_widget (task_editor->priv->due_date));
+
+			if (e_date_edit_get_time (due_date_edit) != (time_t) -1) {
+				gint hour, minute;
+
+				if (e_date_edit_get_time_of_day (dtstart_date_edit, &hour, &minute) !=
+				    e_date_edit_get_time_of_day (due_date_edit, &hour, &minute)) {
+					if (e_date_edit_get_time_of_day (dtstart_date_edit, &hour, &minute))
+						e_date_edit_set_time_of_day (due_date_edit, hour, minute);
+					else
+						e_date_edit_set_time_of_day (due_date_edit, -1, -1);
+				}
+			}
+		}
+	}
+}
+
+static void
+ece_task_setup_ui (ECompEditorTask *task_editor)
+{
+	const gchar *ui =
+		"<ui>"
+		"  <menubar action='main-menu'>"
+		"    <menu action='view-menu'>"
+		"      <placeholder name='parts'>"
+		"        <menuitem action='view-timezone'/>"
+		"        <menuitem action='view-categories'/>"
+		"      </placeholder>"
+		"    </menu>"
+		"    <menu action='options-menu'>"
+		"      <placeholder name='toggles'>"
+		"        <menuitem action='all-day-task'/>"
+		"      </placeholder>"
+		"    </menu>"
+		"  </menubar>"
+		"  <toolbar name='main-toolbar'>"
+		"    <placeholder name='content'>\n"
+		"      <toolitem action='all-day-task'/>\n"
+		"    </placeholder>"
+		"  </toolbar>"
+		"</ui>";
+
+	const GtkToggleActionEntry view_actions[] = {
+		{ "view-categories",
+		  NULL,
+		  N_("_Categories"),
+		  NULL,
+		  N_("Toggles whether to display categories"),
+		  NULL,
+		  FALSE },
+
+		{ "view-timezone",
+		  "stock_timezone",
+		  N_("Time _Zone"),
+		  NULL,
+		  N_("Toggles whether the time zone is displayed"),
+		  NULL,
+		  FALSE },
+
+		{ "all-day-task",
+		  "stock_new-24h-appointment",
+		  N_("All _Day Task"),
+		  "<Control>Y",
+		  N_("Toggles whether to have All Day Task"),
+		  NULL,
+		  FALSE }
+	};
+
+	ECompEditor *comp_editor;
+	GSettings *settings;
+	GtkUIManager *ui_manager;
+	GtkAction *action;
+	GtkActionGroup *action_group;
+	GtkWidget *edit_widget;
+	GError *error = NULL;
+
+	g_return_if_fail (E_IS_COMP_EDITOR_TASK (task_editor));
+
+	comp_editor = E_COMP_EDITOR (task_editor);
+	settings = e_comp_editor_get_settings (comp_editor);
+	ui_manager = e_comp_editor_get_ui_manager (comp_editor);
+	action_group = e_comp_editor_get_action_group (comp_editor, "individual");
+
+	gtk_action_group_add_toggle_actions (action_group,
+		view_actions, G_N_ELEMENTS (view_actions), task_editor);
+
+	gtk_ui_manager_add_ui_from_string (ui_manager, ui, -1, &error);
+
+	e_plugin_ui_register_manager (ui_manager, "org.gnome.evolution.task-editor", task_editor);
+	e_plugin_ui_enable_manager (ui_manager, "org.gnome.evolution.task-editor");
+
+	if (error) {
+		g_critical ("%s: %s", G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+
+	action = e_comp_editor_get_action (comp_editor, "view-timezone");
+	e_binding_bind_property (
+		task_editor->priv->timezone, "visible",
+		action, "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	g_settings_bind (
+		settings, "editor-show-timezone",
+		action, "active",
+		G_SETTINGS_BIND_DEFAULT);
+
+	action = e_comp_editor_get_action (comp_editor, "view-categories");
+	e_binding_bind_property (
+		task_editor->priv->categories, "visible",
+		action, "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	g_settings_bind (
+		settings, "editor-show-categories",
+		action, "active",
+		G_SETTINGS_BIND_DEFAULT);
+
+	action = e_comp_editor_get_action (comp_editor, "all-day-task");
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (task_editor->priv->dtstart);
+	e_binding_bind_property (
+		action, "active",
+		edit_widget, "show-time",
+		G_BINDING_INVERT_BOOLEAN | G_BINDING_BIDIRECTIONAL);
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (task_editor->priv->due_date);
+	e_binding_bind_property (
+		action, "active",
+		edit_widget, "show-time",
+		G_BINDING_INVERT_BOOLEAN);
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (task_editor->priv->completed_date);
+	e_binding_bind_property (
+		action, "active",
+		edit_widget, "show-time",
+		G_BINDING_INVERT_BOOLEAN);
+
+	e_signal_connect_notify (action, "notify::active",
+		G_CALLBACK (ece_task_all_day_notify_active_cb), task_editor);
+}
+
+static void
+e_comp_editor_task_constructed (GObject *object)
+{
+	ECompEditorTask *task_editor;
+	ECompEditor *comp_editor;
+	ECompEditorPage *page;
+	ECompEditorPropertyPart *part, *summary;
+	EFocusTracker *focus_tracker;
+	GtkWidget *edit_widget;
+
+	G_OBJECT_CLASS (e_comp_editor_task_parent_class)->constructed (object);
+
+	task_editor = E_COMP_EDITOR_TASK (object);
+	comp_editor = E_COMP_EDITOR (task_editor);
+	focus_tracker = e_comp_editor_get_focus_tracker (comp_editor);
+
+	page = e_comp_editor_page_general_new (comp_editor,
+		_("_List:"), E_SOURCE_EXTENSION_TASK_LIST,
+		NULL, FALSE, 3);
+
+	part = e_comp_editor_property_part_summary_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 2, 4, 1);
+	summary = part;
+
+	part = e_comp_editor_property_part_location_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 3, 4, 1);
+
+	part = e_comp_editor_property_part_dtstart_new (C_("ECompEditor", "Sta_rt date:"), TRUE, TRUE);
+	e_comp_editor_page_add_property_part (page, part, 0, 4, 2, 1);
+	task_editor->priv->dtstart = part;
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (part);
+	g_signal_connect (edit_widget, "changed", G_CALLBACK (ece_task_dtstart_changed_cb), task_editor);
+
+	part = e_comp_editor_property_part_status_new (I_CAL_VTODO_COMPONENT);
+	e_comp_editor_page_add_property_part (page, part, 2, 4, 2, 1);
+	task_editor->priv->status = part;
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (part);
+	g_signal_connect (edit_widget, "changed", G_CALLBACK (ece_task_status_changed_cb), task_editor);
+
+	part = e_comp_editor_property_part_due_new (TRUE, TRUE);
+	e_comp_editor_page_add_property_part (page, part, 0, 5, 2, 1);
+	task_editor->priv->due_date = part;
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (part);
+	g_signal_connect (edit_widget, "changed", G_CALLBACK (ece_task_due_date_changed_cb), task_editor);
+
+	part = e_comp_editor_property_part_priority_new ();
+	e_comp_editor_page_add_property_part (page, part, 2, 5, 2, 1);
+
+	part = e_comp_editor_property_part_completed_new (TRUE, TRUE);
+	e_comp_editor_page_add_property_part (page, part, 0, 6, 2, 1);
+	task_editor->priv->completed_date = part;
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (part);
+	g_signal_connect (edit_widget, "changed", G_CALLBACK (ece_task_completed_date_changed_cb), task_editor);
+
+	part = e_comp_editor_property_part_percentcomplete_new ();
+	e_comp_editor_page_add_property_part (page, part, 2, 6, 2, 1);
+	task_editor->priv->percentcomplete = part;
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (part);
+	g_signal_connect (edit_widget, "value-changed", G_CALLBACK (ece_task_percentcomplete_value_changed_cb), task_editor);
+
+	part = e_comp_editor_property_part_url_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 7, 2, 1);
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (part);
+	gtk_widget_set_hexpand (edit_widget, TRUE);
+
+	part = e_comp_editor_property_part_classification_new ();
+	e_comp_editor_page_add_property_part (page, part, 2, 7, 2, 1);
+
+	part = e_comp_editor_property_part_timezone_new ();
+	e_comp_editor_page_add_property_part (page, part, 0, 8, 4, 1);
+	task_editor->priv->timezone = part;
+
+	part = e_comp_editor_property_part_categories_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 9, 4, 1);
+	task_editor->priv->categories = part;
+
+	part = e_comp_editor_property_part_description_new (focus_tracker);
+	e_comp_editor_page_add_property_part (page, part, 0, 10, 4, 1);
+	task_editor->priv->description = part;
+
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "General"), page);
+	task_editor->priv->page_general = page;
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (task_editor->priv->timezone);
+	e_comp_editor_property_part_datetime_attach_timezone_entry (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->dtstart),
+		E_TIMEZONE_ENTRY (edit_widget));
+	g_signal_connect_swapped (task_editor->priv->dtstart, "lookup-timezone",
+		G_CALLBACK (e_comp_editor_lookup_timezone), task_editor);
+	e_comp_editor_property_part_datetime_attach_timezone_entry (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->due_date),
+		E_TIMEZONE_ENTRY (edit_widget));
+	g_signal_connect_swapped (task_editor->priv->due_date, "lookup-timezone",
+		G_CALLBACK (e_comp_editor_lookup_timezone), task_editor);
+	e_comp_editor_property_part_datetime_attach_timezone_entry (
+		E_COMP_EDITOR_PROPERTY_PART_DATETIME (task_editor->priv->completed_date),
+		E_TIMEZONE_ENTRY (edit_widget));
+	g_signal_connect_swapped (task_editor->priv->completed_date, "lookup-timezone",
+		G_CALLBACK (e_comp_editor_lookup_timezone), task_editor);
+
+	e_comp_editor_set_time_parts (comp_editor, task_editor->priv->dtstart, task_editor->priv->due_date);
+
+	page = e_comp_editor_page_reminders_new (comp_editor);
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Reminders"), page);
+	task_editor->priv->reminders_page = page;
+
+	page = e_comp_editor_page_recurrence_new (comp_editor);
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Recurrence"), page);
+	task_editor->priv->recurrence_page = page;
+
+	page = e_comp_editor_page_attachments_new (comp_editor);
+	e_comp_editor_add_page (comp_editor, C_("ECompEditorPage", "Attachments"), page);
+
+	ece_task_setup_ui (task_editor);
+
+	edit_widget = e_comp_editor_property_part_get_edit_widget (summary);
+	e_binding_bind_property (edit_widget, "text", comp_editor, "title-suffix", 0);
+	gtk_widget_grab_focus (edit_widget);
+
+	g_signal_connect (comp_editor, "notify::source-client",
+		G_CALLBACK (ece_task_notify_source_client_cb), NULL);
+	g_signal_connect (comp_editor, "notify::target-client",
+		G_CALLBACK (ece_task_notify_target_client_cb), NULL);
+}
+
+static void
+e_comp_editor_task_init (ECompEditorTask *task_editor)
+{
+	task_editor->priv = G_TYPE_INSTANCE_GET_PRIVATE (task_editor, E_TYPE_COMP_EDITOR_TASK, ECompEditorTaskPrivate);
+}
+
+static void
+e_comp_editor_task_class_init (ECompEditorTaskClass *klass)
+{
+	GObjectClass *object_class;
+	ECompEditorClass *comp_editor_class;
+
+	g_type_class_add_private (klass, sizeof (ECompEditorTaskPrivate));
+
+	object_class = G_OBJECT_CLASS (klass);
+	object_class->constructed = e_comp_editor_task_constructed;
+
+	comp_editor_class = E_COMP_EDITOR_CLASS (klass);
+	comp_editor_class->help_section = "tasks-usage";
+	comp_editor_class->title_format_with_attendees = _("Assigned Task — %s");
+	comp_editor_class->title_format_without_attendees = _("Task — %s");
+	comp_editor_class->icon_name = "stock_task";
+	comp_editor_class->sensitize_widgets = ece_task_sensitize_widgets;
+	comp_editor_class->fill_widgets = ece_task_fill_widgets;
+	comp_editor_class->fill_component = ece_task_fill_component;
+}
diff -urN a/src/composer/e-composer-actions.c b/src/composer/e-composer-actions.c
--- a/src/composer/e-composer-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/composer/e-composer-actions.c	2022-01-08 18:47:17.604879289 -0800
@@ -324,21 +324,21 @@
 	{ "attach",
           "mail-attachment",
 	  N_("_Attachment…"),
-	  "<Control>m",
+	  "<Super>m",
 	  N_("Attach a file"),
 	  G_CALLBACK (action_attach_cb) },
 
 	{ "close",
 	  "window-close",
 	  N_("_Close"),
-	  "<Control>w",
+	  "<Super>w",
 	  N_("Close the current file"),
 	  G_CALLBACK (action_close_cb) },
 
 	{ "new-message",
 	  "mail-message-new",
 	  N_("New _Message"),
-	  "<Control>n",
+	  "<Super>n",
 	  N_("Open New Message window"),
 	  G_CALLBACK (action_new_message_cb) },
 
@@ -352,7 +352,7 @@
 	{ "save",
 	  "document-save",
 	  N_("_Save"),
-	  "<Shift><Control>s",
+	  "<Shift><Super>s",
 	  N_("Save the current file"),
 	  G_CALLBACK (action_save_cb) },
 
@@ -385,28 +385,28 @@
 	{ "print",
 	  "document-print",
 	  N_("_Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  NULL,
 	  G_CALLBACK (action_print_cb) },
 
 	{ "print-preview",
 	  "document-print-preview",
 	  N_("Print Pre_view"),
-	  "<Shift><Control>p",
+	  "<Shift><Super>p",
 	  NULL,
 	  G_CALLBACK (action_print_preview_cb) },
 
 	{ "save-draft",
 	  "document-save",
 	  N_("Save as _Draft"),
-	  "<Control>s",
+	  "<Super>s",
 	  N_("Save as draft"),
 	  G_CALLBACK (action_save_draft_cb) },
 
 	{ "send",
 	  "mail-send",
 	  N_("S_end"),
-	  "<Control>Return",
+	  "<Alt><Super>s",
 	  N_("Send this message"),
 	  G_CALLBACK (action_send_cb) },
 };
diff -urN a/src/e-util/e-html-editor-actions.c b/src/e-util/e-html-editor-actions.c
--- a/src/e-util/e-html-editor-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/e-util/e-html-editor-actions.c	2022-01-08 18:47:17.604879289 -0800
@@ -1096,42 +1096,42 @@
 	{ "copy",
 	  "edit-copy",
 	  N_("_Copy"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy selected text to the clipboard"),
 	  NULL }, /* Handled by focus tracker */
 
 	{ "cut",
 	  "edit-cut",
 	  N_("Cu_t"),
-	  "<Control>x",
+	  "<Super>x",
 	  N_("Cut selected text to the clipboard"),
 	  NULL }, /* Handled by focus tracker */
 
 	{ "paste",
 	  "edit-paste",
 	  N_("_Paste"),
-	  "<Control>v",
+	  "<Super>v",
 	  N_("Paste text from the clipboard"),
 	  NULL }, /* Handled by focus tracker */
 
 	{ "redo",
 	  "edit-redo",
 	  N_("_Redo"),
-	  "<Shift><Control>z",
+	  "<Shift><Super>z",
 	  N_("Redo the last undone action"),
 	  G_CALLBACK (action_redo_cb) },
 
 	{ "select-all",
 	  "edit-select-all",
 	  N_("Select _All"),
-	  "<Control>a",
+	  "<Super>a",
 	  NULL,
 	  NULL }, /* Handled by focus tracker */
 
 	{ "undo",
 	  "edit-undo",
 	  N_("_Undo"),
-	  "<Control>z",
+	  "<Super>z",
 	  N_("Undo the last action"),
 	  G_CALLBACK (action_undo_cb) },
 
@@ -1199,7 +1199,7 @@
 	{ "indent",
 	  "format-indent-more",
 	  N_("_Increase Indent"),
-	  "<Control>bracketright",
+	  "<Super>bracketright",
 	  N_("Increase Indent"),
 	  G_CALLBACK (action_indent_cb) },
 
@@ -1234,28 +1234,28 @@
 	{ "paste-quote",
 	  NULL,
 	  N_("Paste _Quotation"),
-	  "<Control><Alt>v",
+	  "<Super><Alt>v",
 	  NULL,
 	  G_CALLBACK (action_paste_quote_cb) },
 
 	{ "show-find",
 	  "edit-find",
 	  N_("_Find…"),
-	  "<Control>f",
+	  "<Super>f",
 	  N_("Search for text"),
 	  G_CALLBACK (action_show_find_cb) },
 
 	{ "find-again",
 	  NULL,
 	  N_("Find A_gain"),
-	  "<Control>g",
+	  "<Super>g",
 	  NULL,
 	  G_CALLBACK (action_find_again_cb) },
 
 	{ "show-replace",
 	  "edit-find-replace",
 	  N_("Re_place…"),
-	  "<Control>h",
+	  "<Super>h",
 	  N_("Search for and replace text"),
 	  G_CALLBACK (action_show_replace_cb) },
 
@@ -1269,14 +1269,14 @@
 	{ "unindent",
 	  "format-indent-less",
 	  N_("_Decrease Indent"),
-	  "<Control>bracketleft",
+	  "<Super>bracketleft",
 	  N_("Decrease Indent"),
 	  G_CALLBACK (action_unindent_cb) },
 
 	{ "wrap-lines",
 	  NULL,
 	  N_("_Wrap Lines"),
-	  "<Control><Shift>k",
+	  "<Super><Shift>k",
 	  NULL,
 	  G_CALLBACK (action_wrap_lines_cb) }
 };
@@ -1286,28 +1286,28 @@
 	{ "justify-center",
 	  "format-justify-center",
 	  N_("_Center"),
-	  "<Control>e",
+	  "<Super>e",
 	  N_("Center Alignment"),
 	  E_CONTENT_EDITOR_ALIGNMENT_CENTER },
 
 	{ "justify-fill",
 	  "format-justify-fill",
 	  N_("_Justified"),
-	  "<Control>j",
+	  "<Super>j",
 	  N_("Align Justified"),
 	  E_CONTENT_EDITOR_ALIGNMENT_JUSTIFY },
 
 	{ "justify-left",
 	  "format-justify-left",
 	  N_("_Left"),
-	  "<Control>l",
+	  "<Super>l",
 	  N_("Left Alignment"),
 	  E_CONTENT_EDITOR_ALIGNMENT_LEFT },
 
 	{ "justify-right",
 	  "format-justify-right",
 	  N_("_Right"),
-	  "<Control>r",
+	  "<Super>r",
 	  N_("Right Alignment"),
 	  E_CONTENT_EDITOR_ALIGNMENT_RIGHT }
 };
@@ -1334,63 +1334,63 @@
 	{ "style-normal",
 	  NULL,
 	  N_("_Normal"),
-	  "<Control>0",
+	  "<Super>0",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_PARAGRAPH },
 
 	{ "style-h1",
 	  NULL,
 	  N_("Heading _1"),
-	  "<Control>1",
+	  "<Super>1",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_H1 },
 
 	{ "style-h2",
 	  NULL,
 	  N_("Heading _2"),
-	  "<Control>2",
+	  "<Super>2",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_H2 },
 
 	{ "style-h3",
 	  NULL,
 	  N_("Heading _3"),
-	  "<Control>3",
+	  "<Super>3",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_H3 },
 
 	{ "style-h4",
 	  NULL,
 	  N_("Heading _4"),
-	  "<Control>4",
+	  "<Super>4",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_H4 },
 
 	{ "style-h5",
 	  NULL,
 	  N_("Heading _5"),
-	  "<Control>5",
+	  "<Super>5",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_H5 },
 
 	{ "style-h6",
 	  NULL,
 	  N_("Heading _6"),
-	  "<Control>6",
+	  "<Super>6",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_H6 },
 
         { "style-preformat",
           NULL,
           N_("_Preformatted"),
-          "<Control>7",
+          "<Super>7",
           NULL,
           E_CONTENT_EDITOR_BLOCK_FORMAT_PRE },
 
 	{ "style-address",
 	  NULL,
 	  N_("A_ddress"),
-	  "<Control>8",
+	  "<Super>8",
 	  NULL,
 	  E_CONTENT_EDITOR_BLOCK_FORMAT_ADDRESS },
 
@@ -1442,7 +1442,7 @@
 	{ "insert-link",
 	  "insert-link",
 	  N_("_Link…"),
-	  "<Control>k",
+	  "<Super>k",
 	  N_("Insert Link"),
 	  G_CALLBACK (action_insert_link_cb) },
 
@@ -1524,7 +1524,7 @@
 	{ "paste-as-text",
 	  NULL,
 	  N_("Paste As _Text"),
-	  "<Shift><Control>v",
+	  "<Shift><Super>v",
 	  NULL,
 	  G_CALLBACK (action_paste_as_text_cb) },
 
@@ -1535,7 +1535,7 @@
 	{ "bold",
 	  "format-text-bold",
 	  N_("_Bold"),
-	  "<Control>b",
+	  "<Super>b",
 	  N_("Bold"),
 	  NULL,
 	  FALSE },
@@ -1543,7 +1543,7 @@
 	{ "italic",
 	  "format-text-italic",
 	  N_("_Italic"),
-	  "<Control>i",
+	  "<Super>i",
 	  N_("Italic"),
 	  NULL,
 	  FALSE },
@@ -1559,7 +1559,7 @@
 	{ "subscript",
 	  NULL,
 	  N_("Subs_cript"),
-	  "<Control><Shift>b",
+	  "<Super><Shift>b",
 	  N_("Subscript"),
 	  NULL,
 	  FALSE },
@@ -1567,7 +1567,7 @@
 	{ "superscript",
 	  NULL,
 	  N_("Su_perscript"),
-	  "<Control><Shift>p",
+	  "<Super><Shift>p",
 	  N_("Superscript"),
 	  NULL,
 	  FALSE },
@@ -1575,7 +1575,7 @@
 	{ "underline",
 	  "format-text-underline",
 	  N_("_Underline"),
-	  "<Control>u",
+	  "<Super>u",
 	  N_("Underline"),
 	  NULL,
 	  FALSE }
diff -urN a/src/e-util/e-html-editor-actions.c.orig b/src/e-util/e-html-editor-actions.c.orig
--- a/src/e-util/e-html-editor-actions.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/e-util/e-html-editor-actions.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,2473 @@
+/* e-html-editor-actions.c
+ *
+ * Copyright (C) 2012 Dan Vrátil <dvratil@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "evolution-config.h"
+
+#include <gio/gio.h>
+#include <glib/gi18n-lib.h>
+#include <string.h>
+#include <enchant.h>
+
+#include "e-html-editor.h"
+#include "e-html-editor-private.h"
+#include "e-html-editor-actions.h"
+#include "e-emoticon-action.h"
+#include "e-emoticon-chooser.h"
+#include "e-gtkemojichooser.h"
+#include "e-image-chooser-dialog.h"
+#include "e-spell-checker.h"
+#include "e-misc-utils.h"
+#include "e-selection.h"
+#include "e-content-editor.h"
+
+static gboolean
+e_html_editor_action_can_run (GtkWidget *widget)
+{
+	GtkWidget *toplevel, *focused;
+
+	g_return_val_if_fail (GTK_IS_WIDGET (widget), FALSE);
+
+	/* The action can be run if the widget is focused... */
+	if (gtk_widget_has_focus (widget))
+		return TRUE;
+
+	toplevel = gtk_widget_get_toplevel (widget);
+	if (!toplevel || !gtk_widget_is_toplevel (toplevel) || !GTK_IS_WINDOW (toplevel))
+		return TRUE;
+
+	focused = gtk_window_get_focus (GTK_WINDOW (toplevel));
+
+	/* ..., or if there is no other widget focused. Eventually the window
+	   can have set the widget as focused, but the widget doesn't have
+	   the flag saet, because the window itself is in the background,
+	   like during the unit tests of the HTML editor.*/
+	return !focused || focused == widget;
+}
+
+static void
+insert_html_file_ready_cb (GFile *file,
+                           GAsyncResult *result,
+                           EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	gchar *contents = NULL;
+	gsize length;
+	GError *error = NULL;
+
+	g_file_load_contents_finish (
+		file, result, &contents, &length, NULL, &error);
+	if (error != NULL) {
+		GtkWidget *dialog;
+
+		dialog = gtk_message_dialog_new (
+			GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (editor))),
+			0, GTK_MESSAGE_ERROR,
+			GTK_BUTTONS_CLOSE, _("Failed to insert HTML file."));
+		gtk_message_dialog_format_secondary_text (
+			GTK_MESSAGE_DIALOG (dialog), "%s.", error->message);
+		gtk_dialog_run (GTK_DIALOG (dialog));
+		gtk_widget_destroy (dialog);
+
+		g_clear_error (&error);
+		g_object_unref (editor);
+		return;
+	}
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_content (
+		cnt_editor, contents, E_CONTENT_EDITOR_INSERT_TEXT_HTML);
+
+	g_free (contents);
+
+	g_object_unref (editor);
+}
+
+static void
+insert_text_file_ready_cb (GFile *file,
+                           GAsyncResult *result,
+                           EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	gchar *contents;
+	gsize length;
+	GError *error = NULL;
+
+	g_file_load_contents_finish (
+		file, result, &contents, &length, NULL, &error);
+	if (error != NULL) {
+		GtkWidget *dialog;
+
+		dialog = gtk_message_dialog_new (
+			GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (editor))),
+			0, GTK_MESSAGE_ERROR,
+			GTK_BUTTONS_CLOSE, _("Failed to insert text file."));
+		gtk_message_dialog_format_secondary_text (
+			GTK_MESSAGE_DIALOG (dialog), "%s.", error->message);
+		gtk_dialog_run (GTK_DIALOG (dialog));
+		gtk_widget_destroy (dialog);
+
+		g_clear_error (&error);
+		g_object_unref (editor);
+		return;
+	}
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_content (
+		cnt_editor, contents, E_CONTENT_EDITOR_INSERT_CONVERT | E_CONTENT_EDITOR_INSERT_TEXT_PLAIN);
+
+	g_free (contents);
+
+	g_object_unref (editor);
+}
+
+/*****************************************************************************
+ * Action Callbacks
+ *****************************************************************************/
+
+static void
+action_context_delete_cell_contents_cb (GtkAction *action,
+                               EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_delete_cell_contents (cnt_editor);
+}
+
+static void
+action_context_delete_column_cb (GtkAction *action,
+                                 EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_delete_column (cnt_editor);
+}
+
+static void
+action_context_delete_row_cb (GtkAction *action,
+                              EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_delete_row (cnt_editor);
+}
+
+static void
+action_context_delete_table_cb (GtkAction *action,
+                                EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_delete_table (cnt_editor);
+}
+
+static void
+action_context_delete_hrule_cb (GtkAction *action,
+				EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_delete_h_rule (cnt_editor);
+}
+
+static void
+action_context_delete_image_cb (GtkAction *action,
+				EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_delete_image (cnt_editor);
+}
+
+static void
+action_context_insert_column_after_cb (GtkAction *action,
+                                       EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_column_after (cnt_editor);
+}
+
+static void
+action_context_insert_column_before_cb (GtkAction *action,
+                                        EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_column_before (cnt_editor);
+}
+
+static void
+action_context_insert_row_above_cb (GtkAction *action,
+                                    EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_row_above (cnt_editor);
+}
+
+static void
+action_context_insert_row_below_cb (GtkAction *action,
+                                    EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_row_below (cnt_editor);
+}
+
+static void
+action_context_remove_link_cb (GtkAction *action,
+                               EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_selection_unlink (cnt_editor);
+}
+
+static void
+action_context_spell_add_cb (GtkAction *action,
+                             EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	ESpellChecker *spell_checker;
+	gchar *word;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	spell_checker = e_content_editor_ref_spell_checker (cnt_editor);
+	word = e_content_editor_get_caret_word (cnt_editor);
+	if (word && *word)
+		e_spell_checker_learn_word (spell_checker, word);
+	g_free (word);
+	g_clear_object (&spell_checker);
+}
+
+static void
+action_context_spell_ignore_cb (GtkAction *action,
+                                EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	ESpellChecker *spell_checker;
+	gchar *word;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	spell_checker = e_content_editor_ref_spell_checker (cnt_editor);
+	word = e_content_editor_get_caret_word (cnt_editor);
+	if (word && *word)
+		e_spell_checker_ignore_word (spell_checker, word);
+	g_free (word);
+	g_clear_object (&spell_checker);
+}
+
+static void
+action_indent_cb (GtkAction *action,
+                  EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (e_html_editor_action_can_run (GTK_WIDGET (cnt_editor)))
+		e_content_editor_selection_indent (cnt_editor);
+}
+
+static void
+emoji_chooser_emoji_picked_cb (EHTMLEditor *editor,
+			       const gchar *emoji_text)
+{
+	if (emoji_text) {
+		EContentEditor *cnt_editor;
+
+		cnt_editor = e_html_editor_get_content_editor (editor);
+
+		e_content_editor_insert_content (cnt_editor, emoji_text,
+			E_CONTENT_EDITOR_INSERT_CONVERT |
+			E_CONTENT_EDITOR_INSERT_TEXT_PLAIN);
+	}
+}
+
+static void
+action_insert_emoji_cb (GtkAction *action,
+			EHTMLEditor *editor)
+{
+	if (!editor->priv->emoji_chooser) {
+		GtkWidget *popover;
+
+		popover = e_gtk_emoji_chooser_new ();
+
+		gtk_popover_set_relative_to (GTK_POPOVER (popover), GTK_WIDGET (editor));
+		gtk_popover_set_position (GTK_POPOVER (popover), GTK_POS_BOTTOM);
+		gtk_popover_set_modal (GTK_POPOVER (popover), TRUE);
+
+		g_signal_connect_object (popover, "emoji-picked",
+			G_CALLBACK (emoji_chooser_emoji_picked_cb), editor, G_CONNECT_SWAPPED);
+
+		editor->priv->emoji_chooser = popover;
+	}
+
+	gtk_popover_popup (GTK_POPOVER (editor->priv->emoji_chooser));
+}
+
+static void
+action_insert_emoticon_cb (GtkAction *action,
+                           EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	EEmoticon *emoticon;
+
+	emoticon = e_emoticon_chooser_get_current_emoticon (E_EMOTICON_CHOOSER (action));
+	g_return_if_fail (emoticon != NULL);
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_emoticon (cnt_editor, emoticon);
+}
+
+static void
+action_insert_html_file_cb (GtkToggleAction *action,
+                            EHTMLEditor *editor)
+{
+	GtkFileChooserNative *native;
+	GtkFileFilter *filter;
+	GtkWidget *toplevel;
+
+	toplevel = gtk_widget_get_toplevel (GTK_WIDGET (editor));
+
+	native = gtk_file_chooser_native_new (
+		_("Insert HTML File"), GTK_IS_WINDOW (toplevel) ? GTK_WINDOW (toplevel) : NULL,
+		GTK_FILE_CHOOSER_ACTION_OPEN,
+		_("_Open"), _("_Cancel"));
+
+	filter = gtk_file_filter_new ();
+	gtk_file_filter_set_name (filter, _("HTML file"));
+	gtk_file_filter_add_mime_type (filter, "text/html");
+	gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (native), filter);
+
+	e_util_load_file_chooser_folder (GTK_FILE_CHOOSER (native));
+
+	if (gtk_native_dialog_run (GTK_NATIVE_DIALOG (native)) == GTK_RESPONSE_ACCEPT) {
+		GFile *file;
+
+		e_util_save_file_chooser_folder (GTK_FILE_CHOOSER (native));
+		file = gtk_file_chooser_get_file (GTK_FILE_CHOOSER (native));
+
+		/* XXX Need a way to cancel this. */
+		g_file_load_contents_async (
+			file, NULL, (GAsyncReadyCallback)
+			insert_html_file_ready_cb,
+			g_object_ref (editor));
+
+		g_object_unref (file);
+	}
+
+	g_object_unref (native);
+}
+
+static void
+action_insert_image_cb (GtkAction *action,
+                        EHTMLEditor *editor)
+{
+	GtkWidget *dialog = NULL;
+	GtkFileChooserNative *native = NULL;
+	GtkWidget *toplevel;
+	gint response;
+
+	toplevel = gtk_widget_get_toplevel (GTK_WIDGET (editor));
+	if (e_util_is_running_flatpak ()) {
+		GtkFileFilter *file_filter;
+
+		native = gtk_file_chooser_native_new (
+			C_("dialog-title", "Insert Image"),
+			GTK_IS_WINDOW (toplevel) ? GTK_WINDOW (toplevel) : NULL,
+			GTK_FILE_CHOOSER_ACTION_OPEN,
+			_("_Open"), _("_Cancel"));
+
+		file_filter = gtk_file_filter_new ();
+		gtk_file_filter_add_pixbuf_formats (file_filter);
+		gtk_file_filter_set_name (file_filter, _("Image files"));
+		gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (native), file_filter);
+		gtk_file_chooser_set_filter (GTK_FILE_CHOOSER (native), file_filter);
+
+		file_filter = gtk_file_filter_new ();
+		gtk_file_filter_set_name (file_filter, _("All files"));
+		gtk_file_filter_add_pattern (file_filter, "*");
+		gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (native), file_filter);
+	} else {
+		GSList *filters, *link;
+
+		dialog = e_image_chooser_dialog_new (C_("dialog-title", "Insert Image"), GTK_IS_WINDOW (toplevel) ? GTK_WINDOW (toplevel) : NULL);
+
+		filters = gtk_file_chooser_list_filters (GTK_FILE_CHOOSER (dialog));
+
+		for (link = filters; link; link = g_slist_next (link)) {
+			GtkFileFilter *file_filter = link->data;
+
+			if (g_strcmp0 (gtk_file_filter_get_name (file_filter), _("Image files")) == 0) {
+				gtk_file_filter_add_mime_type (file_filter, "image/*");
+				break;
+			}
+		}
+
+		g_slist_free (filters);
+	}
+
+	if (dialog)
+		response = gtk_dialog_run (GTK_DIALOG (dialog));
+	else
+		response = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
+
+	if (response == GTK_RESPONSE_ACCEPT) {
+		EContentEditor *cnt_editor;
+		gchar *uri;
+
+		if (dialog)
+			uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (dialog));
+		else
+			uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (native));
+
+		cnt_editor = e_html_editor_get_content_editor (editor);
+		e_content_editor_insert_image (cnt_editor, uri);
+
+		g_free (uri);
+	}
+
+	if (dialog)
+		gtk_widget_destroy (dialog);
+	else
+		g_object_unref (native);
+}
+
+static void
+action_insert_link_cb (GtkAction *action,
+                       EHTMLEditor *editor)
+{
+	if (editor->priv->link_dialog == NULL)
+		editor->priv->link_dialog =
+			e_html_editor_link_dialog_new (editor);
+
+	gtk_window_present (GTK_WINDOW (editor->priv->link_dialog));
+}
+
+static void
+action_insert_rule_cb (GtkAction *action,
+                       EHTMLEditor *editor)
+{
+	if (editor->priv->hrule_dialog == NULL)
+		editor->priv->hrule_dialog =
+			e_html_editor_hrule_dialog_new (editor);
+
+	gtk_window_present (GTK_WINDOW (editor->priv->hrule_dialog));
+}
+
+static void
+action_insert_table_cb (GtkAction *action,
+                        EHTMLEditor *editor)
+{
+	if (editor->priv->table_dialog == NULL)
+		editor->priv->table_dialog =
+			e_html_editor_table_dialog_new (editor);
+
+	gtk_window_present (GTK_WINDOW (editor->priv->table_dialog));
+}
+
+static void
+action_insert_text_file_cb (GtkAction *action,
+                            EHTMLEditor *editor)
+{
+	GtkFileChooserNative *native;
+	GtkWidget *toplevel;
+	GtkFileFilter *filter;
+
+	toplevel = gtk_widget_get_toplevel (GTK_WIDGET (editor));
+
+	native = gtk_file_chooser_native_new (
+		_("Insert text file"), GTK_IS_WINDOW (toplevel) ? GTK_WINDOW (toplevel) : NULL,
+		GTK_FILE_CHOOSER_ACTION_OPEN,
+		_("_Open"), _("_Cancel"));
+
+	filter = gtk_file_filter_new ();
+	gtk_file_filter_set_name (filter, _("Text file"));
+	gtk_file_filter_add_mime_type (filter, "text/plain");
+	gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (native), filter);
+
+	e_util_load_file_chooser_folder (GTK_FILE_CHOOSER (native));
+
+	if (gtk_native_dialog_run (GTK_NATIVE_DIALOG (native)) == GTK_RESPONSE_ACCEPT) {
+		GFile *file;
+
+		e_util_save_file_chooser_folder (GTK_FILE_CHOOSER (native));
+		file = gtk_file_chooser_get_file (GTK_FILE_CHOOSER (native));
+
+		/* XXX Need a way to cancel this. */
+		g_file_load_contents_async (
+			file, NULL, (GAsyncReadyCallback)
+			insert_text_file_ready_cb,
+			g_object_ref (editor));
+
+		g_object_unref (file);
+	}
+
+	g_object_unref (native);
+}
+
+static gboolean
+editor_actions_add_to_recent_languages (EHTMLEditor *editor,
+					const gchar *language_code);
+
+static void
+action_language_cb (GtkToggleAction *toggle_action,
+                    EHTMLEditor *editor)
+{
+	ESpellChecker *spell_checker;
+	EContentEditor *cnt_editor;
+	const gchar *language_code;
+	GtkAction *add_action;
+	gchar *action_name;
+	gboolean active;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	spell_checker = e_content_editor_ref_spell_checker (cnt_editor);
+	language_code = gtk_action_get_name (GTK_ACTION (toggle_action));
+
+	active = gtk_toggle_action_get_active (toggle_action);
+	e_spell_checker_set_language_active (spell_checker, language_code, active);
+	g_clear_object (&spell_checker);
+
+	/* Update "Add Word To" context menu item visibility. */
+	action_name = g_strdup_printf ("context-spell-add-%s", language_code);
+	add_action = e_html_editor_get_action (editor, action_name);
+	gtk_action_set_visible (add_action, active);
+	g_free (action_name);
+
+	e_html_editor_update_spell_actions (editor);
+
+	g_signal_emit_by_name (editor, "spell-languages-changed");
+
+	if (active) {
+		GSettings *settings;
+		GPtrArray *array;
+		gchar **strv;
+		gint ii, max_items;
+
+		gtk_ui_manager_remove_ui (editor->priv->manager, editor->priv->recent_spell_languages_merge_id);
+
+		settings = e_util_ref_settings ("org.gnome.evolution.mail");
+		strv = g_settings_get_strv (settings, "composer-spell-languages-recently-used");
+		max_items = g_settings_get_int (settings, "composer-spell-languages-max-recently-used");
+		if (max_items < 5)
+			max_items = 5;
+
+		array = g_ptr_array_sized_new (max_items + 1);
+		g_ptr_array_add (array, (gpointer) language_code);
+
+		editor_actions_add_to_recent_languages (editor, language_code);
+
+		for (ii = 0; strv && strv[ii] && array->len < max_items; ii++) {
+			if (g_strcmp0 (language_code, strv[ii]) != 0) {
+				g_ptr_array_add (array, strv[ii]);
+				editor_actions_add_to_recent_languages (editor, strv[ii]);
+			}
+		}
+
+		g_ptr_array_add (array, NULL);
+
+		g_settings_set_strv (settings, "composer-spell-languages-recently-used", (const gchar * const *) array->pdata);
+
+		g_object_unref (settings);
+		g_ptr_array_free (array, TRUE);
+		g_strfreev (strv);
+	}
+}
+
+static gboolean
+update_mode_combobox (gpointer data)
+{
+	GWeakRef *weak_ref = data;
+	EHTMLEditor *editor;
+	EContentEditor *cnt_editor;
+	GtkAction *action;
+	gboolean is_html;
+
+	editor = g_weak_ref_get (weak_ref);
+	if (!editor)
+		return FALSE;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	is_html = e_content_editor_get_html_mode (cnt_editor);
+
+	action = gtk_action_group_get_action (
+		editor->priv->core_editor_actions, "mode-html");
+	gtk_radio_action_set_current_value (
+		GTK_RADIO_ACTION (action), (is_html ? 1 : 0));
+
+	g_object_unref (editor);
+
+	return FALSE;
+}
+
+static void
+html_editor_actions_notify_html_mode_cb (EContentEditor *cnt_editor,
+					 GParamSpec *param,
+					 EHTMLEditor *editor)
+{
+	GtkActionGroup *action_group;
+	GtkWidget *style_combo_box;
+	gboolean is_html;
+
+	g_return_if_fail (E_IS_CONTENT_EDITOR (cnt_editor));
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	is_html = e_content_editor_get_html_mode (cnt_editor);
+
+	g_object_set (G_OBJECT (editor->priv->html_actions), "sensitive", is_html, NULL);
+
+	/* This must be done from idle callback, because apparently we can change
+	 * current value in callback of current value change */
+	g_idle_add_full (G_PRIORITY_HIGH_IDLE, update_mode_combobox, e_weak_ref_new (editor), (GDestroyNotify) e_weak_ref_free);
+
+	action_group = editor->priv->html_actions;
+	gtk_action_group_set_visible (action_group, is_html);
+
+	action_group = editor->priv->html_context_actions;
+	gtk_action_group_set_visible (action_group, is_html);
+
+	gtk_widget_set_sensitive (editor->priv->fg_color_combo_box, is_html);
+	gtk_widget_set_sensitive (editor->priv->bg_color_combo_box, is_html);
+
+	if (is_html) {
+		gtk_widget_show (editor->priv->html_toolbar);
+	} else {
+		gtk_widget_hide (editor->priv->html_toolbar);
+	}
+
+	/* Certain paragraph styles are HTML-only. */
+	gtk_action_set_sensitive (ACTION (STYLE_H1), is_html);
+	gtk_action_set_visible (ACTION (STYLE_H1), is_html);
+	gtk_action_set_sensitive (ACTION (STYLE_H2), is_html);
+	gtk_action_set_visible (ACTION (STYLE_H2), is_html);
+	gtk_action_set_sensitive (ACTION (STYLE_H3), is_html);
+	gtk_action_set_visible (ACTION (STYLE_H3), is_html);
+	gtk_action_set_sensitive (ACTION (STYLE_H4), is_html);
+	gtk_action_set_visible (ACTION (STYLE_H4), is_html);
+	gtk_action_set_sensitive (ACTION (STYLE_H5), is_html);
+	gtk_action_set_visible (ACTION (STYLE_H5), is_html);
+	gtk_action_set_sensitive (ACTION (STYLE_H6), is_html);
+	gtk_action_set_visible (ACTION (STYLE_H6), is_html);
+	gtk_action_set_sensitive (ACTION (STYLE_ADDRESS), is_html);
+	gtk_action_set_visible (ACTION (STYLE_ADDRESS), is_html);
+
+	/* Hide them from the action combo box as well */
+	style_combo_box = e_html_editor_get_style_combo_box (editor);
+	e_action_combo_box_update_model (E_ACTION_COMBO_BOX (style_combo_box));
+}
+
+static void
+action_mode_cb (GtkRadioAction *action,
+		GtkRadioAction *current,
+		EHTMLEditor *editor)
+{
+	/* Nothing to do here, wait for notification of
+	   a property change from the EContentEditor */
+}
+
+static void
+clipboard_text_received_for_paste_as_text (GtkClipboard *clipboard,
+                                           const gchar *text,
+                                           EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	if (!text || !*text)
+		return;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_content (
+		cnt_editor,
+		text,
+		E_CONTENT_EDITOR_INSERT_CONVERT |
+		E_CONTENT_EDITOR_INSERT_TEXT_PLAIN |
+		(editor->priv->paste_plain_prefer_pre ? E_CONTENT_EDITOR_INSERT_CONVERT_PREFER_PRE : 0));
+}
+
+static void
+action_paste_as_text_cb (GtkAction *action,
+                         EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	GtkClipboard *clipboard;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (!gtk_widget_has_focus (GTK_WIDGET (cnt_editor)))
+		gtk_widget_grab_focus (GTK_WIDGET (cnt_editor));
+
+	clipboard = gtk_clipboard_get_for_display (
+		gdk_display_get_default (),
+		GDK_SELECTION_CLIPBOARD);
+
+	gtk_clipboard_request_text (
+		clipboard,
+		(GtkClipboardTextReceivedFunc) clipboard_text_received_for_paste_as_text,
+		editor);
+}
+
+static void
+paste_quote_text (EHTMLEditor *editor,
+		  const gchar *text,
+		  gboolean is_html)
+{
+	EContentEditor *cnt_editor;
+
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+	g_return_if_fail (text != NULL);
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	e_content_editor_insert_content (
+		cnt_editor,
+		text,
+		E_CONTENT_EDITOR_INSERT_QUOTE_CONTENT |
+		(is_html ? E_CONTENT_EDITOR_INSERT_TEXT_HTML : E_CONTENT_EDITOR_INSERT_TEXT_PLAIN) |
+		((!is_html && editor->priv->paste_plain_prefer_pre) ? E_CONTENT_EDITOR_INSERT_CONVERT_PREFER_PRE : 0));
+}
+
+static void
+clipboard_html_received_for_paste_quote (GtkClipboard *clipboard,
+                                         const gchar *text,
+                                         gpointer user_data)
+{
+	EHTMLEditor *editor = user_data;
+
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+	g_return_if_fail (text != NULL);
+
+	paste_quote_text (editor, text, TRUE);
+}
+
+static void
+clipboard_text_received_for_paste_quote (GtkClipboard *clipboard,
+                                         const gchar *text,
+                                         gpointer user_data)
+{
+	EHTMLEditor *editor = user_data;
+
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+	g_return_if_fail (text != NULL);
+
+	paste_quote_text (editor, text, FALSE);
+}
+
+static void
+action_paste_quote_cb (GtkAction *action,
+                       EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	GtkClipboard *clipboard;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (!gtk_widget_has_focus (GTK_WIDGET (cnt_editor)))
+		gtk_widget_grab_focus (GTK_WIDGET (cnt_editor));
+
+	clipboard = gtk_clipboard_get_for_display (
+		gdk_display_get_default (),
+		GDK_SELECTION_CLIPBOARD);
+
+	if (e_content_editor_get_html_mode (cnt_editor)) {
+		if (e_clipboard_wait_is_html_available (clipboard))
+			e_clipboard_request_html (clipboard, clipboard_html_received_for_paste_quote, editor);
+		else if (gtk_clipboard_wait_is_text_available (clipboard))
+			gtk_clipboard_request_text (clipboard, clipboard_text_received_for_paste_quote, editor);
+	} else {
+		if (gtk_clipboard_wait_is_text_available (clipboard))
+			gtk_clipboard_request_text (clipboard, clipboard_text_received_for_paste_quote, editor);
+		else if (e_clipboard_wait_is_html_available (clipboard))
+			e_clipboard_request_html (clipboard, clipboard_html_received_for_paste_quote, editor);
+	}
+}
+
+static void
+action_properties_cell_cb (GtkAction *action,
+                           EHTMLEditor *editor)
+{
+	if (editor->priv->cell_dialog == NULL) {
+		editor->priv->cell_dialog =
+			e_html_editor_cell_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->cell_dialog));
+}
+
+static void
+action_properties_image_cb (GtkAction *action,
+                            EHTMLEditor *editor)
+{
+	if (editor->priv->image_dialog == NULL) {
+		editor->priv->image_dialog =
+			e_html_editor_image_dialog_new (editor);
+	}
+
+	e_html_editor_image_dialog_show (
+		E_HTML_EDITOR_IMAGE_DIALOG (editor->priv->image_dialog));
+}
+
+static void
+action_properties_link_cb (GtkAction *action,
+                           EHTMLEditor *editor)
+{
+	if (editor->priv->link_dialog == NULL) {
+		editor->priv->link_dialog =
+			e_html_editor_link_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->link_dialog));
+}
+
+static void
+action_properties_page_cb (GtkAction *action,
+                           EHTMLEditor *editor)
+{
+	if (editor->priv->page_dialog == NULL) {
+		editor->priv->page_dialog =
+			e_html_editor_page_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->page_dialog));
+}
+
+static void
+action_properties_paragraph_cb (GtkAction *action,
+                                EHTMLEditor *editor)
+{
+	if (editor->priv->paragraph_dialog == NULL) {
+		editor->priv->paragraph_dialog =
+			e_html_editor_paragraph_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->paragraph_dialog));
+}
+
+static void
+action_properties_rule_cb (GtkAction *action,
+                           EHTMLEditor *editor)
+{
+	if (editor->priv->hrule_dialog == NULL) {
+		editor->priv->hrule_dialog =
+			e_html_editor_hrule_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->hrule_dialog));
+}
+
+static void
+action_properties_table_cb (GtkAction *action,
+                            EHTMLEditor *editor)
+{
+	if (editor->priv->table_dialog == NULL) {
+		editor->priv->table_dialog =
+			e_html_editor_table_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->table_dialog));
+}
+
+static void
+action_properties_text_cb (GtkAction *action,
+                           EHTMLEditor *editor)
+{
+	if (editor->priv->text_dialog == NULL) {
+		editor->priv->text_dialog =
+			e_html_editor_text_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->text_dialog));
+}
+
+static void
+action_redo_cb (GtkAction *action,
+                EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (e_html_editor_action_can_run (GTK_WIDGET (cnt_editor)))
+		e_content_editor_redo (cnt_editor);
+}
+
+static void
+action_show_find_cb (GtkAction *action,
+                     EHTMLEditor *editor)
+{
+	if (editor->priv->find_dialog == NULL) {
+		editor->priv->find_dialog = e_html_editor_find_dialog_new (editor);
+		gtk_action_set_sensitive (ACTION (FIND_AGAIN), TRUE);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->find_dialog));
+}
+
+static void
+action_find_again_cb (GtkAction *action,
+                      EHTMLEditor *editor)
+{
+	if (editor->priv->find_dialog == NULL)
+		return;
+
+	e_html_editor_find_dialog_find_next (
+		E_HTML_EDITOR_FIND_DIALOG (editor->priv->find_dialog));
+}
+
+static void
+action_show_replace_cb (GtkAction *action,
+                        EHTMLEditor *editor)
+{
+	if (editor->priv->replace_dialog == NULL) {
+		editor->priv->replace_dialog =
+			e_html_editor_replace_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->replace_dialog));
+}
+
+static void
+action_spell_check_cb (GtkAction *action,
+                       EHTMLEditor *editor)
+{
+	if (editor->priv->spell_check_dialog == NULL) {
+		editor->priv->spell_check_dialog =
+			e_html_editor_spell_check_dialog_new (editor);
+	}
+
+	gtk_window_present (GTK_WINDOW (editor->priv->spell_check_dialog));
+}
+
+static void
+action_undo_cb (GtkAction *action,
+                EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (e_html_editor_action_can_run (GTK_WIDGET (cnt_editor))) {
+		e_content_editor_undo (cnt_editor);
+	}
+}
+
+static void
+action_unindent_cb (GtkAction *action,
+                    EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (e_html_editor_action_can_run (GTK_WIDGET (cnt_editor)))
+		e_content_editor_selection_unindent (cnt_editor);
+}
+
+static void
+action_wrap_lines_cb (GtkAction *action,
+                      EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	if (e_html_editor_action_can_run (GTK_WIDGET (cnt_editor)))
+		e_content_editor_selection_wrap (cnt_editor);
+}
+
+/* This is when the user toggled the action */
+static void
+manage_format_subsuperscript_toggled (EHTMLEditor *editor,
+				      GtkToggleAction *changed_action,
+				      const gchar *prop_name,
+				      GtkToggleAction *second_action)
+{
+	EContentEditor *cnt_editor = e_html_editor_get_content_editor (editor);
+
+	g_signal_handlers_block_matched (cnt_editor, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_block_matched (changed_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_block_matched (second_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+
+	if (gtk_toggle_action_get_active (changed_action) &&
+	    gtk_toggle_action_get_active (second_action))
+		gtk_toggle_action_set_active (second_action, FALSE);
+
+	g_object_set (G_OBJECT (cnt_editor), prop_name, gtk_toggle_action_get_active (changed_action), NULL);
+
+	g_signal_handlers_unblock_matched (second_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_unblock_matched (changed_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_unblock_matched (cnt_editor, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+}
+
+/* This is when the content editor claimed change on the property */
+static void
+manage_format_subsuperscript_notify (EHTMLEditor *editor,
+				     GtkToggleAction *changed_action,
+				     const gchar *prop_name,
+				     GtkToggleAction *second_action)
+{
+	EContentEditor *cnt_editor = e_html_editor_get_content_editor (editor);
+	gboolean value = FALSE;
+
+	g_signal_handlers_block_matched (cnt_editor, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_block_matched (changed_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_block_matched (second_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+
+	g_object_get (G_OBJECT (cnt_editor), prop_name, &value, NULL);
+
+	gtk_toggle_action_set_active (changed_action, value);
+
+	if (gtk_toggle_action_get_active (changed_action) &&
+	    gtk_toggle_action_get_active (second_action))
+		gtk_toggle_action_set_active (second_action, FALSE);
+
+	g_signal_handlers_unblock_matched (second_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_unblock_matched (changed_action, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+	g_signal_handlers_unblock_matched (cnt_editor, G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, editor);
+}
+
+static void
+html_editor_actions_subscript_toggled_cb (GtkToggleAction *action,
+					  EHTMLEditor *editor)
+{
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	manage_format_subsuperscript_toggled (editor, GTK_TOGGLE_ACTION (ACTION (SUBSCRIPT)), "subscript", GTK_TOGGLE_ACTION (ACTION (SUPERSCRIPT)));
+}
+
+static void
+html_editor_actions_notify_subscript_cb (EContentEditor *cnt_editor,
+					 GParamSpec *param,
+					 EHTMLEditor *editor)
+{
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	manage_format_subsuperscript_notify (editor, GTK_TOGGLE_ACTION (ACTION (SUBSCRIPT)), "subscript", GTK_TOGGLE_ACTION (ACTION (SUPERSCRIPT)));
+}
+
+static void
+html_editor_actions_superscript_toggled_cb (GtkToggleAction *action,
+					    EHTMLEditor *editor)
+{
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	manage_format_subsuperscript_toggled (editor, GTK_TOGGLE_ACTION (ACTION (SUPERSCRIPT)), "superscript", GTK_TOGGLE_ACTION (ACTION (SUBSCRIPT)));
+}
+
+static void
+html_editor_actions_notify_superscript_cb (EContentEditor *cnt_editor,
+					   GParamSpec *param,
+					   EHTMLEditor *editor)
+{
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	manage_format_subsuperscript_notify (editor, GTK_TOGGLE_ACTION (ACTION (SUPERSCRIPT)), "superscript", GTK_TOGGLE_ACTION (ACTION (SUBSCRIPT)));
+}
+
+
+/*****************************************************************************
+ * Core Actions
+ *
+ * These actions are always enabled.
+ *****************************************************************************/
+
+static GtkActionEntry core_entries[] = {
+
+	{ "copy",
+	  "edit-copy",
+	  N_("_Copy"),
+	  "<Control>c",
+	  N_("Copy selected text to the clipboard"),
+	  NULL }, /* Handled by focus tracker */
+
+	{ "cut",
+	  "edit-cut",
+	  N_("Cu_t"),
+	  "<Control>x",
+	  N_("Cut selected text to the clipboard"),
+	  NULL }, /* Handled by focus tracker */
+
+	{ "paste",
+	  "edit-paste",
+	  N_("_Paste"),
+	  "<Control>v",
+	  N_("Paste text from the clipboard"),
+	  NULL }, /* Handled by focus tracker */
+
+	{ "redo",
+	  "edit-redo",
+	  N_("_Redo"),
+	  "<Shift><Control>z",
+	  N_("Redo the last undone action"),
+	  G_CALLBACK (action_redo_cb) },
+
+	{ "select-all",
+	  "edit-select-all",
+	  N_("Select _All"),
+	  "<Control>a",
+	  NULL,
+	  NULL }, /* Handled by focus tracker */
+
+	{ "undo",
+	  "edit-undo",
+	  N_("_Undo"),
+	  "<Control>z",
+	  N_("Undo the last action"),
+	  G_CALLBACK (action_undo_cb) },
+
+	/* Menus */
+
+	{ "edit-menu",
+	  NULL,
+	  N_("_Edit"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "file-menu",
+	  NULL,
+	  N_("_File"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "format-menu",
+	  NULL,
+	  N_("For_mat"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "paragraph-style-menu",
+	  NULL,
+	  N_("_Paragraph Style"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "insert-menu",
+	  NULL,
+	  N_("_Insert"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "justify-menu",
+	  NULL,
+	  N_("_Alignment"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "language-menu",
+	  NULL,
+	  N_("Current _Languages"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "view-menu",
+	  NULL,
+	  N_("_View"),
+	  NULL,
+	  NULL,
+	  NULL }
+};
+
+static GtkActionEntry core_editor_entries[] = {
+
+	{ "indent",
+	  "format-indent-more",
+	  N_("_Increase Indent"),
+	  "<Control>bracketright",
+	  N_("Increase Indent"),
+	  G_CALLBACK (action_indent_cb) },
+
+	{ "insert-emoji",
+	  NULL,
+	  N_("E_moji"),
+	  NULL,
+	  N_("Insert Emoji"),
+	  G_CALLBACK (action_insert_emoji_cb) },
+
+	{ "insert-emoji-toolbar",
+	  "face-smile",
+	  N_("Insert E_moji"),
+	  NULL,
+	  N_("Insert Emoji"),
+	  G_CALLBACK (action_insert_emoji_cb) },
+
+	{ "insert-html-file",
+	  NULL,
+	  N_("_HTML File…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_insert_html_file_cb) },
+
+	{ "insert-text-file",
+	  NULL,
+	  N_("Te_xt File…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_insert_text_file_cb) },
+
+	{ "paste-quote",
+	  NULL,
+	  N_("Paste _Quotation"),
+	  "<Control><Alt>v",
+	  NULL,
+	  G_CALLBACK (action_paste_quote_cb) },
+
+	{ "show-find",
+	  "edit-find",
+	  N_("_Find…"),
+	  "<Control>f",
+	  N_("Search for text"),
+	  G_CALLBACK (action_show_find_cb) },
+
+	{ "find-again",
+	  NULL,
+	  N_("Find A_gain"),
+	  "<Control>g",
+	  NULL,
+	  G_CALLBACK (action_find_again_cb) },
+
+	{ "show-replace",
+	  "edit-find-replace",
+	  N_("Re_place…"),
+	  "<Control>h",
+	  N_("Search for and replace text"),
+	  G_CALLBACK (action_show_replace_cb) },
+
+	{ "spell-check",
+	  "tools-check-spelling",
+	  N_("Check _Spelling…"),
+	  "F7",
+	  NULL,
+	  G_CALLBACK (action_spell_check_cb) },
+
+	{ "unindent",
+	  "format-indent-less",
+	  N_("_Decrease Indent"),
+	  "<Control>bracketleft",
+	  N_("Decrease Indent"),
+	  G_CALLBACK (action_unindent_cb) },
+
+	{ "wrap-lines",
+	  NULL,
+	  N_("_Wrap Lines"),
+	  "<Control><Shift>k",
+	  NULL,
+	  G_CALLBACK (action_wrap_lines_cb) }
+};
+
+static GtkRadioActionEntry core_justify_entries[] = {
+
+	{ "justify-center",
+	  "format-justify-center",
+	  N_("_Center"),
+	  "<Control>e",
+	  N_("Center Alignment"),
+	  E_CONTENT_EDITOR_ALIGNMENT_CENTER },
+
+	{ "justify-fill",
+	  "format-justify-fill",
+	  N_("_Justified"),
+	  "<Control>j",
+	  N_("Align Justified"),
+	  E_CONTENT_EDITOR_ALIGNMENT_JUSTIFY },
+
+	{ "justify-left",
+	  "format-justify-left",
+	  N_("_Left"),
+	  "<Control>l",
+	  N_("Left Alignment"),
+	  E_CONTENT_EDITOR_ALIGNMENT_LEFT },
+
+	{ "justify-right",
+	  "format-justify-right",
+	  N_("_Right"),
+	  "<Control>r",
+	  N_("Right Alignment"),
+	  E_CONTENT_EDITOR_ALIGNMENT_RIGHT }
+};
+
+static GtkRadioActionEntry core_mode_entries[] = {
+
+	{ "mode-html",
+	  NULL,
+	  N_("_HTML"),
+	  NULL,
+	  N_("HTML editing mode"),
+	  TRUE },	/* e_content_editor_set_html_mode */
+
+	{ "mode-plain",
+	  NULL,
+	  N_("Plain _Text"),
+	  NULL,
+	  N_("Plain text editing mode"),
+	  FALSE }	/* e_content_editor_set_html_mode */
+};
+
+static GtkRadioActionEntry core_style_entries[] = {
+
+	{ "style-normal",
+	  NULL,
+	  N_("_Normal"),
+	  "<Control>0",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_PARAGRAPH },
+
+	{ "style-h1",
+	  NULL,
+	  N_("Heading _1"),
+	  "<Control>1",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_H1 },
+
+	{ "style-h2",
+	  NULL,
+	  N_("Heading _2"),
+	  "<Control>2",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_H2 },
+
+	{ "style-h3",
+	  NULL,
+	  N_("Heading _3"),
+	  "<Control>3",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_H3 },
+
+	{ "style-h4",
+	  NULL,
+	  N_("Heading _4"),
+	  "<Control>4",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_H4 },
+
+	{ "style-h5",
+	  NULL,
+	  N_("Heading _5"),
+	  "<Control>5",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_H5 },
+
+	{ "style-h6",
+	  NULL,
+	  N_("Heading _6"),
+	  "<Control>6",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_H6 },
+
+        { "style-preformat",
+          NULL,
+          N_("_Preformatted"),
+          "<Control>7",
+          NULL,
+          E_CONTENT_EDITOR_BLOCK_FORMAT_PRE },
+
+	{ "style-address",
+	  NULL,
+	  N_("A_ddress"),
+	  "<Control>8",
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_ADDRESS },
+
+	{ "style-list-bullet",
+	  NULL,
+	  N_("_Bulleted List"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_UNORDERED_LIST },
+
+	{ "style-list-roman",
+	  NULL,
+	  N_("_Roman Numeral List"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_ORDERED_LIST_ROMAN },
+
+	{ "style-list-number",
+	  NULL,
+	  N_("Numbered _List"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_ORDERED_LIST },
+
+	{ "style-list-alpha",
+	  NULL,
+	  N_("_Alphabetical List"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_BLOCK_FORMAT_ORDERED_LIST_ALPHA }
+};
+
+/*****************************************************************************
+ * Core Actions (HTML only)
+ *
+ * These actions are only enabled in HTML mode.
+ *****************************************************************************/
+
+static GtkActionEntry html_entries[] = {
+
+	{ "insert-image",
+	  "insert-image",
+	  N_("_Image…"),
+	  NULL,
+	  /* Translators: This is an action tooltip */
+	  N_("Insert Image"),
+	  G_CALLBACK (action_insert_image_cb) },
+
+	{ "insert-link",
+	  "insert-link",
+	  N_("_Link…"),
+	  "<Control>k",
+	  N_("Insert Link"),
+	  G_CALLBACK (action_insert_link_cb) },
+
+	{ "insert-rule",
+	  "stock_insert-rule",
+	  /* Translators: 'Rule' here means a horizontal line in an HTML text */
+	  N_("_Rule…"),
+	  NULL,
+	  /* Translators: 'Rule' here means a horizontal line in an HTML text */
+	  N_("Insert Rule"),
+	  G_CALLBACK (action_insert_rule_cb) },
+
+	{ "insert-table",
+	  "stock_insert-table",
+	  N_("_Table…"),
+	  NULL,
+	  N_("Insert Table"),
+	  G_CALLBACK (action_insert_table_cb) },
+
+	{ "properties-cell",
+	  NULL,
+	  N_("_Cell…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_cell_cb) },
+
+	{ "properties-image",
+	  NULL,
+	  N_("_Image…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_image_cb) },
+
+	{ "properties-link",
+	  NULL,
+	  N_("_Link…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_link_cb) },
+
+	{ "properties-page",
+	  NULL,
+	  N_("Pa_ge…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_page_cb) },
+
+	{ "properties-rule",
+	  NULL,
+	  /* Translators: 'Rule' here means a horizontal line in an HTML text */
+	  N_("_Rule…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_rule_cb) },
+
+	{ "properties-table",
+	  NULL,
+	  N_("_Table…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_table_cb) },
+
+	/* Menus */
+
+	{ "font-size-menu",
+	  NULL,
+	  N_("Font _Size"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "font-style-menu",
+	  NULL,
+	  N_("_Font Style"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "paste-as-text",
+	  NULL,
+	  N_("Paste As _Text"),
+	  "<Shift><Control>v",
+	  NULL,
+	  G_CALLBACK (action_paste_as_text_cb) },
+
+};
+
+static GtkToggleActionEntry html_toggle_entries[] = {
+
+	{ "bold",
+	  "format-text-bold",
+	  N_("_Bold"),
+	  "<Control>b",
+	  N_("Bold"),
+	  NULL,
+	  FALSE },
+
+	{ "italic",
+	  "format-text-italic",
+	  N_("_Italic"),
+	  "<Control>i",
+	  N_("Italic"),
+	  NULL,
+	  FALSE },
+
+	{ "strikethrough",
+	  "format-text-strikethrough",
+	  N_("_Strikethrough"),
+	  NULL,
+	  N_("Strikethrough"),
+	  NULL,
+	  FALSE },
+
+	{ "subscript",
+	  NULL,
+	  N_("Subs_cript"),
+	  "<Control><Shift>b",
+	  N_("Subscript"),
+	  NULL,
+	  FALSE },
+
+	{ "superscript",
+	  NULL,
+	  N_("Su_perscript"),
+	  "<Control><Shift>p",
+	  N_("Superscript"),
+	  NULL,
+	  FALSE },
+
+	{ "underline",
+	  "format-text-underline",
+	  N_("_Underline"),
+	  "<Control>u",
+	  N_("Underline"),
+	  NULL,
+	  FALSE }
+};
+
+static GtkRadioActionEntry html_size_entries[] = {
+
+	{ "size-minus-two",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("-2"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_TINY },
+
+	{ "size-minus-one",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("-1"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_SMALL },
+
+	{ "size-plus-zero",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("+0"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_NORMAL },
+
+	{ "size-plus-one",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("+1"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_BIG },
+
+	{ "size-plus-two",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("+2"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_BIGGER },
+
+	{ "size-plus-three",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("+3"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_LARGE },
+
+	{ "size-plus-four",
+	  NULL,
+	  /* Translators: This is a font size level. It is shown on a tool bar. Please keep it as short as possible. */
+	  N_("+4"),
+	  NULL,
+	  NULL,
+	  E_CONTENT_EDITOR_FONT_SIZE_VERY_LARGE }
+};
+
+/*****************************************************************************
+ * Context Menu Actions
+ *
+ * These require separate action entries so we can toggle their visiblity
+ * rather than their sensitivity as we do with main menu / toolbar actions.
+ * Note that some of these actions use the same callback function as their
+ * non-context sensitive counterparts.
+ *****************************************************************************/
+
+static GtkActionEntry context_entries[] = {
+
+	{ "context-delete-cell",
+	  NULL,
+	  N_("Cell Contents"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_delete_cell_contents_cb) },
+
+	{ "context-delete-column",
+	  NULL,
+	  N_("Column"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_delete_column_cb) },
+
+	{ "context-delete-row",
+	  NULL,
+	  N_("Row"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_delete_row_cb) },
+
+	{ "context-delete-table",
+	  NULL,
+	  N_("Table"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_delete_table_cb) },
+
+	/* Menus */
+
+	{ "context-delete-table-menu",
+	  NULL,
+	  /* Translators: Popup menu item caption, containing all the Delete options for a table */
+	  N_("Table Delete"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "context-insert-table-menu",
+	  NULL,
+	  /* Translators: Popup menu item caption, containing all the Insert options for a table */
+	  N_("Table Insert"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "context-properties-menu",
+	  NULL,
+	  N_("Properties"),
+	  NULL,
+	  NULL,
+	  NULL },
+};
+
+/*****************************************************************************
+ * Context Menu Actions (HTML only)
+ *
+ * These actions are never visible in plain-text mode.  Note that some
+ * of them use the same callback function as their non-context sensitive
+ * counterparts.
+ *****************************************************************************/
+
+static GtkActionEntry html_context_entries[] = {
+
+	{ "context-delete-hrule",
+	  NULL,
+	  N_("Delete Rule"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_delete_hrule_cb) },
+
+	{ "context-delete-image",
+	  NULL,
+	  N_("Delete Image"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_delete_image_cb) },
+
+	{ "context-insert-column-after",
+	  NULL,
+	  N_("Column After"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_insert_column_after_cb) },
+
+	{ "context-insert-column-before",
+	  NULL,
+	  N_("Column Before"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_insert_column_before_cb) },
+
+	{ "context-insert-link",
+	  NULL,
+	  N_("Insert _Link"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_insert_link_cb) },
+
+	{ "context-insert-row-above",
+	  NULL,
+	  N_("Row Above"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_insert_row_above_cb) },
+
+	{ "context-insert-row-below",
+	  NULL,
+	  N_("Row Below"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_insert_row_below_cb) },
+
+	{ "context-properties-cell",
+	  NULL,
+	  N_("Cell…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_cell_cb) },
+
+	{ "context-properties-image",
+	  NULL,
+	  N_("Image…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_image_cb) },
+
+	{ "context-properties-link",
+	  NULL,
+	  N_("Link…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_link_cb) },
+
+	{ "context-properties-page",
+	  NULL,
+	  N_("Page…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_page_cb) },
+
+	{ "context-properties-paragraph",
+	  NULL,
+	  N_("Paragraph…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_paragraph_cb) },
+
+	{ "context-properties-rule",
+	  NULL,
+	  /* Translators: 'Rule' here means a horizontal line in an HTML text */
+	  N_("Rule…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_rule_cb) },
+
+	{ "context-properties-table",
+	  NULL,
+	  N_("Table…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_table_cb) },
+
+	{ "context-properties-text",
+	  NULL,
+	  N_("Text…"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_properties_text_cb) },
+
+	{ "context-remove-link",
+	  NULL,
+	  N_("Remove Link"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_remove_link_cb) }
+};
+
+/*****************************************************************************
+ * Context Menu Actions (spell checking only)
+ *
+ * These actions are only visible when the word underneath the cursor is
+ * misspelled.
+ *****************************************************************************/
+
+static GtkActionEntry spell_context_entries[] = {
+
+	{ "context-spell-add",
+	  NULL,
+	  N_("Add Word to Dictionary"),
+	  NULL,
+	  NULL,
+          G_CALLBACK (action_context_spell_add_cb) },
+
+	{ "context-spell-ignore",
+	  NULL,
+	  N_("Ignore Misspelled Word"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_context_spell_ignore_cb) },
+
+	{ "context-spell-add-menu",
+	  NULL,
+	  N_("Add Word To"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	/* Menus */
+
+	{ "context-more-suggestions-menu",
+	  NULL,
+	  N_("More Suggestions"),
+	  NULL,
+	  NULL,
+	  NULL }
+};
+
+static gboolean
+editor_actions_add_to_recent_languages (EHTMLEditor *editor,
+					const gchar *language_code)
+{
+	GtkAction *language_action;
+	gchar *name;
+
+	g_return_val_if_fail (E_IS_HTML_EDITOR (editor), FALSE);
+	g_return_val_if_fail (language_code != NULL, FALSE);
+
+	language_action = gtk_action_group_get_action (editor->priv->language_actions, language_code);
+	if (!language_action)
+		return FALSE;
+
+	name = g_strconcat ("recent-spell-language-", language_code, NULL);
+
+	if (!gtk_action_group_get_action (editor->priv->language_actions, name)) {
+		GtkToggleAction *toggle_action;
+
+		toggle_action = gtk_toggle_action_new (name,
+			gtk_action_get_label (language_action),
+			gtk_action_get_tooltip (language_action),
+			NULL);
+
+		e_binding_bind_property (language_action, "active",
+			toggle_action, "active",
+			G_BINDING_BIDIRECTIONAL | G_BINDING_SYNC_CREATE);
+
+		gtk_action_group_add_action (editor->priv->language_actions, GTK_ACTION (toggle_action));
+
+		g_object_unref (toggle_action);
+	}
+
+	gtk_ui_manager_add_ui (
+		editor->priv->manager, editor->priv->recent_spell_languages_merge_id,
+		"/main-menu/edit-menu/language-menu/recent-languages",
+		name, name, GTK_UI_MANAGER_AUTO, FALSE);
+
+	g_free (name);
+
+	return TRUE;
+}
+
+static void
+editor_actions_setup_languages_menu (EHTMLEditor *editor)
+{
+	ESpellChecker *spell_checker;
+	EContentEditor *cnt_editor;
+	GtkUIManager *manager;
+	GtkActionGroup *action_group;
+	GHashTable *lang_parents; /* gchar *name ~> GtkAction * */
+	GList *list = NULL, *link;
+	GSettings *settings;
+	gchar **strv;
+	gint ii, added = 0, max_items;
+	guint merge_id;
+
+	lang_parents = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
+	manager = editor->priv->manager;
+	action_group = editor->priv->language_actions;
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	spell_checker = e_content_editor_ref_spell_checker (cnt_editor);
+	merge_id = gtk_ui_manager_new_merge_id (manager);
+	editor->priv->recent_spell_languages_merge_id = gtk_ui_manager_new_merge_id (manager);
+
+	list = e_spell_checker_list_available_dicts (spell_checker);
+
+	for (link = list; link != NULL; link = g_list_next (link)) {
+		ESpellDictionary *dictionary = link->data;
+		GtkAction *parent_action;
+		GtkToggleAction *action;
+		const gchar *dictionay_name;
+		gchar *language_name, *path;
+		GString *escaped_name = NULL;
+		gboolean active = FALSE;
+
+		if (!e_util_get_language_info (e_spell_dictionary_get_code (dictionary), &language_name, NULL)) {
+			language_name = g_strdup (e_spell_dictionary_get_code (dictionary));
+			if (language_name) {
+				gchar *ptr;
+
+				ptr = strchr (language_name, '_');
+				if (ptr)
+					*ptr = '\0';
+			} else {
+				language_name = g_strdup ("");
+			}
+		}
+
+		dictionay_name = e_spell_dictionary_get_name (dictionary);
+		if (dictionay_name && strchr (dictionay_name, '_') != NULL)
+			escaped_name = e_str_replace_string (dictionay_name, "_", "__");
+
+		action = gtk_toggle_action_new (
+			e_spell_dictionary_get_code (dictionary),
+			escaped_name ? escaped_name->str : dictionay_name,
+			NULL, NULL);
+
+		if (escaped_name)
+			g_string_free (escaped_name, TRUE);
+
+		/* Do this BEFORE connecting to the "toggled" signal.
+		 * We're not prepared to invoke the signal handler yet.
+		 * The "Add Word To" actions have not yet been added. */
+		active = e_spell_checker_get_language_active (
+			spell_checker, e_spell_dictionary_get_code (dictionary));
+		gtk_toggle_action_set_active (action, active);
+
+		g_signal_connect (
+			action, "toggled",
+			G_CALLBACK (action_language_cb), editor);
+
+		gtk_action_group_add_action (
+			action_group, GTK_ACTION (action));
+
+		g_object_unref (action);
+
+		parent_action = g_hash_table_lookup (lang_parents, language_name);
+		if (!parent_action) {
+			gchar *name, *tmp;
+
+			name = g_strdup (e_spell_dictionary_get_code (dictionary));
+			tmp = strchr (name, '_');
+			if (tmp)
+				*tmp = '\0';
+
+			tmp = g_strconcat ("language-parent-", name, NULL);
+			g_free (name);
+			name = tmp;
+
+			parent_action = gtk_action_new (name, language_name, NULL, NULL);
+
+			gtk_action_group_add_action (action_group, parent_action);
+
+			g_hash_table_insert (lang_parents, g_strdup (language_name), parent_action);
+
+			gtk_ui_manager_add_ui (
+				manager, merge_id,
+				"/main-menu/edit-menu/language-menu/all-languages",
+				name, name, GTK_UI_MANAGER_MENU, FALSE);
+
+			g_free (name);
+		}
+
+		path = g_strconcat ("/main-menu/edit-menu/language-menu/all-languages/", gtk_action_get_name (parent_action), NULL);
+
+		gtk_ui_manager_add_ui (
+			manager, merge_id,
+			path,
+			e_spell_dictionary_get_code (dictionary),
+			e_spell_dictionary_get_code (dictionary),
+			GTK_UI_MANAGER_AUTO, FALSE);
+
+		g_free (language_name);
+		g_free (path);
+	}
+
+	g_list_free (list);
+	g_clear_object (&spell_checker);
+	g_hash_table_destroy (lang_parents);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+	strv = g_settings_get_strv (settings, "composer-spell-languages-recently-used");
+	max_items = g_settings_get_int (settings, "composer-spell-languages-max-recently-used");
+	if (max_items < 5)
+		max_items = 5;
+	g_object_unref (settings);
+
+	for (ii = 0; strv && strv[ii] && added < max_items; ii++) {
+		if (editor_actions_add_to_recent_languages (editor, strv[ii]))
+			added++;
+	}
+
+	g_strfreev (strv);
+}
+
+static void
+editor_actions_setup_spell_check_menu (EHTMLEditor *editor)
+{
+	EContentEditor *cnt_editor;
+	ESpellChecker *spell_checker;
+	GtkUIManager *manager;
+	GtkActionGroup *action_group;
+	GList *available_dicts = NULL, *iter;
+	guint merge_id;
+
+	manager = editor->priv->manager;
+	action_group = editor->priv->spell_check_actions;;
+	cnt_editor = e_html_editor_get_content_editor (editor);
+	spell_checker = e_content_editor_ref_spell_checker (cnt_editor);
+	available_dicts = e_spell_checker_list_available_dicts (spell_checker);
+	merge_id = gtk_ui_manager_new_merge_id (manager);
+
+	for (iter = available_dicts; iter; iter = iter->next) {
+		ESpellDictionary *dictionary = iter->data;
+		GtkAction *action;
+		const gchar *code;
+		const gchar *name;
+		GString *escaped_name = NULL;
+		gchar *action_label;
+		gchar *action_name;
+
+		code = e_spell_dictionary_get_code (dictionary);
+		name = e_spell_dictionary_get_name (dictionary);
+
+		/* Add a suggestion menu. */
+		action_name = g_strdup_printf (
+			"context-spell-suggest-%s-menu", code);
+
+		if (name && strchr (name, '_') != NULL)
+			escaped_name = e_str_replace_string (name, "_", "__");
+
+		action = gtk_action_new (action_name, escaped_name ? escaped_name->str : name, NULL, NULL);
+		gtk_action_group_add_action (action_group, action);
+		g_object_unref (action);
+
+		gtk_ui_manager_add_ui (
+			manager, merge_id,
+			"/context-menu/context-spell-suggest",
+			action_name, action_name,
+			GTK_UI_MANAGER_MENU, FALSE);
+
+		g_free (action_name);
+
+		/* Add an item to the "Add Word To" menu. */
+		action_name = g_strdup_printf ("context-spell-add-%s", code);
+		/* Translators: %s will be replaced with the actual dictionary
+		 * name, where a user can add a word to. This is part of an
+		 * "Add Word To" submenu. */
+		action_label = g_strdup_printf (_("%s Dictionary"), escaped_name ? escaped_name->str : name);
+
+		action = gtk_action_new (
+			action_name, action_label, NULL, NULL);
+
+		g_signal_connect (
+			action, "activate",
+			G_CALLBACK (action_context_spell_add_cb), editor);
+
+		gtk_action_set_visible (action, e_spell_checker_get_language_active (spell_checker, code));
+
+		gtk_action_group_add_action (action_group, action);
+
+		g_object_unref (action);
+
+		gtk_ui_manager_add_ui (
+			manager, merge_id,
+			"/context-menu/context-spell-add-menu",
+			action_name, action_name,
+			GTK_UI_MANAGER_AUTO, FALSE);
+
+		g_free (action_label);
+		g_free (action_name);
+
+		if (escaped_name)
+			g_string_free (escaped_name, TRUE);
+	}
+
+	g_list_free (available_dicts);
+	g_clear_object (&spell_checker);
+}
+
+void
+editor_actions_init (EHTMLEditor *editor)
+{
+	GtkAction *action;
+	GtkActionGroup *action_group;
+	GtkUIManager *manager;
+	const gchar *domain;
+
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	manager = e_html_editor_get_ui_manager (editor);
+	domain = GETTEXT_PACKAGE;
+
+	/* Core Actions */
+	action_group = editor->priv->core_actions;
+	gtk_action_group_set_translation_domain (action_group, domain);
+	gtk_action_group_add_actions (
+		action_group, core_entries,
+		G_N_ELEMENTS (core_entries), editor);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	action_group = editor->priv->core_editor_actions;
+	gtk_action_group_set_translation_domain (action_group, domain);
+	gtk_action_group_add_actions (
+		action_group, core_editor_entries,
+		G_N_ELEMENTS (core_editor_entries), editor);
+	gtk_action_group_add_radio_actions (
+		action_group, core_justify_entries,
+		G_N_ELEMENTS (core_justify_entries),
+		E_CONTENT_EDITOR_ALIGNMENT_LEFT,
+		NULL, NULL);
+	gtk_action_group_add_radio_actions (
+		action_group, core_mode_entries,
+		G_N_ELEMENTS (core_mode_entries),
+		TRUE,
+		G_CALLBACK (action_mode_cb), editor);
+	gtk_action_group_add_radio_actions (
+		action_group, core_style_entries,
+		G_N_ELEMENTS (core_style_entries),
+		E_CONTENT_EDITOR_BLOCK_FORMAT_PARAGRAPH,
+		NULL, NULL);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Face Action */
+	action = e_emoticon_action_new (
+		"insert-emoticon", _("_Emoticon"),
+		_("Insert Emoticon"), NULL);
+	g_object_set (action, "icon-name", "face-smile", NULL);
+	g_signal_connect (
+		action, "item-activated",
+		G_CALLBACK (action_insert_emoticon_cb), editor);
+	gtk_action_group_add_action (action_group, action);
+	g_object_unref (action);
+
+	/* Core Actions (HTML only) */
+	action_group = editor->priv->html_actions;
+	gtk_action_group_set_translation_domain (action_group, domain);
+	gtk_action_group_add_actions (
+		action_group, html_entries,
+		G_N_ELEMENTS (html_entries), editor);
+	gtk_action_group_add_toggle_actions (
+		action_group, html_toggle_entries,
+		G_N_ELEMENTS (html_toggle_entries), editor);
+	gtk_action_group_add_radio_actions (
+		action_group, html_size_entries,
+		G_N_ELEMENTS (html_size_entries),
+		E_CONTENT_EDITOR_FONT_SIZE_NORMAL,
+		NULL, NULL);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Context Menu Actions */
+	action_group = editor->priv->context_actions;
+	gtk_action_group_set_translation_domain (action_group, domain);
+	gtk_action_group_add_actions (
+		action_group, context_entries,
+		G_N_ELEMENTS (context_entries), editor);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Context Menu Actions (HTML only) */
+	action_group = editor->priv->html_context_actions;
+	gtk_action_group_set_translation_domain (action_group, domain);
+	gtk_action_group_add_actions (
+		action_group, html_context_entries,
+		G_N_ELEMENTS (html_context_entries), editor);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Context Menu Actions (spell check only) */
+	action_group = editor->priv->spell_check_actions;
+	gtk_action_group_set_translation_domain (action_group, domain);
+	gtk_action_group_add_actions (
+		action_group, spell_context_entries,
+		G_N_ELEMENTS (spell_context_entries), editor);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Language actions are generated dynamically. */
+	editor_actions_setup_languages_menu (editor);
+	action_group = editor->priv->language_actions;
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Some spell check actions are generated dynamically. */
+	action_group = editor->priv->suggestion_actions;
+	editor_actions_setup_spell_check_menu (editor);
+	gtk_ui_manager_insert_action_group (manager, action_group, 0);
+
+	/* Do this after all language actions are initialized. */
+	e_html_editor_update_spell_actions (editor);
+
+	/* Fine Tuning */
+
+	g_object_set (
+		G_OBJECT (ACTION (SHOW_FIND)),
+		"short-label", _("_Find"), NULL);
+	g_object_set (
+		G_OBJECT (ACTION (SHOW_REPLACE)),
+		"short-label", _("Re_place"), NULL);
+	g_object_set (
+		G_OBJECT (ACTION (INSERT_EMOJI)),
+		"short-label", _("E_moji"), NULL);
+	g_object_set (
+		G_OBJECT (ACTION (INSERT_IMAGE)),
+		"short-label", _("_Image"), NULL);
+	g_object_set (
+		G_OBJECT (ACTION (INSERT_LINK)),
+		"short-label", _("_Link"), NULL);
+	g_object_set (
+		G_OBJECT (ACTION (INSERT_RULE)),
+		/* Translators: 'Rule' here means a horizontal line in an HTML text */
+		"short-label", _("_Rule"), NULL);
+	g_object_set (
+		G_OBJECT (ACTION (INSERT_TABLE)),
+		"short-label", _("_Table"), NULL);
+
+	gtk_action_set_sensitive (ACTION (UNINDENT), FALSE);
+	gtk_action_set_sensitive (ACTION (FIND_AGAIN), FALSE);
+}
+
+static gboolean
+e_html_editor_content_editor_font_name_to_combo_box (GBinding *binding,
+						     const GValue *from_value,
+						     GValue *to_value,
+						     gpointer user_data)
+{
+	gchar *id = NULL;
+
+	id = e_html_editor_util_dup_font_id (GTK_COMBO_BOX (g_binding_get_target (binding)), g_value_get_string (from_value));
+	g_value_take_string (to_value, id ? id : g_strdup (""));
+
+	return TRUE;
+}
+
+static gboolean
+e_html_editor_indent_level_to_bool_indent_cb (GBinding *binding,
+					      const GValue *from_value,
+					      GValue *to_value,
+					      gpointer user_data)
+{
+	g_value_set_boolean (to_value, g_value_get_int (from_value) < E_HTML_EDITOR_MAX_INDENT_LEVEL);
+
+	return TRUE;
+}
+
+static gboolean
+e_html_editor_indent_level_to_bool_unindent_cb (GBinding *binding,
+						const GValue *from_value,
+						GValue *to_value,
+						gpointer user_data)
+{
+	g_value_set_boolean (to_value, g_value_get_int (from_value) > 0);
+
+	return TRUE;
+}
+
+void
+editor_actions_bind (EHTMLEditor *editor)
+{
+	GtkAction *action;
+	GtkActionGroup *action_group;
+	EContentEditor *cnt_editor;
+
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	cnt_editor = e_html_editor_get_content_editor (editor);
+
+	action_group = editor->priv->core_editor_actions;
+	action = gtk_action_group_get_action (action_group, "mode-html");
+	e_binding_bind_property (
+		cnt_editor, "html-mode",
+		action, "current-value",
+		G_BINDING_BIDIRECTIONAL | G_BINDING_SYNC_CREATE);
+
+	/* Synchronize widget mode with the buttons */
+	e_content_editor_set_html_mode (cnt_editor, TRUE);
+
+	e_binding_bind_property (
+		cnt_editor, "can-redo",
+		ACTION (REDO), "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "can-undo",
+		ACTION (UNDO), "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "can-copy",
+		ACTION (COPY), "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "can-cut",
+		ACTION (CUT), "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "can-paste",
+		ACTION (PASTE), "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "can-paste",
+		ACTION (PASTE_QUOTE), "sensitive",
+		G_BINDING_SYNC_CREATE);
+
+	/* This is connected to JUSTIFY_LEFT action only, but
+	 * it automatically applies on all actions in the group. */
+	e_binding_bind_property (
+		cnt_editor, "alignment",
+		ACTION (JUSTIFY_LEFT), "current-value",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property (
+		cnt_editor, "bold",
+		ACTION (BOLD), "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property (
+		cnt_editor, "font-size",
+		ACTION (FONT_SIZE_GROUP), "current-value",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property (
+		cnt_editor, "block-format",
+		ACTION (STYLE_NORMAL), "current-value",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property_full (
+		cnt_editor, "indent-level",
+		ACTION (INDENT), "sensitive",
+		G_BINDING_SYNC_CREATE,
+		e_html_editor_indent_level_to_bool_indent_cb,
+		NULL, NULL, NULL);
+	e_binding_bind_property_full (
+		cnt_editor, "indent-level",
+		ACTION (UNINDENT), "sensitive",
+		G_BINDING_SYNC_CREATE,
+		e_html_editor_indent_level_to_bool_unindent_cb,
+		NULL, NULL, NULL);
+	e_binding_bind_property (
+		cnt_editor, "italic",
+		ACTION (ITALIC), "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property (
+		cnt_editor, "strikethrough",
+		ACTION (STRIKETHROUGH), "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property (
+		cnt_editor, "underline",
+		ACTION (UNDERLINE), "active",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL);
+	e_binding_bind_property_full (
+		cnt_editor, "font-name",
+		editor->priv->font_name_combo_box, "active-id",
+		G_BINDING_SYNC_CREATE | G_BINDING_BIDIRECTIONAL,
+		e_html_editor_content_editor_font_name_to_combo_box,
+		NULL,
+		NULL, NULL);
+
+	/* Cannot use binding, due to subscript and superscript being mutually exclusive */
+	g_signal_connect_object (ACTION (SUBSCRIPT), "toggled",
+		G_CALLBACK (html_editor_actions_subscript_toggled_cb), editor, 0);
+	g_signal_connect_object (cnt_editor, "notify::subscript",
+		G_CALLBACK (html_editor_actions_notify_subscript_cb), editor, 0);
+	g_signal_connect_object (ACTION (SUPERSCRIPT), "toggled",
+		G_CALLBACK (html_editor_actions_superscript_toggled_cb), editor, 0);
+	g_signal_connect_object (cnt_editor, "notify::superscript",
+		G_CALLBACK (html_editor_actions_notify_superscript_cb), editor, 0);
+
+	g_signal_connect_object (cnt_editor, "notify::html-mode",
+		G_CALLBACK (html_editor_actions_notify_html_mode_cb), editor, 0);
+
+	/* Disable all actions and toolbars when editor is not editable */
+	e_binding_bind_property (
+		cnt_editor, "editable",
+		editor->priv->core_editor_actions, "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "editable",
+		editor->priv->html_actions, "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "editable",
+		editor->priv->spell_check_actions, "sensitive",
+		G_BINDING_SYNC_CREATE);
+	e_binding_bind_property (
+		cnt_editor, "editable",
+		editor->priv->suggestion_actions, "sensitive",
+		G_BINDING_SYNC_CREATE);
+}
+
+void
+editor_actions_update_spellcheck_languages_menu (EHTMLEditor *editor,
+						 const gchar * const *languages)
+{
+	GHashTable *active;
+	GList *actions, *link;
+	gint ii;
+
+	g_return_if_fail (E_IS_HTML_EDITOR (editor));
+
+	active = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+
+	for (ii = 0; languages && languages[ii]; ii++) {
+		g_hash_table_insert (active, g_strdup (languages[ii]), NULL);
+	}
+
+	actions = gtk_action_group_list_actions (editor->priv->language_actions);
+	for (link = actions; link; link = g_list_next (link)) {
+		GtkToggleAction *toggle_action;
+		gboolean is_active;
+
+		if (!GTK_IS_TOGGLE_ACTION (link->data))
+			continue;
+
+		if (gtk_action_get_name (link->data) &&
+		    g_str_has_prefix (gtk_action_get_name (link->data), "recent-spell-language-"))
+			continue;
+
+		is_active = g_hash_table_contains (active, gtk_action_get_name (link->data));
+		toggle_action = GTK_TOGGLE_ACTION (link->data);
+
+		if ((gtk_toggle_action_get_active (toggle_action) ? 1 : 0) != (is_active ? 1 : 0)) {
+			g_signal_handlers_block_by_func (toggle_action, action_language_cb, editor);
+			gtk_toggle_action_set_active (toggle_action, is_active);
+			g_signal_handlers_unblock_by_func (toggle_action, action_language_cb, editor);
+		}
+	}
+
+	g_hash_table_destroy (active);
+	g_list_free (actions);
+}
diff -urN a/src/e-util/e-mail-signature-editor.c b/src/e-util/e-mail-signature-editor.c
--- a/src/e-util/e-mail-signature-editor.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/e-util/e-mail-signature-editor.c	2022-01-08 18:47:17.608212272 -0800
@@ -317,14 +317,14 @@
 	{ "close",
 	  "window-close",
 	  N_("_Close"),
-	  "<Control>w",
+	  "<Super>w",
 	  N_("Close"),
 	  G_CALLBACK (action_close_cb) },
 
 	{ "save-and-close",
 	  "document-save",
 	  N_("_Save and Close"),
-	  "<Control>Return",
+	  "<Alt><Super>s",
 	  N_("Save and Close"),
 	  G_CALLBACK (action_save_and_close_cb) },
 
diff -urN a/src/e-util/e-web-view.c b/src/e-util/e-web-view.c
--- a/src/e-util/e-web-view.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/e-util/e-web-view.c	2022-01-08 18:47:17.608212272 -0800
@@ -404,7 +404,7 @@
 	{ "uri-copy",
 	  "edit-copy",
 	  N_("_Copy Link Location"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the link to the clipboard"),
 	  G_CALLBACK (action_uri_copy_cb) }
 };
@@ -424,7 +424,7 @@
 	{ "mailto-copy",
 	  "edit-copy",
 	  N_("_Copy Email Address"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the email address to the clipboard"),
 	  G_CALLBACK (action_mailto_copy_cb) },
 
@@ -448,14 +448,14 @@
 	{ "image-copy",
 	  "edit-copy",
 	  N_("_Copy Image"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the image to the clipboard"),
 	  G_CALLBACK (action_image_copy_cb) },
 
 	{ "image-save",
 	  "document-save",
 	  N_("Save _Image…"),
-	  "<Control>s",
+	  "<Super>s",
 	  N_("Save the image to a file"),
 	  G_CALLBACK (action_image_save_cb) }
 };
@@ -465,7 +465,7 @@
 	{ "copy-clipboard",
 	  "edit-copy",
 	  N_("_Copy"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the selection"),
 	  G_CALLBACK (action_copy_clipboard_cb) },
 
diff -urN a/src/e-util/test-html-editor.c b/src/e-util/test-html-editor.c
--- a/src/e-util/test-html-editor.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/e-util/test-html-editor.c	2022-01-08 18:47:17.608212272 -0800
@@ -423,7 +423,7 @@
 	{ "new-editor",
 	  "document-new",
 	  N_("_New editor"),
-	  "<Control>N",
+	  "<Super>N",
 	  NULL,
 	  G_CALLBACK (action_new_editor_cb) },
 
@@ -431,14 +431,14 @@
 	{ "print",
 	  "document-print",
 	  N_("_Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  NULL,
 	  G_CALLBACK (action_print_cb) },
 
 	{ "print-preview",
 	  "document-print-preview",
 	  N_("Print Pre_view"),
-	  "<Control><Shift>p",
+	  "<Super><Shift>p",
 	  NULL,
 	  G_CALLBACK (action_print_preview_cb) },
 #endif /* ENABLE_PRINT */
@@ -513,7 +513,7 @@
 	  NULL,
 	  N_("Inspector"),
 	  NULL,
-	  "<Control><Shift>I",
+	  "<Super><Shift>I",
 	  G_CALLBACK (action_view_inspector) },
 
 	{ "view-menu",
diff -urN a/src/e-util/test-html-editor-units-utils.c b/src/e-util/test-html-editor-units-utils.c
--- a/src/e-util/test-html-editor-units-utils.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/e-util/test-html-editor-units-utils.c	2022-01-08 18:47:17.608212272 -0800
@@ -227,7 +227,7 @@
 	return FALSE;
 }
 
-/* <Control>+<Shift>+I */
+/* <Super>+<Shift>+I */
 #define WEBKIT_INSPECTOR_MOD  (GDK_CONTROL_MASK | GDK_SHIFT_MASK)
 #define WEBKIT_INSPECTOR_KEY  (GDK_KEY_I)
 
diff -urN a/src/mail/e-mail-browser.c b/src/mail/e-mail-browser.c
--- a/src/mail/e-mail-browser.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/mail/e-mail-browser.c	2022-01-08 18:47:17.608212272 -0800
@@ -164,28 +164,28 @@
 	{ "close",
 	  "window-close",
 	  N_("_Close"),
-	  "<Control>w",
+	  "<Super>w",
 	  N_("Close this window"),
 	  G_CALLBACK (action_close_cb) },
 
 	{ "copy-clipboard",
 	  "edit-copy",
 	  N_("_Copy"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the selection"),
 	  NULL },  /* Handled by EFocusTracker */
 
 	{ "cut-clipboard",
 	  "edit-cut",
 	  N_("Cu_t"),
-	  "<Control>x",
+	  "<Super>x",
 	  N_("Cut the selection"),
 	  NULL },  /* Handled by EFocusTracker */
 
 	{ "paste-clipboard",
 	  "edit-paste",
 	  N_("_Paste"),
-	  "<Control>v",
+	  "<Super>v",
 	  N_("Paste the clipboard"),
 	  NULL },  /* Handled by EFocusTracker */
 
diff -urN a/src/mail/e-mail-notes.c b/src/mail/e-mail-notes.c
--- a/src/mail/e-mail-notes.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/mail/e-mail-notes.c	2022-01-08 18:47:17.608212272 -0800
@@ -1015,14 +1015,14 @@
 		{ "close",
 		  "window-close",
 		  N_("_Close"),
-		  "<Control>w",
+		  "<Super>w",
 		  N_("Close"),
 		  G_CALLBACK (action_close_cb) },
 
 		{ "save-and-close",
 		  "document-save",
 		  N_("_Save and Close"),
-		  "<Control>Return",
+		  "<Alt><Super>s",
 		  N_("Save and Close"),
 		  G_CALLBACK (action_save_and_close_cb) },
 
diff -urN a/src/mail/e-mail-reader.c b/src/mail/e-mail-reader.c
--- a/src/mail/e-mail-reader.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/mail/e-mail-reader.c	2022-01-08 18:47:17.611545254 -0800
@@ -2435,14 +2435,14 @@
 	{ "mail-archive",
 	  "mail-archive",
 	  N_("_Archive…"),
-	  "<Alt><Control>a",
+	  "<Alt><Super>a",
 	  N_("Move selected messages to the Archive folder for the account"),
 	  G_CALLBACK (action_mail_archive_cb) },
 
 	{ "mail-check-for-junk",
 	  "mail-mark-junk",
 	  N_("Check for _Junk"),
-	  "<Control><Alt>j",
+	  "<Super><Alt>j",
 	  N_("Filter the selected messages for junk status"),
 	  G_CALLBACK (action_mail_check_for_junk_cb) },
 
@@ -2463,14 +2463,14 @@
 	{ "mail-copy",
 	  "mail-copy",
 	  N_("_Copy to Folder…"),
-	  "<Shift><Control>y",
+	  "<Shift><Super>y",
 	  N_("Copy selected messages to another folder"),
 	  G_CALLBACK (action_mail_copy_cb) },
 
 	{ "mail-delete",
 	  "user-trash",
 	  N_("_Delete Message"),
-	  "<Control>d",
+	  "<Super>d",
 	  N_("Mark the selected messages for deletion"),
 	  G_CALLBACK (action_mail_delete_cb) },
 
@@ -2526,14 +2526,14 @@
 	{ "mail-filters-apply",
 	  "stock_mail-filters-apply",
 	  N_("A_pply Filters"),
-	  "<Control>y",
+	  "<Super>y",
 	  N_("Apply filter rules to the selected messages"),
 	  G_CALLBACK (action_mail_filters_apply_cb) },
 
 	{ "mail-find",
 	  "edit-find",
 	  N_("_Find in Message…"),
-	  "<Shift><Control>f",
+	  "<Shift><Super>f",
 	  N_("Search for text in the body of the displayed message"),
 	  G_CALLBACK (action_mail_find_cb) },
 
@@ -2554,7 +2554,7 @@
 	{ "mail-flag-for-followup",
 	  "stock_mail-flag-for-followup",
 	  N_("Follow _Up…"),
-	  "<Shift><Control>g",
+	  "<Shift><Super>g",
 	  N_("Flag the selected messages for follow-up"),
 	  G_CALLBACK (action_mail_flag_for_followup_cb) },
 
@@ -2619,7 +2619,7 @@
 	{ "mail-load-images",
 	  "image-x-generic",
 	  N_("_Load Images"),
-	  "<Control>i",
+	  "<Super>i",
 	  N_("Force images in HTML mail to be loaded"),
 	  G_CALLBACK (action_mail_load_images_cb) },
 
@@ -2647,21 +2647,21 @@
 	{ "mail-mark-junk",
 	  "mail-mark-junk",
 	  N_("_Junk"),
-	  "<Control>j",
+	  "<Super>j",
 	  N_("Mark the selected messages as junk"),
 	  G_CALLBACK (action_mail_mark_junk_cb) },
 
 	{ "mail-mark-notjunk",
 	  "mail-mark-notjunk",
 	  N_("_Not Junk"),
-	  "<Shift><Control>j",
+	  "<Shift><Super>j",
 	  N_("Mark the selected messages as not being junk"),
 	  G_CALLBACK (action_mail_mark_notjunk_cb) },
 
 	{ "mail-mark-read",
 	  "mail-mark-read",
 	  N_("_Read"),
-	  "<Control>k",
+	  "<Super>k",
 	  N_("Mark the selected messages as having been read"),
 	  G_CALLBACK (action_mail_mark_read_cb) },
 
@@ -2689,7 +2689,7 @@
 	{ "mail-mark-unread",
 	  "mail-mark-unread",
 	  N_("_Unread"),
-	  "<Shift><Control>k",
+	  "<Shift><Super>k",
 	  N_("Mark the selected messages as not having been read"),
 	  G_CALLBACK (action_mail_mark_unread_cb) },
 
@@ -2703,28 +2703,28 @@
 	{ "mail-message-new",
 	  "mail-message-new",
 	  N_("Compose _New Message"),
-	  "<Shift><Control>m",
+	  "<Shift><Super>m",
 	  N_("Open a window for composing a mail message"),
 	  G_CALLBACK (action_mail_message_new_cb) },
 
 	{ "mail-message-open",
 	  NULL,
 	  N_("_Open in New Window"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("Open the selected messages in a new window"),
 	  G_CALLBACK (action_mail_message_open_cb) },
 
 	{ "mail-move",
 	  "mail-move",
 	  N_("_Move to Folder…"),
-	  "<Shift><Control>v",
+	  "<Shift><Super>v",
 	  N_("Move selected messages to another folder"),
 	  G_CALLBACK (action_mail_move_cb) },
 
 	{ "mail-next",
 	  "go-next",
 	  N_("_Next Message"),
-	  "<Control>Page_Down",
+	  "<Super>Page_Down",
 	  N_("Display the next message"),
 	  G_CALLBACK (action_mail_next_cb) },
 
@@ -2745,14 +2745,14 @@
 	{ "mail-next-unread",
 	  "go-jump",
 	  N_("Next _Unread Message"),
-	  "<Control>bracketright",
+	  "<Super>bracketright",
 	  N_("Display the next unread message"),
 	  G_CALLBACK (action_mail_next_unread_cb) },
 
 	{ "mail-previous",
 	  "go-previous",
 	  N_("_Previous Message"),
-	  "<Control>Page_Up",
+	  "<Super>Page_Up",
 	  N_("Display the previous message"),
 	  G_CALLBACK (action_mail_previous_cb) },
 
@@ -2773,14 +2773,14 @@
 	{ "mail-previous-unread",
 	  NULL,
 	  N_("P_revious Unread Message"),
-	  "<Control>bracketleft",
+	  "<Super>bracketleft",
 	  N_("Display the previous unread message"),
 	  G_CALLBACK (action_mail_previous_unread_cb) },
 
 	{ "mail-print",
 	  "document-print",
 	  N_("_Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  N_("Print this message"),
 	  G_CALLBACK (action_mail_print_cb) },
 
@@ -2815,28 +2815,28 @@
 	{ "mail-reply-all",
 	  NULL,
 	  N_("Reply to _All"),
-	  "<Shift><Control>r",
+	  "<Shift><Super>r",
 	  N_("Compose a reply to all the recipients of the selected message"),
 	  G_CALLBACK (action_mail_reply_all_cb) },
 
 	{ "mail-reply-alternative",
 	  NULL,
 	  N_("Al_ternative Reply…"),
-	  "<Alt><Control>r",
+	  "<Alt><Super>r",
 	  N_("Choose reply options for the selected message"),
 	  G_CALLBACK (action_mail_reply_alternative_cb) },
 
 	{ "mail-reply-list",
 	  NULL,
 	  N_("Reply to _List"),
-	  "<Control>l",
+	  "<Super>l",
 	  N_("Compose a reply to the mailing list of the selected message"),
 	  G_CALLBACK (action_mail_reply_list_cb) },
 
 	{ "mail-reply-sender",
 	  "mail-reply-sender",
 	  N_("_Reply to Sender"),
-	  "<Control>r",
+	  "<Super>r",
 	  N_("Compose a reply to the sender of the selected message"),
 	  G_CALLBACK (action_mail_reply_sender_cb) },
 
@@ -2850,7 +2850,7 @@
 	{ "mail-save-as",
 	  "document-save-as",
 	  N_("_Save as mbox…"),
-	  "<Control>s",
+	  "<Super>s",
 	  N_("Save selected messages as an mbox file"),
 	  G_CALLBACK (action_mail_save_as_cb) },
 
@@ -2864,7 +2864,7 @@
 	{ "mail-show-source",
 	  NULL,
 	  N_("_Message Source"),
-	  "<Control>u",
+	  "<Super>u",
 	  N_("Show the raw email source of the message"),
 	  G_CALLBACK (action_mail_show_source_cb) },
 
@@ -2878,28 +2878,28 @@
 	{ "mail-undelete",
 	  NULL,
 	  N_("_Undelete Message"),
-	  "<Shift><Control>d",
+	  "<Shift><Super>d",
 	  N_("Undelete the selected messages"),
 	  G_CALLBACK (action_mail_undelete_cb) },
 
 	{ "mail-zoom-100",
 	  "zoom-original",
 	  N_("_Normal Size"),
-	  "<Control>0",
+	  "<Super>0",
 	  N_("Reset the text to its original size"),
 	  G_CALLBACK (action_mail_zoom_100_cb) },
 
 	{ "mail-zoom-in",
 	  "zoom-in",
 	  N_("_Zoom In"),
-	  "<Control>plus",
+	  "<Super>plus",
 	  N_("Increase the text size"),
 	  G_CALLBACK (action_mail_zoom_in_cb) },
 
 	{ "mail-zoom-out",
 	  "zoom-out",
 	  N_("Zoom _Out"),
-	  "<Control>minus",
+	  "<Super>minus",
 	  N_("Decrease the text size"),
 	  G_CALLBACK (action_mail_zoom_out_cb) },
 
@@ -5127,7 +5127,7 @@
 		G_CALLBACK (action_mail_forward_cb), reader);
 
 	gtk_action_group_add_action_with_accel (
-		action_group, GTK_ACTION (menu_tool_action), "<Control>f");
+		action_group, GTK_ACTION (menu_tool_action), "<Super>f");
 
 	/* Likewise the "mail-reply-group" action. */
 
@@ -5147,7 +5147,7 @@
 		G_CALLBACK (action_mail_reply_group_cb), reader);
 
 	gtk_action_group_add_action_with_accel (
-		action_group, GTK_ACTION (menu_tool_action), "<Control>g");
+		action_group, GTK_ACTION (menu_tool_action), "<Super>g");
 
 	/* Add the other actions the normal way. */
 	gtk_action_group_add_actions (
diff -urN a/src/mail/e-mail-reader.c.orig b/src/mail/e-mail-reader.c.orig
--- a/src/mail/e-mail-reader.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/mail/e-mail-reader.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,6241 @@
+/*
+ * e-mail-reader.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ */
+
+#include "evolution-config.h"
+
+#include "e-mail-reader.h"
+
+#include <glib/gi18n.h>
+#include <gdk/gdkkeysyms.h>
+
+#ifdef HAVE_XFREE
+#include <X11/XF86keysym.h>
+#endif
+
+#include <shell/e-shell-utils.h>
+
+#include <libemail-engine/libemail-engine.h>
+
+#include <em-format/e-mail-formatter.h>
+#include <em-format/e-mail-parser.h>
+#include <em-format/e-mail-part-utils.h>
+
+#include "e-mail-backend.h"
+#include "e-mail-browser.h"
+#include "e-mail-enumtypes.h"
+#include "e-mail-label-action.h"
+#include "e-mail-label-dialog.h"
+#include "e-mail-label-list-store.h"
+#include "e-mail-notes.h"
+#include "e-mail-reader-utils.h"
+#include "e-mail-remote-content-popover.h"
+#include "e-mail-ui-session.h"
+#include "e-mail-view.h"
+#include "em-composer-utils.h"
+#include "em-event.h"
+#include "em-folder-selector.h"
+#include "em-folder-tree.h"
+#include "em-utils.h"
+#include "mail-autofilter.h"
+#include "mail-vfolder-ui.h"
+#include "message-list.h"
+
+#define E_MAIL_READER_GET_PRIVATE(obj) \
+	((EMailReaderPrivate *) g_object_get_qdata \
+	(G_OBJECT (obj), quark_private))
+
+#define d(x)
+
+typedef struct _EMailReaderClosure EMailReaderClosure;
+typedef struct _EMailReaderPrivate EMailReaderPrivate;
+
+struct _EMailReaderClosure {
+	EMailReader *reader;
+	EActivity *activity;
+	CamelMimeMessage *message;
+	CamelFolder *folder;
+	gchar *message_uid;
+	gboolean selection_is_html;
+};
+
+struct _EMailReaderPrivate {
+
+	EMailForwardStyle forward_style;
+	EMailReplyStyle reply_style;
+
+	/* This timer runs when the user selects a single message. */
+	guint message_selected_timeout_id;
+
+	/* This allows message retrieval to be cancelled if another
+	 * message is selected before the retrieval has completed. */
+	GCancellable *retrieving_message;
+
+	/* These flags work to prevent a folder switch from
+	 * automatically marking the message as read. We only want
+	 * that to happen when the -user- selects a message. */
+	guint folder_was_just_selected : 1;
+	guint avoid_next_mark_as_seen : 1;
+	guint did_try_to_open_message : 1;
+
+	guint group_by_threads : 1;
+	guint mark_seen_always : 1;
+	guint delete_selects_previous : 1;
+
+	/* to be able to start the mark_seen timeout only after
+	 * the message is loaded into the EMailDisplay */
+	gboolean schedule_mark_seen;
+	guint schedule_mark_seen_interval;
+
+	gpointer followup_alert; /* weak pointer to an EAlert */
+
+	GSList *ongoing_operations; /* GCancellable * */
+
+	guint main_menu_label_merge_id;
+	guint popup_menu_label_merge_id;
+};
+
+enum {
+	CHANGED,
+	COMPOSER_CREATED,
+	FOLDER_LOADED,
+	MESSAGE_LOADED,
+	MESSAGE_SEEN,
+	SHOW_SEARCH_BAR,
+	UPDATE_ACTIONS,
+	LAST_SIGNAL
+};
+
+/* Remembers the previously selected folder when transferring messages. */
+static gchar *default_xfer_messages_uri;
+
+static GQuark quark_private;
+static guint signals[LAST_SIGNAL];
+
+G_DEFINE_INTERFACE (EMailReader, e_mail_reader, G_TYPE_INITIALLY_UNOWNED)
+
+static void
+mail_reader_set_display_formatter_for_message (EMailReader *reader,
+                                               EMailDisplay *display,
+                                               const gchar *message_uid,
+                                               CamelMimeMessage *message,
+                                               CamelFolder *folder);
+
+static void
+mail_reader_closure_free (EMailReaderClosure *closure)
+{
+	g_clear_object (&closure->reader);
+	g_clear_object (&closure->activity);
+	g_clear_object (&closure->folder);
+	g_clear_object (&closure->message);
+	g_free (closure->message_uid);
+
+	g_slice_free (EMailReaderClosure, closure);
+}
+
+static void
+mail_reader_private_free (EMailReaderPrivate *priv)
+{
+	if (priv->message_selected_timeout_id > 0)
+		g_source_remove (priv->message_selected_timeout_id);
+
+	if (priv->retrieving_message != NULL) {
+		g_cancellable_cancel (priv->retrieving_message);
+		g_object_unref (priv->retrieving_message);
+		priv->retrieving_message = NULL;
+	}
+
+	g_slice_free (EMailReaderPrivate, priv);
+}
+
+static void
+action_mail_add_sender_cb (GtkAction *action,
+                           EMailReader *reader)
+{
+	EShell *shell;
+	EMailBackend *backend;
+	EMailSession *session;
+	EShellBackend *shell_backend;
+	CamelInternetAddress *cia;
+	CamelMessageInfo *info = NULL;
+	CamelFolder *folder;
+	GPtrArray *uids;
+	const gchar *address;
+	const gchar *message_uid;
+
+	folder = e_mail_reader_ref_folder (reader);
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+
+	uids = e_mail_reader_get_selected_uids (reader);
+	g_return_if_fail (uids != NULL && uids->len == 1);
+	message_uid = g_ptr_array_index (uids, 0);
+
+	info = camel_folder_get_message_info (folder, message_uid);
+	if (info == NULL)
+		goto exit;
+
+	address = camel_message_info_get_from (info);
+	if (address == NULL || *address == '\0')
+		goto exit;
+
+	/* XXX EBookShellBackend should be listening for this
+	 *     event.  Kind of kludgey, but works for now. */
+	shell_backend = E_SHELL_BACKEND (backend);
+	shell = e_shell_backend_get_shell (shell_backend);
+	e_shell_event (shell, "contact-quick-add-email", (gpointer) address);
+
+	/* Remove this address from the photo cache. */
+	cia = camel_internet_address_new ();
+	if (camel_address_decode (CAMEL_ADDRESS (cia), address) > 0) {
+		EPhotoCache *photo_cache;
+		const gchar *address_only = NULL;
+
+		photo_cache = e_mail_ui_session_get_photo_cache (
+			E_MAIL_UI_SESSION (session));
+		if (camel_internet_address_get (cia, 0, NULL, &address_only))
+			e_photo_cache_remove_photo (photo_cache, address_only);
+	}
+	g_object_unref (cia);
+
+exit:
+	g_clear_object (&info);
+	g_ptr_array_unref (uids);
+
+	g_clear_object (&folder);
+}
+
+static void
+action_add_to_address_book_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	EShell *shell;
+	EMailBackend *backend;
+	EMailDisplay *display;
+	EMailSession *session;
+	EShellBackend *shell_backend;
+	CamelInternetAddress *cia;
+	EPhotoCache *photo_cache;
+	EWebView *web_view;
+	CamelURL *curl;
+	const gchar *uri;
+	const gchar *address_only = NULL;
+	gchar *email;
+
+	/* This action is defined in EMailDisplay. */
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+
+	display = e_mail_reader_get_mail_display (reader);
+	if (display == NULL)
+		return;
+
+	web_view = E_WEB_VIEW (display);
+	uri = e_web_view_get_selected_uri (web_view);
+	g_return_if_fail (uri != NULL);
+
+	curl = camel_url_new (uri, NULL);
+	g_return_if_fail (curl != NULL);
+
+	if (curl->path == NULL || *curl->path == '\0')
+		goto exit;
+
+	cia = camel_internet_address_new ();
+	if (camel_address_decode (CAMEL_ADDRESS (cia), curl->path) < 0) {
+		g_object_unref (cia);
+		goto exit;
+	}
+
+	/* XXX EBookShellBackend should be listening for this
+	 *     event.  Kind of kludgey, but works for now. */
+	shell_backend = E_SHELL_BACKEND (backend);
+	shell = e_shell_backend_get_shell (shell_backend);
+	email = camel_address_format (CAMEL_ADDRESS (cia));
+	e_shell_event (shell, "contact-quick-add-email", email);
+	g_free (email);
+
+	/* Remove this address from the photo cache. */
+	photo_cache = e_mail_ui_session_get_photo_cache (
+		E_MAIL_UI_SESSION (session));
+	if (camel_internet_address_get (cia, 0, NULL, &address_only))
+		e_photo_cache_remove_photo (photo_cache, address_only);
+
+	g_object_unref (cia);
+
+exit:
+	camel_url_free (curl);
+}
+
+static void
+action_mail_charset_cb (GtkRadioAction *action,
+                        GtkRadioAction *current,
+                        EMailReader *reader)
+{
+	EMailDisplay *display;
+	EMailFormatter *formatter;
+
+	if (action != current)
+		return;
+
+	display = e_mail_reader_get_mail_display (reader);
+	formatter = e_mail_display_get_formatter (display);
+
+	if (formatter != NULL) {
+		const gchar *charset;
+
+		/* Charset for "Default" action will be NULL. */
+		charset = g_object_get_data (G_OBJECT (action), "charset");
+		e_mail_formatter_set_charset (formatter, charset);
+	}
+}
+
+static void
+action_mail_check_for_junk_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	EMailBackend *backend;
+	EMailSession *session;
+	CamelFolder *folder;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	backend = e_mail_reader_get_backend (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+	session = e_mail_backend_get_session (backend);
+
+	mail_filter_folder (
+		session, folder, uids,
+		E_FILTER_SOURCE_JUNKTEST, FALSE);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+mail_reader_copy_or_move_selected_messages (EMailReader *reader,
+					    gboolean is_move)
+{
+	CamelFolder *folder;
+	EMailBackend *backend;
+	EMailSession *session;
+	EMFolderSelector *selector;
+	EMFolderTree *folder_tree;
+	EMFolderTreeModel *model;
+	GSettings *settings;
+	GtkWidget *dialog;
+	GtkWindow *window;
+	GPtrArray *uids;
+	const gchar *uri;
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+
+	folder = e_mail_reader_ref_folder (reader);
+	window = e_mail_reader_get_window (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+	model = em_folder_tree_model_get_default ();
+
+	dialog = em_folder_selector_new (window, model);
+
+	gtk_window_set_title (GTK_WINDOW (dialog), is_move ? _("Move to Folder") : _("Copy to Folder"));
+
+	selector = EM_FOLDER_SELECTOR (dialog);
+	em_folder_selector_set_can_create (selector, TRUE);
+	em_folder_selector_set_default_button_label (selector, is_move ? _("_Move") : _("C_opy"));
+
+	folder_tree = em_folder_selector_get_folder_tree (selector);
+
+	em_folder_tree_set_excluded (
+		folder_tree,
+		EMFT_EXCLUDE_NOSELECT |
+		EMFT_EXCLUDE_VIRTUAL |
+		EMFT_EXCLUDE_VTRASH);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	if (!g_settings_get_boolean (settings, "copy-move-to-folder-preserve-expand"))
+		gtk_tree_view_expand_all (GTK_TREE_VIEW (folder_tree));
+
+	g_clear_object (&settings);
+
+	em_folder_selector_maybe_collapse_archive_folders (selector);
+
+	if (default_xfer_messages_uri != NULL) {
+		em_folder_tree_set_selected (
+			folder_tree, default_xfer_messages_uri, FALSE);
+	} else if (folder) {
+		gchar *uri = e_mail_folder_uri_from_folder (folder);
+
+		if (uri) {
+			em_folder_tree_set_selected (folder_tree, uri, FALSE);
+			g_free (uri);
+		}
+	}
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) != GTK_RESPONSE_OK)
+		goto exit;
+
+	uri = em_folder_selector_get_selected_uri (selector);
+
+	g_free (default_xfer_messages_uri);
+	default_xfer_messages_uri = g_strdup (uri);
+
+	if (uri != NULL)
+		mail_transfer_messages (
+			session, folder, uids,
+			is_move, uri, 0, NULL, NULL);
+
+exit:
+	gtk_widget_destroy (dialog);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+mail_reader_manage_color_flag_on_selection (EMailReader *reader,
+					    const gchar *color)
+{
+	CamelFolder *folder;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	folder = e_mail_reader_ref_folder (reader);
+
+	if (folder != NULL) {
+		GPtrArray *uids;
+		guint ii;
+
+		camel_folder_freeze (folder);
+
+		uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+		for (ii = 0; ii < uids->len; ii++) {
+			CamelMessageInfo *info;
+
+			info = camel_folder_get_message_info (folder, uids->pdata[ii]);
+			if (info) {
+				camel_message_info_set_user_tag (info, "color", color);
+				g_object_unref (info);
+			}
+		}
+
+		g_ptr_array_unref (uids);
+
+		camel_folder_thaw (folder);
+
+		g_object_unref (folder);
+	}
+}
+
+static void
+action_mail_color_assign_cb (GtkAction *action,
+			     EMailReader *reader)
+{
+	GtkWidget *dialog;
+
+	dialog = gtk_color_chooser_dialog_new (NULL, e_mail_reader_get_window (reader));
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_OK) {
+		GdkRGBA rgba;
+		gchar *color;
+
+		gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER (dialog), &rgba);
+
+		color = g_strdup_printf ("#%02X%02X%02X",
+			0xFF & ((gint) (255 * rgba.red)),
+			0xFF & ((gint) (255 * rgba.green)),
+			0xFF & ((gint) (255 * rgba.blue)));
+
+		if (color) {
+			mail_reader_manage_color_flag_on_selection (reader, color);
+
+			g_free (color);
+		}
+	}
+
+	gtk_widget_destroy (dialog);
+}
+
+static void
+action_mail_color_unset_cb (GtkAction *action,
+			    EMailReader *reader)
+{
+	mail_reader_manage_color_flag_on_selection (reader, NULL);
+}
+
+static void
+action_mail_copy_cb (GtkAction *action,
+                     EMailReader *reader)
+{
+	mail_reader_copy_or_move_selected_messages (reader, FALSE);
+}
+
+static gboolean
+mail_reader_replace_vee_folder_with_real (CamelFolder **inout_folder,
+					  const gchar *uid,
+					  gchar **out_real_uid)
+{
+	g_return_val_if_fail (inout_folder != NULL, FALSE);
+	g_return_val_if_fail (CAMEL_IS_FOLDER (*inout_folder), FALSE);
+	g_return_val_if_fail (uid != NULL, FALSE);
+	g_return_val_if_fail (out_real_uid != NULL, FALSE);
+
+	*out_real_uid = NULL;
+
+	if (CAMEL_IS_VEE_FOLDER (*inout_folder)) {
+		CamelMessageInfo *info;
+
+		info = camel_folder_get_message_info (*inout_folder, uid);
+		if (info) {
+			CamelFolder *real_folder;
+
+			real_folder = camel_vee_folder_get_location (CAMEL_VEE_FOLDER (*inout_folder), CAMEL_VEE_MESSAGE_INFO (info), out_real_uid);
+
+			if (real_folder && *out_real_uid) {
+				g_object_unref (*inout_folder);
+
+				*inout_folder = g_object_ref (real_folder);
+			}
+
+			g_object_unref (info);
+		} else {
+			g_warn_if_reached ();
+		}
+	}
+
+	return *out_real_uid != NULL;
+}
+
+static void
+action_mail_edit_note_cb (GtkAction *action,
+			  EMailReader *reader)
+{
+	CamelFolder *folder;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids (reader);
+
+	if (uids && uids->len == 1) {
+		gchar *real_uid = NULL;
+		const gchar *uid = uids->pdata[0];
+
+		if (mail_reader_replace_vee_folder_with_real (&folder, uid, &real_uid))
+			uid = real_uid;
+
+		e_mail_notes_edit (e_mail_reader_get_window (reader), folder, uid);
+
+		g_free (real_uid);
+	} else {
+		g_warn_if_reached ();
+	}
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+typedef struct {
+	CamelFolder *folder;
+	gchar *uid;
+} DeleteNoteData;
+
+static void
+delete_note_data_free (gpointer ptr)
+{
+	DeleteNoteData *dnd = ptr;
+
+	if (dnd) {
+		g_clear_object (&dnd->folder);
+		g_free (dnd->uid);
+		g_slice_free (DeleteNoteData, dnd);
+	}
+}
+
+static void
+mail_delete_note_thread (EAlertSinkThreadJobData *job_data,
+			 gpointer user_data,
+			 GCancellable *cancellable,
+			 GError **error)
+{
+	DeleteNoteData *dnd = user_data;
+
+	g_return_if_fail (dnd != NULL);
+	g_return_if_fail (CAMEL_IS_FOLDER (dnd->folder));
+	g_return_if_fail (dnd->uid != NULL);
+
+	e_mail_notes_remove_sync (dnd->folder, dnd->uid, cancellable, error);
+}
+
+static void
+action_mail_delete_note_cb (GtkAction *action,
+			    EMailReader *reader)
+{
+	CamelFolder *folder;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids (reader);
+
+	if (uids && uids->len == 1) {
+		DeleteNoteData *dnd;
+		EAlertSink *alert_sink;
+		EActivity *activity;
+		gchar *full_display_name;
+		gchar *real_uid = NULL;
+		const gchar *uid = uids->pdata[0];
+
+		if (mail_reader_replace_vee_folder_with_real (&folder, uid, &real_uid))
+			uid = real_uid;
+
+		dnd = g_slice_new0 (DeleteNoteData);
+		dnd->folder = g_object_ref (folder);
+		dnd->uid = g_strdup (uid);
+
+		full_display_name = e_mail_folder_to_full_display_name (folder, NULL);
+		alert_sink = e_mail_reader_get_alert_sink (reader);
+
+		activity = e_alert_sink_submit_thread_job (alert_sink,
+			_("Deleting message note…"),
+			"mail:failed-delete-note",
+			full_display_name ? full_display_name : camel_folder_get_full_name (folder),
+			mail_delete_note_thread, dnd, delete_note_data_free);
+
+		if (activity)
+			e_shell_backend_add_activity (E_SHELL_BACKEND (e_mail_reader_get_backend (reader)), activity);
+
+		g_clear_object (&activity);
+		g_free (full_display_name);
+		g_free (real_uid);
+	} else {
+		g_warn_if_reached ();
+	}
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_delete_cb (GtkAction *action,
+                       EMailReader *reader)
+{
+	guint32 mask = CAMEL_MESSAGE_SEEN | CAMEL_MESSAGE_DELETED;
+	guint32 set = CAMEL_MESSAGE_SEEN | CAMEL_MESSAGE_DELETED;
+
+	if (!e_mail_reader_confirm_delete (reader))
+		return;
+
+	/* FIXME Verify all selected messages are deletable.
+	 *       But handle it by disabling this action. */
+
+	if (e_mail_reader_mark_selected (reader, mask, set) != 0 &&
+	    !e_mail_reader_close_on_delete_or_junk (reader)) {
+		if (e_mail_reader_get_delete_selects_previous (reader))
+			e_mail_reader_select_previous_message (reader, FALSE);
+		else
+			e_mail_reader_select_next_message (reader, FALSE);
+	}
+}
+
+static void
+action_mail_filter_on_mailing_list_cb (GtkAction *action,
+                                       EMailReader *reader)
+{
+	e_mail_reader_create_filter_from_selected (reader, AUTO_MLIST);
+}
+
+static void
+action_mail_filter_on_recipients_cb (GtkAction *action,
+                                     EMailReader *reader)
+{
+	e_mail_reader_create_filter_from_selected (reader, AUTO_TO);
+}
+
+static void
+action_mail_filter_on_sender_cb (GtkAction *action,
+                                 EMailReader *reader)
+{
+	e_mail_reader_create_filter_from_selected (reader, AUTO_FROM);
+}
+
+static void
+action_mail_filter_on_subject_cb (GtkAction *action,
+                                  EMailReader *reader)
+{
+	e_mail_reader_create_filter_from_selected (reader, AUTO_SUBJECT);
+}
+
+static void
+action_mail_filters_apply_cb (GtkAction *action,
+                              EMailReader *reader)
+{
+	EMailBackend *backend;
+	EMailSession *session;
+	CamelFolder *folder;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	backend = e_mail_reader_get_backend (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+	session = e_mail_backend_get_session (backend);
+
+	mail_filter_folder (
+		session, folder, uids,
+		E_FILTER_SOURCE_DEMAND, FALSE);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_remove_attachments_cb (GtkAction *action,
+                                   EMailReader *reader)
+{
+	e_mail_reader_remove_attachments (reader);
+}
+
+static void
+action_mail_remove_duplicates_cb (GtkAction *action,
+                                  EMailReader *reader)
+{
+	e_mail_reader_remove_duplicates (reader);
+}
+
+static void
+action_mail_find_cb (GtkAction *action,
+                     EMailReader *reader)
+{
+	e_mail_reader_show_search_bar (reader);
+}
+
+static void
+action_mail_flag_clear_cb (GtkAction *action,
+                           EMailReader *reader)
+{
+	CamelFolder *folder;
+	GtkWindow *window;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+	window = e_mail_reader_get_window (reader);
+
+	em_utils_flag_for_followup_clear (window, folder, uids);
+
+	e_mail_reader_reload (reader);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_flag_completed_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	CamelFolder *folder;
+	GtkWindow *window;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+	window = e_mail_reader_get_window (reader);
+
+	em_utils_flag_for_followup_completed (window, folder, uids);
+
+	e_mail_reader_reload (reader);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_flag_for_followup_cb (GtkAction *action,
+                                  EMailReader *reader)
+{
+	CamelFolder *folder;
+	GPtrArray *uids;
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+	em_utils_flag_for_followup (reader, folder, uids);
+
+	e_mail_reader_reload (reader);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_forward_cb (GtkAction *action,
+                        EMailReader *reader)
+{
+	GtkWindow *window;
+	GPtrArray *uids;
+
+	window = e_mail_reader_get_window (reader);
+	uids = e_mail_reader_get_selected_uids (reader);
+	g_return_if_fail (uids != NULL);
+
+	if (em_utils_ask_open_many (window, uids->len)) {
+		CamelFolder *folder;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		e_mail_reader_forward_messages (
+			reader, folder, uids,
+			e_mail_reader_get_forward_style (reader));
+
+		g_clear_object (&folder);
+	}
+
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_forward_attached_cb (GtkAction *action,
+                                 EMailReader *reader)
+{
+	GtkWindow *window;
+	GPtrArray *uids;
+
+	window = e_mail_reader_get_window (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+	g_return_if_fail (uids != NULL);
+
+	if (em_utils_ask_open_many (window, uids->len)) {
+		CamelFolder *folder;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		e_mail_reader_forward_messages (
+			reader, folder, uids,
+			E_MAIL_FORWARD_STYLE_ATTACHED);
+
+		g_clear_object (&folder);
+	}
+
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_forward_inline_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	GtkWindow *window;
+	GPtrArray *uids;
+
+	window = e_mail_reader_get_window (reader);
+	uids = e_mail_reader_get_selected_uids (reader);
+	g_return_if_fail (uids != NULL);
+
+	if (em_utils_ask_open_many (window, uids->len)) {
+		CamelFolder *folder;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		e_mail_reader_forward_messages (
+			reader, folder, uids,
+			E_MAIL_FORWARD_STYLE_INLINE);
+
+		g_clear_object (&folder);
+	}
+
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_forward_quoted_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	GtkWindow *window;
+	GPtrArray *uids;
+
+	window = e_mail_reader_get_window (reader);
+	uids = e_mail_reader_get_selected_uids (reader);
+	g_return_if_fail (uids != NULL);
+
+	if (em_utils_ask_open_many (window, uids->len)) {
+		CamelFolder *folder;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		e_mail_reader_forward_messages (
+			reader, folder, uids,
+			E_MAIL_FORWARD_STYLE_QUOTED);
+
+		g_clear_object (&folder);
+	}
+
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_label_new_cb (GtkAction *action,
+                          EMailReader *reader)
+{
+	EMailLabelDialog *label_dialog;
+	EMailLabelListStore *label_store;
+	EMailBackend *backend;
+	EMailSession *session;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	GtkWidget *dialog;
+	GPtrArray *uids;
+	GdkColor label_color;
+	const gchar *label_name;
+	gchar *label_tag;
+	gint n_children;
+	guint ii;
+
+	dialog = e_mail_label_dialog_new (e_mail_reader_get_window (reader));
+
+	gtk_window_set_title (GTK_WINDOW (dialog), _("Add Label"));
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) != GTK_RESPONSE_OK)
+		goto exit;
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+	label_store = e_mail_ui_session_get_label_store (
+		E_MAIL_UI_SESSION (session));
+
+	label_dialog = E_MAIL_LABEL_DIALOG (dialog);
+	label_name = e_mail_label_dialog_get_label_name (label_dialog);
+	e_mail_label_dialog_get_label_color (label_dialog, &label_color);
+
+	e_mail_label_list_store_set (
+		label_store, NULL, label_name, &label_color);
+
+	/* XXX This is awkward.  We've added a new label to the list store
+	 *     but we don't have the new label's tag nor an iterator to use
+	 *     to fetch it.  We know the label was appended to the store,
+	 *     so we have to dig it out manually.  EMailLabelListStore API
+	 *     probably needs some rethinking. */
+	model = GTK_TREE_MODEL (label_store);
+	n_children = gtk_tree_model_iter_n_children (model, NULL);
+	g_warn_if_fail (gtk_tree_model_iter_nth_child (model, &iter, NULL, n_children - 1));
+	label_tag = e_mail_label_list_store_get_tag (label_store, &iter);
+
+	uids = e_mail_reader_get_selected_uids (reader);
+	if (uids) {
+		CamelFolder *folder;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		for (ii = 0; ii < uids->len; ii++) {
+			camel_folder_set_message_user_flag (
+				folder, uids->pdata[ii], label_tag, TRUE);
+		}
+
+		g_clear_object (&folder);
+		g_ptr_array_unref (uids);
+	}
+
+	g_free (label_tag);
+
+ exit:
+	gtk_widget_destroy (dialog);
+}
+
+static void
+action_mail_label_none_cb (GtkAction *action,
+                           EMailReader *reader)
+{
+	EMailBackend *backend;
+	EMailSession *session;
+	EMailLabelListStore *label_store;
+	CamelFolder *folder;
+	GtkTreeIter iter;
+	GPtrArray *uids;
+	gboolean valid;
+	guint ii;
+
+	uids = e_mail_reader_get_selected_uids (reader);
+	if (!uids)
+		return;
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+	label_store = e_mail_ui_session_get_label_store (
+		E_MAIL_UI_SESSION (session));
+
+	folder = e_mail_reader_ref_folder (reader);
+
+	valid = gtk_tree_model_get_iter_first (
+		GTK_TREE_MODEL (label_store), &iter);
+
+	while (valid) {
+		gchar *tag;
+
+		tag = e_mail_label_list_store_get_tag (label_store, &iter);
+
+		for (ii = 0; ii < uids->len; ii++) {
+			camel_folder_set_message_user_flag (
+				folder, uids->pdata[ii], tag, FALSE);
+			camel_folder_set_message_user_tag (
+				folder, uids->pdata[ii], "label", NULL);
+		}
+
+		g_free (tag);
+
+		valid = gtk_tree_model_iter_next (
+			GTK_TREE_MODEL (label_store), &iter);
+	}
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_load_images_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	EMailDisplay *display;
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	e_mail_display_load_images (display);
+}
+
+static void
+action_mail_mark_important_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	guint32 mask = CAMEL_MESSAGE_FLAGGED | CAMEL_MESSAGE_DELETED;
+	guint32 set = CAMEL_MESSAGE_FLAGGED;
+
+	e_mail_reader_mark_selected (reader, mask, set);
+}
+
+static void
+action_mail_mark_junk_cb (GtkAction *action,
+                          EMailReader *reader)
+{
+	guint32 mask =
+		CAMEL_MESSAGE_SEEN |
+		CAMEL_MESSAGE_JUNK |
+		CAMEL_MESSAGE_NOTJUNK |
+		CAMEL_MESSAGE_JUNK_LEARN;
+	guint32 set =
+		CAMEL_MESSAGE_SEEN |
+		CAMEL_MESSAGE_JUNK |
+		CAMEL_MESSAGE_JUNK_LEARN;
+
+	if (e_mail_reader_mark_selected (reader, mask, set) != 0 &&
+	    !e_mail_reader_close_on_delete_or_junk (reader)) {
+		if (e_mail_reader_get_delete_selects_previous (reader))
+			e_mail_reader_select_previous_message (reader, TRUE);
+		else
+			e_mail_reader_select_next_message (reader, TRUE);
+	}
+}
+
+static void
+action_mail_mark_notjunk_cb (GtkAction *action,
+                             EMailReader *reader)
+{
+	guint32 mask =
+		CAMEL_MESSAGE_JUNK |
+		CAMEL_MESSAGE_NOTJUNK |
+		CAMEL_MESSAGE_JUNK_LEARN;
+	guint32 set  =
+		CAMEL_MESSAGE_NOTJUNK |
+		CAMEL_MESSAGE_JUNK_LEARN;
+
+	if (e_mail_reader_mark_selected (reader, mask, set) != 0) {
+		if (e_mail_reader_get_delete_selects_previous (reader))
+			e_mail_reader_select_previous_message (reader, TRUE);
+		else
+			e_mail_reader_select_next_message (reader, TRUE);
+	}
+}
+
+static void
+action_mail_mark_read_cb (GtkAction *action,
+                          EMailReader *reader)
+{
+	guint32 mask = CAMEL_MESSAGE_SEEN;
+	guint32 set = CAMEL_MESSAGE_SEEN;
+
+	e_mail_reader_mark_selected (reader, mask, set);
+}
+
+static void
+action_mail_mark_unimportant_cb (GtkAction *action,
+                                 EMailReader *reader)
+{
+	guint32 mask = CAMEL_MESSAGE_FLAGGED;
+	guint32 set = 0;
+
+	e_mail_reader_mark_selected (reader, mask, set);
+}
+
+static void
+action_mail_mark_ignore_thread_sub_cb (GtkAction *action,
+					 EMailReader *reader)
+{
+	e_mail_reader_mark_selected_ignore_thread (reader, E_IGNORE_THREAD_SUBSET_SET);
+}
+
+static void
+action_mail_mark_unignore_thread_sub_cb (GtkAction *action,
+					 EMailReader *reader)
+{
+	e_mail_reader_mark_selected_ignore_thread (reader, E_IGNORE_THREAD_SUBSET_UNSET);
+}
+
+static void
+action_mail_mark_ignore_thread_whole_cb (GtkAction *action,
+					 EMailReader *reader)
+{
+	e_mail_reader_mark_selected_ignore_thread (reader, E_IGNORE_THREAD_WHOLE_SET);
+}
+
+static void
+action_mail_mark_unignore_thread_whole_cb (GtkAction *action,
+					   EMailReader *reader)
+{
+	e_mail_reader_mark_selected_ignore_thread (reader, E_IGNORE_THREAD_WHOLE_UNSET);
+}
+
+static void
+action_mail_mark_unread_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	GtkWidget *message_list;
+	EMFolderTreeModel *model;
+	CamelFolder *folder;
+	guint32 mask = CAMEL_MESSAGE_SEEN | CAMEL_MESSAGE_DELETED;
+	guint32 set = 0;
+	guint n_marked;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	n_marked = e_mail_reader_mark_selected (reader, mask, set);
+
+	if (MESSAGE_LIST (message_list)->seen_id != 0) {
+		g_source_remove (MESSAGE_LIST (message_list)->seen_id);
+		MESSAGE_LIST (message_list)->seen_id = 0;
+	}
+
+	folder = e_mail_reader_ref_folder (reader);
+
+	/* Notify the tree model that the user has marked messages as
+	 * unread so it doesn't mistake the event as new mail arriving. */
+	model = em_folder_tree_model_get_default ();
+	em_folder_tree_model_user_marked_unread (model, folder, n_marked);
+
+	g_clear_object (&folder);
+}
+
+static void
+action_mail_message_edit_cb (GtkAction *action,
+                             EMailReader *reader)
+{
+	EShell *shell;
+	EMailBackend *backend;
+	ESourceRegistry *registry;
+	CamelFolder *folder;
+	GPtrArray *uids;
+	gboolean replace;
+
+	uids = e_mail_reader_get_selected_uids (reader);
+	g_return_if_fail (uids != NULL);
+
+	backend = e_mail_reader_get_backend (reader);
+	shell = e_shell_backend_get_shell (E_SHELL_BACKEND (backend));
+	registry = e_shell_get_registry (shell);
+
+	folder = e_mail_reader_ref_folder (reader);
+	replace = em_utils_folder_is_drafts (registry, folder);
+	e_mail_reader_edit_messages (reader, folder, uids, replace, replace);
+	g_clear_object (&folder);
+
+	g_ptr_array_unref (uids);
+}
+
+typedef struct _CreateComposerData {
+	EMailReader *reader;
+	CamelMimeMessage *message;
+	CamelFolder *folder;
+	const gchar *message_uid; /* In the Camel string pool */
+	gboolean is_redirect;
+} CreateComposerData;
+
+static void
+mail_reader_new_composer_created_cb (GObject *source_object,
+				     GAsyncResult *result,
+				     gpointer user_data)
+{
+	CreateComposerData *ccd = user_data;
+	EMsgComposer *composer;
+	GError *error = NULL;
+
+	g_return_if_fail (ccd != NULL);
+
+	composer = e_msg_composer_new_finish (result, &error);
+	if (error) {
+		g_warning ("%s: Failed to create msg composer: %s", G_STRFUNC, error->message);
+		g_clear_error (&error);
+	} else {
+		if (ccd->is_redirect)
+			em_utils_redirect_message (composer, ccd->message);
+		else
+			em_utils_compose_new_message_with_selection (composer, ccd->folder, ccd->message_uid);
+
+		e_mail_reader_composer_created (ccd->reader, composer, ccd->message);
+	}
+
+	g_clear_object (&ccd->reader);
+	g_clear_object (&ccd->message);
+	g_clear_object (&ccd->folder);
+	camel_pstring_free (ccd->message_uid);
+	g_slice_free (CreateComposerData, ccd);
+}
+
+static void
+action_mail_message_new_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	EShell *shell;
+	EMailBackend *backend;
+	EShellBackend *shell_backend;
+	CamelFolder *folder;
+	CreateComposerData *ccd;
+	GPtrArray *selected_uids = NULL;
+	const gchar *selected_uid = NULL;
+
+	folder = e_mail_reader_ref_folder (reader);
+	backend = e_mail_reader_get_backend (reader);
+
+	selected_uids = e_mail_reader_get_selected_uids (reader);
+	if (selected_uids && selected_uids->len > 0)
+		selected_uid = g_ptr_array_index (selected_uids, 0);
+
+	if (!selected_uid) {
+		GtkWidget *message_list;
+
+		message_list = e_mail_reader_get_message_list (reader);
+		if (message_list)
+			selected_uid = MESSAGE_LIST (message_list)->cursor_uid;
+	}
+
+	shell_backend = E_SHELL_BACKEND (backend);
+	shell = e_shell_backend_get_shell (shell_backend);
+
+	ccd = g_slice_new0 (CreateComposerData);
+	ccd->reader = g_object_ref (reader);
+	ccd->folder = folder;
+	ccd->message_uid = camel_pstring_strdup (selected_uid);
+	ccd->is_redirect = FALSE;
+
+	e_msg_composer_new (shell, mail_reader_new_composer_created_cb, ccd);
+
+	if (selected_uids)
+		g_ptr_array_unref (selected_uids);
+}
+
+static void
+action_mail_message_open_cb (GtkAction *action,
+                             EMailReader *reader)
+{
+	e_mail_reader_open_selected_mail (reader);
+}
+
+static void
+action_mail_archive_cb (GtkAction *action,
+			EMailReader *reader)
+{
+	CamelFolder *folder;
+	EMailBackend *backend;
+	EMailSession *session;
+	GPtrArray *uids;
+	gchar *archive_folder;
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+	g_return_if_fail (uids != NULL);
+
+	folder = e_mail_reader_ref_folder (reader);
+	archive_folder = em_utils_get_archive_folder_uri_from_folder (folder, backend, uids, TRUE);
+
+	if (archive_folder != NULL)
+		mail_transfer_messages (
+			session, folder, uids,
+			TRUE, archive_folder, 0, NULL, NULL);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+	g_free (archive_folder);
+}
+
+static void
+action_mail_move_cb (GtkAction *action,
+                     EMailReader *reader)
+{
+	mail_reader_copy_or_move_selected_messages (reader, TRUE);
+}
+
+static void
+action_mail_next_cb (GtkAction *action,
+                     EMailReader *reader)
+{
+	GtkWidget *message_list;
+	MessageListSelectDirection direction;
+	guint32 flags, mask;
+
+	direction = MESSAGE_LIST_SELECT_NEXT;
+	flags = 0;
+	mask = 0;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select (
+		MESSAGE_LIST (message_list), direction, flags, mask);
+}
+
+static void
+action_mail_next_important_cb (GtkAction *action,
+                               EMailReader *reader)
+{
+	GtkWidget *message_list;
+	MessageListSelectDirection direction;
+	guint32 flags, mask;
+
+	direction = MESSAGE_LIST_SELECT_NEXT | MESSAGE_LIST_SELECT_WRAP;
+	flags = CAMEL_MESSAGE_FLAGGED;
+	mask = CAMEL_MESSAGE_FLAGGED;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select (
+		MESSAGE_LIST (message_list), direction, flags, mask);
+}
+
+static void
+action_mail_next_thread_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	GtkWidget *message_list;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select_next_thread (MESSAGE_LIST (message_list));
+}
+
+static void
+mail_reader_select_unread (EMailReader *reader,
+			   gboolean move_forward)
+{
+	GtkWidget *message_list;
+	MessageListSelectDirection direction;
+	guint32 flags, mask;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	direction = (move_forward ? MESSAGE_LIST_SELECT_NEXT : MESSAGE_LIST_SELECT_PREVIOUS) |
+		    MESSAGE_LIST_SELECT_WRAP | MESSAGE_LIST_SELECT_INCLUDE_COLLAPSED;
+	flags = 0;
+	mask = CAMEL_MESSAGE_SEEN;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	if (!message_list_select (MESSAGE_LIST (message_list), direction, flags, mask)) {
+		GtkWindow *window;
+
+		window = e_mail_reader_get_window (reader);
+		if (E_IS_SHELL_WINDOW (window)) {
+			EShellWindow *shell_window;
+			EMFolderTree *folder_tree = NULL;
+			const gchar *active_view;
+
+			shell_window = E_SHELL_WINDOW (window);
+			active_view = e_shell_window_get_active_view (shell_window);
+
+			if (g_strcmp0 (active_view, "mail") == 0) {
+				EShellView *shell_view;
+				EShellSidebar *shell_sidebar;
+
+				shell_view = e_shell_window_get_shell_view (shell_window, "mail");
+				shell_sidebar = e_shell_view_get_shell_sidebar (shell_view);
+				g_object_get (shell_sidebar, "folder-tree", &folder_tree, NULL);
+
+				if (folder_tree) {
+					gboolean selected;
+
+					if (move_forward)
+						selected = em_folder_tree_select_next_path (folder_tree, TRUE);
+					else
+						selected = em_folder_tree_select_prev_path (folder_tree, TRUE);
+
+					if (selected)
+						message_list_set_regen_selects_unread (MESSAGE_LIST (message_list), TRUE);
+				}
+
+				g_clear_object (&folder_tree);
+			}
+		}
+	}
+}
+
+static void
+action_mail_next_unread_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	mail_reader_select_unread (reader, TRUE);
+}
+
+static void
+action_mail_previous_cb (GtkAction *action,
+                         EMailReader *reader)
+{
+	GtkWidget *message_list;
+	MessageListSelectDirection direction;
+	guint32 flags, mask;
+
+	direction = MESSAGE_LIST_SELECT_PREVIOUS;
+	flags = 0;
+	mask = 0;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select (
+		MESSAGE_LIST (message_list), direction, flags, mask);
+}
+
+static void
+action_mail_previous_important_cb (GtkAction *action,
+                                   EMailReader *reader)
+{
+	GtkWidget *message_list;
+	MessageListSelectDirection direction;
+	guint32 flags, mask;
+
+	direction = MESSAGE_LIST_SELECT_PREVIOUS | MESSAGE_LIST_SELECT_WRAP;
+	flags = CAMEL_MESSAGE_FLAGGED;
+	mask = CAMEL_MESSAGE_FLAGGED;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select (
+		MESSAGE_LIST (message_list), direction, flags, mask);
+}
+
+static void
+action_mail_previous_thread_cb (GtkAction *action,
+                                EMailReader *reader)
+{
+	GtkWidget *message_list;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select_prev_thread (MESSAGE_LIST (message_list));
+}
+
+static void
+action_mail_previous_unread_cb (GtkAction *action,
+                                EMailReader *reader)
+{
+	mail_reader_select_unread (reader, FALSE);
+}
+
+static void
+action_mail_print_cb (GtkAction *action,
+                      EMailReader *reader)
+{
+	GtkPrintOperationAction print_action;
+
+	print_action = GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG;
+	e_mail_reader_print (reader, print_action);
+}
+
+static void
+action_mail_print_preview_cb (GtkAction *action,
+                              EMailReader *reader)
+{
+	GtkPrintOperationAction print_action;
+
+	print_action = GTK_PRINT_OPERATION_ACTION_PREVIEW;
+	e_mail_reader_print (reader, print_action);
+}
+
+static void
+mail_reader_redirect_cb (CamelFolder *folder,
+                         GAsyncResult *result,
+                         EMailReaderClosure *closure)
+{
+	EShell *shell;
+	EMailBackend *backend;
+	EAlertSink *alert_sink;
+	CamelMimeMessage *message;
+	CreateComposerData *ccd;
+	GError *error = NULL;
+
+	alert_sink = e_activity_get_alert_sink (closure->activity);
+
+	message = camel_folder_get_message_finish (folder, result, &error);
+
+	if (e_activity_handle_cancellation (closure->activity, error)) {
+		g_warn_if_fail (message == NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (error);
+		return;
+
+	} else if (error != NULL) {
+		g_warn_if_fail (message == NULL);
+		e_alert_submit (
+			alert_sink, "mail:no-retrieve-message",
+			error->message, NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (error);
+		return;
+	}
+
+	g_return_if_fail (CAMEL_IS_MIME_MESSAGE (message));
+
+	backend = e_mail_reader_get_backend (closure->reader);
+	shell = e_shell_backend_get_shell (E_SHELL_BACKEND (backend));
+
+	ccd = g_slice_new0 (CreateComposerData);
+	ccd->reader = g_object_ref (closure->reader);
+	ccd->message = message;
+	ccd->message_uid = camel_pstring_strdup (closure->message_uid);
+	ccd->is_redirect = TRUE;
+
+	e_msg_composer_new (shell, mail_reader_new_composer_created_cb, ccd);
+
+	mail_reader_closure_free (closure);
+}
+
+static void
+action_mail_redirect_cb (GtkAction *action,
+                         EMailReader *reader)
+{
+	EActivity *activity;
+	GCancellable *cancellable;
+	EMailReaderClosure *closure;
+	GtkWidget *message_list;
+	CamelFolder *folder;
+	const gchar *message_uid;
+
+	message_list = e_mail_reader_get_message_list (reader);
+	message_uid = MESSAGE_LIST (message_list)->cursor_uid;
+	g_return_if_fail (message_uid != NULL);
+
+	/* Open the message asynchronously. */
+
+	activity = e_mail_reader_new_activity (reader);
+	cancellable = e_activity_get_cancellable (activity);
+
+	closure = g_slice_new0 (EMailReaderClosure);
+	closure->activity = activity;
+	closure->reader = g_object_ref (reader);
+	closure->message_uid = g_strdup (message_uid);
+
+	folder = e_mail_reader_ref_folder (reader);
+
+	camel_folder_get_message (
+		folder, message_uid, G_PRIORITY_DEFAULT,
+		cancellable, (GAsyncReadyCallback)
+		mail_reader_redirect_cb, closure);
+
+	g_clear_object (&folder);
+}
+
+static void
+action_mail_reply_all_check (CamelFolder *folder,
+                             GAsyncResult *result,
+                             EMailReaderClosure *closure)
+{
+	EAlertSink *alert_sink;
+	CamelMimeMessage *message;
+	CamelInternetAddress *to, *cc;
+	gint recip_count = 0;
+	EMailReplyType type = E_MAIL_REPLY_TO_ALL;
+	GError *error = NULL;
+
+	alert_sink = e_activity_get_alert_sink (closure->activity);
+
+	message = camel_folder_get_message_finish (folder, result, &error);
+
+	if (e_activity_handle_cancellation (closure->activity, error)) {
+		g_warn_if_fail (message == NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (error);
+		return;
+
+	} else if (error != NULL) {
+		g_warn_if_fail (message == NULL);
+		e_alert_submit (
+			alert_sink, "mail:no-retrieve-message",
+			error->message, NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (error);
+		return;
+	}
+
+	g_return_if_fail (CAMEL_IS_MIME_MESSAGE (message));
+
+	to = camel_mime_message_get_recipients (
+		message, CAMEL_RECIPIENT_TYPE_TO);
+	cc = camel_mime_message_get_recipients (
+		message, CAMEL_RECIPIENT_TYPE_CC);
+
+	recip_count = camel_address_length (CAMEL_ADDRESS (to));
+	recip_count += camel_address_length (CAMEL_ADDRESS (cc));
+
+	if (recip_count >= 15) {
+		GtkWidget *dialog;
+		GtkWidget *check;
+		GtkWidget *container;
+		gint response;
+
+		dialog = e_alert_dialog_new_for_args (
+			e_mail_reader_get_window (closure->reader),
+			"mail:ask-reply-many-recips", NULL);
+
+		container = e_alert_dialog_get_content_area (
+			E_ALERT_DIALOG (dialog));
+
+		/* Check buttons */
+		check = gtk_check_button_new_with_mnemonic (
+			_("_Do not ask me again."));
+		gtk_box_pack_start (
+			GTK_BOX (container), check, FALSE, FALSE, 0);
+		gtk_widget_show (check);
+
+		response = gtk_dialog_run (GTK_DIALOG (dialog));
+
+		if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check))) {
+			GSettings *settings;
+			const gchar *key;
+
+			settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+			key = "prompt-on-reply-many-recips";
+			g_settings_set_boolean (settings, key, FALSE);
+
+			g_object_unref (settings);
+		}
+
+		gtk_widget_destroy (dialog);
+
+		switch (response) {
+			case GTK_RESPONSE_NO:
+				type = E_MAIL_REPLY_TO_SENDER;
+				break;
+			case GTK_RESPONSE_CANCEL:
+			case GTK_RESPONSE_DELETE_EVENT:
+				goto exit;
+			default:
+				break;
+		}
+	}
+
+	e_mail_reader_reply_to_message (closure->reader, message, type);
+
+exit:
+	g_object_unref (message);
+
+	mail_reader_closure_free (closure);
+}
+
+static void
+action_mail_reply_all_cb (GtkAction *action,
+                          EMailReader *reader)
+{
+	GSettings *settings;
+	const gchar *key;
+	guint32 state;
+	gboolean ask;
+
+	state = e_mail_reader_check_state (reader);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	key = "prompt-on-reply-many-recips";
+	ask = g_settings_get_boolean (settings, key);
+
+	g_object_unref (settings);
+
+	if (ask && !(state & E_MAIL_READER_SELECTION_IS_MAILING_LIST)) {
+		EActivity *activity;
+		GCancellable *cancellable;
+		EMailReaderClosure *closure;
+		CamelFolder *folder;
+		GtkWidget *message_list;
+		const gchar *message_uid;
+
+		message_list = e_mail_reader_get_message_list (reader);
+		message_uid = MESSAGE_LIST (message_list)->cursor_uid;
+		g_return_if_fail (message_uid != NULL);
+
+		activity = e_mail_reader_new_activity (reader);
+		cancellable = e_activity_get_cancellable (activity);
+
+		closure = g_slice_new0 (EMailReaderClosure);
+		closure->activity = activity;
+		closure->reader = g_object_ref (reader);
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		camel_folder_get_message (
+			folder, message_uid, G_PRIORITY_DEFAULT,
+			cancellable, (GAsyncReadyCallback)
+			action_mail_reply_all_check, closure);
+
+		g_clear_object (&folder);
+
+		return;
+	}
+
+	e_mail_reader_reply_to_message (reader, NULL, E_MAIL_REPLY_TO_ALL);
+}
+
+static void
+action_mail_reply_alternative_got_message (GObject *source_object,
+					   GAsyncResult *result,
+					   gpointer user_data)
+{
+	EMailReaderClosure *closure = user_data;
+	EAlertSink *alert_sink;
+	CamelMimeMessage *message;
+	gboolean is_selection;
+	CamelFolder *folder = NULL;
+	const gchar *message_uid = NULL;
+	EMailPartList *part_list = NULL;
+	EMailPartValidityFlags validity_pgp_sum = 0;
+	EMailPartValidityFlags validity_smime_sum = 0;
+	GError *error = NULL;
+
+	alert_sink = e_activity_get_alert_sink (closure->activity);
+
+	message = e_mail_reader_utils_get_selection_or_message_finish (E_MAIL_READER (source_object), result,
+			&is_selection, &folder, &message_uid, &part_list, &validity_pgp_sum, &validity_smime_sum, &error);
+
+	if (e_activity_handle_cancellation (closure->activity, error)) {
+		g_warn_if_fail (message == NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (error);
+		return;
+
+	} else if (error != NULL) {
+		g_warn_if_fail (message == NULL);
+		e_alert_submit (
+			alert_sink, "mail:no-retrieve-message",
+			error->message, NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (error);
+		return;
+	}
+
+	g_return_if_fail (CAMEL_IS_MIME_MESSAGE (message));
+
+	g_clear_object (&closure->activity);
+
+	em_utils_reply_alternative (e_mail_reader_get_window (closure->reader),
+		e_shell_backend_get_shell (E_SHELL_BACKEND (e_mail_reader_get_backend (closure->reader))),
+		alert_sink, message, folder, message_uid,
+		e_mail_reader_get_reply_style (closure->reader),
+		is_selection ? NULL : part_list, validity_pgp_sum, validity_smime_sum);
+
+	mail_reader_closure_free (closure);
+	camel_pstring_free (message_uid);
+	g_clear_object (&message);
+	g_clear_object (&folder);
+	g_clear_object (&part_list);
+	g_clear_error (&error);
+}
+
+static void
+action_mail_reply_alternative_cb (GtkAction *action,
+				  EMailReader *reader)
+{
+	EActivity *activity;
+	GCancellable *cancellable;
+	EMailReaderClosure *closure;
+	GtkWidget *message_list;
+	const gchar *message_uid;
+
+	message_list = e_mail_reader_get_message_list (reader);
+	message_uid = MESSAGE_LIST (message_list)->cursor_uid;
+	g_return_if_fail (message_uid != NULL);
+
+	activity = e_mail_reader_new_activity (reader);
+	cancellable = e_activity_get_cancellable (activity);
+
+	closure = g_slice_new0 (EMailReaderClosure);
+	closure->activity = activity;
+	closure->reader = g_object_ref (reader);
+
+	e_mail_reader_utils_get_selection_or_message (reader, NULL, cancellable,
+		action_mail_reply_alternative_got_message, closure);
+}
+
+static void
+action_mail_reply_group_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	GSettings *settings;
+	gboolean reply_list;
+	guint32 state;
+	const gchar *key;
+
+	state = e_mail_reader_check_state (reader);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	key = "composer-group-reply-to-list";
+	reply_list = g_settings_get_boolean (settings, key);
+
+	g_object_unref (settings);
+
+	if (reply_list && (state & E_MAIL_READER_SELECTION_IS_MAILING_LIST)) {
+		e_mail_reader_reply_to_message (
+			reader, NULL, E_MAIL_REPLY_TO_LIST);
+	} else
+		action_mail_reply_all_cb (action, reader);
+}
+
+static void
+action_mail_reply_list_cb (GtkAction *action,
+                           EMailReader *reader)
+{
+	e_mail_reader_reply_to_message (reader, NULL, E_MAIL_REPLY_TO_LIST);
+}
+
+static gboolean
+message_is_list_administrative (CamelMimeMessage *message)
+{
+	const gchar *header;
+
+	header = camel_medium_get_header (
+		CAMEL_MEDIUM (message), "X-List-Administrivia");
+	if (header == NULL)
+		return FALSE;
+
+	while (*header == ' ' || *header == '\t')
+		header++;
+
+	return g_ascii_strncasecmp (header, "yes", 3) == 0;
+}
+
+static void
+action_mail_reply_sender_check (CamelFolder *folder,
+                                GAsyncResult *result,
+                                EMailReaderClosure *closure)
+{
+	EAlertSink *alert_sink;
+	CamelMimeMessage *message;
+	EMailReplyType type = E_MAIL_REPLY_TO_SENDER;
+	GSettings *settings;
+	gboolean ask_ignore_list_reply_to;
+	gboolean ask_list_reply_to;
+	gboolean munged_list_message;
+	gboolean active;
+	const gchar *key;
+	GError *local_error = NULL;
+
+	alert_sink = e_activity_get_alert_sink (closure->activity);
+
+	message = camel_folder_get_message_finish (
+		folder, result, &local_error);
+
+	/* Sanity check. */
+	g_return_if_fail (
+		((message != NULL) && (local_error == NULL)) ||
+		((message == NULL) && (local_error != NULL)));
+
+	if (e_activity_handle_cancellation (closure->activity, local_error)) {
+		mail_reader_closure_free (closure);
+		g_error_free (local_error);
+		return;
+
+	} else if (local_error != NULL) {
+		e_alert_submit (
+			alert_sink, "mail:no-retrieve-message",
+			local_error->message, NULL);
+		mail_reader_closure_free (closure);
+		g_error_free (local_error);
+		return;
+	}
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	key = "composer-ignore-list-reply-to";
+	ask_ignore_list_reply_to = g_settings_get_boolean (settings, key);
+
+	key = "prompt-on-list-reply-to";
+	ask_list_reply_to = g_settings_get_boolean (settings, key);
+
+	munged_list_message = em_utils_is_munged_list_message (message);
+
+	if (message_is_list_administrative (message)) {
+		/* Do not ask for messages which are list administrative,
+		 * like list confirmation messages. */
+	} else if (ask_ignore_list_reply_to || !munged_list_message) {
+		/* Don't do the "Are you sure you want to reply in private?"
+		 * pop-up if it's a Reply-To: munged list message... unless
+		 * we're ignoring munging. */
+		GtkWidget *dialog;
+		GtkWidget *check;
+		GtkWidget *container;
+		gint response;
+
+		dialog = e_alert_dialog_new_for_args (
+			e_mail_reader_get_window (closure->reader),
+			"mail:ask-list-private-reply", NULL);
+
+		container = e_alert_dialog_get_content_area (
+			E_ALERT_DIALOG (dialog));
+
+		/* Check buttons */
+		check = gtk_check_button_new_with_mnemonic (
+			_("_Do not ask me again."));
+		gtk_box_pack_start (
+			GTK_BOX (container), check, FALSE, FALSE, 0);
+		gtk_widget_show (check);
+
+		response = gtk_dialog_run (GTK_DIALOG (dialog));
+
+		active = gtk_toggle_button_get_active (
+			GTK_TOGGLE_BUTTON (check));
+		if (active) {
+			key = "prompt-on-private-list-reply";
+			g_settings_set_boolean (settings, key, FALSE);
+		}
+
+		gtk_widget_destroy (dialog);
+
+		if (response == GTK_RESPONSE_YES)
+			type = E_MAIL_REPLY_TO_ALL;
+		else if (response == GTK_RESPONSE_OK)
+			type = E_MAIL_REPLY_TO_LIST;
+		else if (response == GTK_RESPONSE_CANCEL ||
+			response == GTK_RESPONSE_DELETE_EVENT) {
+			goto exit;
+		}
+
+	} else if (ask_list_reply_to) {
+		GtkWidget *dialog;
+		GtkWidget *container;
+		GtkWidget *check_again;
+		GtkWidget *check_always_ignore;
+		gint response;
+
+		dialog = e_alert_dialog_new_for_args (
+			e_mail_reader_get_window (closure->reader),
+			"mail:ask-list-honour-reply-to", NULL);
+
+		container = e_alert_dialog_get_content_area (
+			E_ALERT_DIALOG (dialog));
+
+		check_again = gtk_check_button_new_with_mnemonic (
+			_("_Do not ask me again."));
+		gtk_box_pack_start (
+			GTK_BOX (container), check_again, FALSE, FALSE, 0);
+		gtk_widget_show (check_again);
+
+		check_always_ignore = gtk_check_button_new_with_mnemonic (
+			_("_Always ignore Reply-To: for mailing lists."));
+		gtk_box_pack_start (
+			GTK_BOX (container), check_always_ignore,
+			FALSE, FALSE, 0);
+		gtk_widget_show (check_always_ignore);
+
+		response = gtk_dialog_run (GTK_DIALOG (dialog));
+
+		active = gtk_toggle_button_get_active (
+			GTK_TOGGLE_BUTTON (check_again));
+		if (active) {
+			key = "prompt-on-list-reply-to";
+			g_settings_set_boolean (settings, key, FALSE);
+		}
+
+		key = "composer-ignore-list-reply-to";
+		active = gtk_toggle_button_get_active (
+			GTK_TOGGLE_BUTTON (check_always_ignore));
+		g_settings_set_boolean (settings, key, active);
+
+		gtk_widget_destroy (dialog);
+
+		switch (response) {
+			case GTK_RESPONSE_NO:
+				type = E_MAIL_REPLY_TO_FROM;
+				break;
+			case GTK_RESPONSE_OK:
+				type = E_MAIL_REPLY_TO_LIST;
+				break;
+			case GTK_RESPONSE_CANCEL:
+			case GTK_RESPONSE_DELETE_EVENT:
+				goto exit;
+			default:
+				break;
+		}
+	}
+
+	e_mail_reader_reply_to_message (closure->reader, message, type);
+
+exit:
+	g_object_unref (settings);
+	g_object_unref (message);
+
+	mail_reader_closure_free (closure);
+}
+
+static void
+action_mail_reply_sender_cb (GtkAction *action,
+                             EMailReader *reader)
+{
+	GSettings *settings;
+	gboolean ask_list_reply_to;
+	gboolean ask_private_list_reply;
+	gboolean ask;
+	guint32 state;
+	const gchar *key;
+
+	state = e_mail_reader_check_state (reader);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	key = "prompt-on-list-reply-to";
+	ask_list_reply_to = g_settings_get_boolean (settings, key);
+
+	key = "prompt-on-private-list-reply";
+	ask_private_list_reply = g_settings_get_boolean (settings, key);
+
+	g_object_unref (settings);
+
+	ask = (ask_private_list_reply || ask_list_reply_to);
+
+	if (ask && (state & E_MAIL_READER_SELECTION_IS_MAILING_LIST)) {
+		EActivity *activity;
+		GCancellable *cancellable;
+		EMailReaderClosure *closure;
+		CamelFolder *folder;
+		GtkWidget *message_list;
+		const gchar *message_uid;
+
+		message_list = e_mail_reader_get_message_list (reader);
+		message_uid = MESSAGE_LIST (message_list)->cursor_uid;
+		g_return_if_fail (message_uid != NULL);
+
+		activity = e_mail_reader_new_activity (reader);
+		cancellable = e_activity_get_cancellable (activity);
+
+		closure = g_slice_new0 (EMailReaderClosure);
+		closure->activity = activity;
+		closure->reader = g_object_ref (reader);
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		camel_folder_get_message (
+			folder, message_uid, G_PRIORITY_DEFAULT,
+			cancellable, (GAsyncReadyCallback)
+			action_mail_reply_sender_check, closure);
+
+		g_clear_object (&folder);
+
+		return;
+	}
+
+	e_mail_reader_reply_to_message (reader, NULL, E_MAIL_REPLY_TO_SENDER);
+}
+
+static void
+action_mail_reply_recipient_cb (GtkAction *action,
+                                EMailReader *reader)
+{
+	e_mail_reader_reply_to_message (reader, NULL, E_MAIL_REPLY_TO_RECIPIENT);
+}
+
+static void
+action_mail_save_as_cb (GtkAction *action,
+                        EMailReader *reader)
+{
+	e_mail_reader_save_messages (reader);
+}
+
+static void
+action_mail_search_folder_from_mailing_list_cb (GtkAction *action,
+                                                EMailReader *reader)
+{
+	e_mail_reader_create_vfolder_from_selected (reader, AUTO_MLIST);
+}
+
+static void
+action_mail_search_folder_from_recipients_cb (GtkAction *action,
+                                              EMailReader *reader)
+{
+	e_mail_reader_create_vfolder_from_selected (reader, AUTO_TO);
+}
+
+static void
+action_mail_search_folder_from_sender_cb (GtkAction *action,
+                                          EMailReader *reader)
+{
+	e_mail_reader_create_vfolder_from_selected (reader, AUTO_FROM);
+}
+
+static void
+action_mail_search_folder_from_subject_cb (GtkAction *action,
+                                           EMailReader *reader)
+{
+	e_mail_reader_create_vfolder_from_selected (reader, AUTO_SUBJECT);
+}
+
+static void
+action_mail_show_all_headers_cb (GtkToggleAction *action,
+                                 EMailReader *reader)
+{
+	EMailDisplay *display;
+	EMailFormatterMode mode;
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	/* Ignore action when viewing message source. */
+	mode = e_mail_display_get_mode (display);
+	if (mode == E_MAIL_FORMATTER_MODE_SOURCE)
+		return;
+	if (mode == E_MAIL_FORMATTER_MODE_RAW)
+		return;
+
+	if (gtk_toggle_action_get_active (action))
+		mode = E_MAIL_FORMATTER_MODE_ALL_HEADERS;
+	else
+		mode = E_MAIL_FORMATTER_MODE_NORMAL;
+
+	e_mail_display_set_mode (display, mode);
+}
+
+static void
+mail_source_retrieved (GObject *source_object,
+                       GAsyncResult *result,
+                       gpointer user_data)
+{
+	EMailReaderClosure *closure;
+	CamelMimeMessage *message;
+	EMailDisplay *display;
+	GError *error = NULL;
+
+	closure = (EMailReaderClosure *) user_data;
+	display = e_mail_reader_get_mail_display (closure->reader);
+
+	message = camel_folder_get_message_finish (
+		CAMEL_FOLDER (source_object), result, &error);
+
+	/* Sanity check. */
+	g_return_if_fail (
+		((message != NULL) && (error == NULL)) ||
+		((message == NULL) && (error != NULL)));
+
+	if (message != NULL) {
+		mail_reader_set_display_formatter_for_message (
+			closure->reader, display,
+			closure->message_uid, message,
+			CAMEL_FOLDER (source_object));
+		g_object_unref (message);
+	} else if (error) {
+		if (display) {
+			gchar *status;
+
+			status = g_strdup_printf (
+				"%s<br>%s",
+				_("Failed to retrieve message:"),
+				error->message);
+			e_mail_display_set_status (display, status);
+			g_free (status);
+		}
+
+		g_error_free (error);
+	}
+
+	e_activity_set_state (closure->activity, E_ACTIVITY_COMPLETED);
+
+	mail_reader_closure_free (closure);
+}
+
+static void
+action_mail_show_source_cb (GtkAction *action,
+                            EMailReader *reader)
+{
+	EMailDisplay *display;
+	EMailBackend *backend;
+	GtkWidget *browser;
+	CamelFolder *folder;
+	GPtrArray *uids;
+	const gchar *message_uid;
+	gchar *string;
+	EActivity *activity;
+	GCancellable *cancellable;
+	EMailReaderClosure *closure;
+	MessageList *ml;
+
+	backend = e_mail_reader_get_backend (reader);
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids (reader);
+	g_return_if_fail (uids != NULL && uids->len == 1);
+	message_uid = g_ptr_array_index (uids, 0);
+
+	if (!E_IS_MAIL_BROWSER (e_mail_reader_get_window (reader))) {
+		EMailBrowser *mail_browser;
+
+		mail_browser = em_utils_find_message_window (E_MAIL_FORMATTER_MODE_SOURCE, folder, message_uid);
+
+		if (mail_browser) {
+			gtk_window_present (GTK_WINDOW (mail_browser));
+			g_ptr_array_unref (uids);
+			g_clear_object (&folder);
+			return;
+		}
+	}
+
+	browser = e_mail_browser_new (backend, E_MAIL_FORMATTER_MODE_SOURCE);
+	ml = MESSAGE_LIST (e_mail_reader_get_message_list (E_MAIL_READER (browser)));
+
+	message_list_freeze (ml);
+	e_mail_reader_set_folder (E_MAIL_READER (browser), folder);
+	e_mail_reader_set_message (E_MAIL_READER (browser), message_uid);
+	message_list_thaw (ml);
+
+	display = e_mail_reader_get_mail_display (E_MAIL_READER (browser));
+
+	string = g_strdup_printf (_("Retrieving message “%s”"), message_uid);
+	e_mail_display_set_part_list (display, NULL);
+	e_mail_display_set_status (display, string);
+	gtk_widget_show (browser);
+
+	activity = e_mail_reader_new_activity (E_MAIL_READER (browser));
+	e_activity_set_text (activity, string);
+	cancellable = e_activity_get_cancellable (activity);
+	g_free (string);
+
+	closure = g_slice_new0 (EMailReaderClosure);
+	closure->reader = E_MAIL_READER (g_object_ref (browser));
+	closure->activity = g_object_ref (activity);
+	closure->message_uid = g_strdup (message_uid);
+
+	camel_folder_get_message (
+		folder, message_uid, G_PRIORITY_DEFAULT,
+		cancellable, mail_source_retrieved, closure);
+
+	g_object_unref (activity);
+
+	g_ptr_array_unref (uids);
+
+	g_clear_object (&folder);
+}
+
+static void
+action_mail_toggle_important_cb (GtkAction *action,
+                                 EMailReader *reader)
+{
+	CamelFolder *folder;
+	GPtrArray *uids;
+	guint ii;
+
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+	if (!uids)
+		return;
+
+	folder = e_mail_reader_ref_folder (reader);
+
+	camel_folder_freeze (folder);
+
+	for (ii = 0; ii < uids->len; ii++) {
+		guint32 flags;
+
+		flags = camel_folder_get_message_flags (
+			folder, uids->pdata[ii]);
+		flags ^= CAMEL_MESSAGE_FLAGGED;
+		if (flags & CAMEL_MESSAGE_FLAGGED)
+			flags &= ~CAMEL_MESSAGE_DELETED;
+
+		camel_folder_set_message_flags (
+			folder, uids->pdata[ii], CAMEL_MESSAGE_FLAGGED |
+			CAMEL_MESSAGE_DELETED, flags);
+	}
+
+	camel_folder_thaw (folder);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+static void
+action_mail_undelete_cb (GtkAction *action,
+                         EMailReader *reader)
+{
+	guint32 mask = CAMEL_MESSAGE_DELETED;
+	guint32 set = 0;
+
+	e_mail_reader_mark_selected (reader, mask, set);
+}
+
+static void
+action_mail_zoom_100_cb (GtkAction *action,
+                         EMailReader *reader)
+{
+	EMailDisplay *display;
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	e_web_view_zoom_100 (E_WEB_VIEW (display));
+}
+
+static void
+action_mail_zoom_in_cb (GtkAction *action,
+                        EMailReader *reader)
+{
+	EMailDisplay *display;
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	e_web_view_zoom_in (E_WEB_VIEW (display));
+}
+
+static void
+action_mail_zoom_out_cb (GtkAction *action,
+                         EMailReader *reader)
+{
+	EMailDisplay *display;
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	e_web_view_zoom_out (E_WEB_VIEW (display));
+}
+
+static void
+action_mail_search_web_cb (GtkAction *action,
+			   EMailReader *reader)
+{
+	EMailDisplay *display;
+	GtkAction *wv_action;
+
+	display = e_mail_reader_get_mail_display (reader);
+	wv_action = e_web_view_get_action (E_WEB_VIEW (display), "search-web");
+
+	gtk_action_activate (wv_action);
+}
+
+static void
+action_search_folder_recipient_cb (GtkAction *action,
+                                   EMailReader *reader)
+{
+	EMailBackend *backend;
+	EMailSession *session;
+	EWebView *web_view;
+	CamelURL *curl;
+	const gchar *uri;
+
+	/* This action is defined in EMailDisplay. */
+
+	web_view = E_WEB_VIEW (e_mail_reader_get_mail_display (reader));
+
+	uri = e_web_view_get_selected_uri (web_view);
+	g_return_if_fail (uri != NULL);
+
+	curl = camel_url_new (uri, NULL);
+	g_return_if_fail (curl != NULL);
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+
+	if (curl->path != NULL && *curl->path != '\0') {
+		CamelFolder *folder;
+		CamelInternetAddress *inet_addr;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		inet_addr = camel_internet_address_new ();
+		camel_address_decode (CAMEL_ADDRESS (inet_addr), curl->path);
+		vfolder_gui_add_from_address (
+			session, inet_addr, AUTO_TO, folder);
+		g_object_unref (inet_addr);
+
+		g_clear_object (&folder);
+	}
+
+	camel_url_free (curl);
+}
+
+static void
+action_search_folder_sender_cb (GtkAction *action,
+                                EMailReader *reader)
+{
+	EMailBackend *backend;
+	EMailSession *session;
+	EWebView *web_view;
+	CamelURL *curl;
+	const gchar *uri;
+
+	/* This action is defined in EMailDisplay. */
+
+	web_view = E_WEB_VIEW (e_mail_reader_get_mail_display (reader));
+
+	uri = e_web_view_get_selected_uri (web_view);
+	g_return_if_fail (uri != NULL);
+
+	curl = camel_url_new (uri, NULL);
+	g_return_if_fail (curl != NULL);
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+
+	if (curl->path != NULL && *curl->path != '\0') {
+		CamelFolder *folder;
+		CamelInternetAddress *inet_addr;
+
+		folder = e_mail_reader_ref_folder (reader);
+
+		inet_addr = camel_internet_address_new ();
+		camel_address_decode (CAMEL_ADDRESS (inet_addr), curl->path);
+		vfolder_gui_add_from_address (
+			session, inet_addr, AUTO_FROM, folder);
+		g_object_unref (inet_addr);
+
+		g_clear_object (&folder);
+	}
+
+	camel_url_free (curl);
+}
+
+static GtkActionEntry mail_reader_entries[] = {
+
+	{ "mail-add-sender",
+	  NULL,
+	  N_("A_dd Sender to Address Book"),
+	  NULL,
+	  N_("Add sender to address book"),
+	  G_CALLBACK (action_mail_add_sender_cb) },
+
+	{ "mail-archive",
+	  "mail-archive",
+	  N_("_Archive…"),
+	  "<Alt><Control>a",
+	  N_("Move selected messages to the Archive folder for the account"),
+	  G_CALLBACK (action_mail_archive_cb) },
+
+	{ "mail-check-for-junk",
+	  "mail-mark-junk",
+	  N_("Check for _Junk"),
+	  "<Control><Alt>j",
+	  N_("Filter the selected messages for junk status"),
+	  G_CALLBACK (action_mail_check_for_junk_cb) },
+
+	{ "mail-color-assign",
+	  NULL,
+	  N_("Assign C_olor…"),
+	  NULL,
+	  N_("Assign color for the selected messages"),
+	  G_CALLBACK (action_mail_color_assign_cb) },
+
+	{ "mail-color-unset",
+	  NULL,
+	  N_("Unse_t Color"),
+	  NULL,
+	  N_("Unset color for the selected messages"),
+	  G_CALLBACK (action_mail_color_unset_cb) },
+
+	{ "mail-copy",
+	  "mail-copy",
+	  N_("_Copy to Folder…"),
+	  "<Shift><Control>y",
+	  N_("Copy selected messages to another folder"),
+	  G_CALLBACK (action_mail_copy_cb) },
+
+	{ "mail-delete",
+	  "user-trash",
+	  N_("_Delete Message"),
+	  "<Control>d",
+	  N_("Mark the selected messages for deletion"),
+	  G_CALLBACK (action_mail_delete_cb) },
+
+	{ "mail-add-note",
+	  "evolution-memos",
+	  N_("_Add note…"),
+	  NULL,
+	  N_("Add a note for the selected message"),
+	  G_CALLBACK (action_mail_edit_note_cb) },
+
+	{ "mail-delete-note",
+	  NULL,
+	  N_("Delete no_te"),
+	  NULL,
+	  N_("Delete the note for the selected message"),
+	  G_CALLBACK (action_mail_delete_note_cb) },
+
+	{ "mail-edit-note",
+	  "evolution-memos",
+	  N_("_Edit note…"),
+	  NULL,
+	  N_("Edit a note for the selected message"),
+	  G_CALLBACK (action_mail_edit_note_cb) },
+
+	{ "mail-filter-rule-for-mailing-list",
+	  NULL,
+	  N_("Create a Filter Rule for Mailing _List…"),
+	  NULL,
+	  N_("Create a rule to filter messages to this mailing list"),
+	  G_CALLBACK (action_mail_filter_on_mailing_list_cb) },
+
+	{ "mail-filter-rule-for-recipients",
+	  NULL,
+	  N_("Create a Filter Rule for _Recipients…"),
+	  NULL,
+	  N_("Create a rule to filter messages to these recipients"),
+	  G_CALLBACK (action_mail_filter_on_recipients_cb) },
+
+	{ "mail-filter-rule-for-sender",
+	  NULL,
+	  N_("Create a Filter Rule for Se_nder…"),
+	  NULL,
+	  N_("Create a rule to filter messages from this sender"),
+	  G_CALLBACK (action_mail_filter_on_sender_cb) },
+
+	{ "mail-filter-rule-for-subject",
+	  NULL,
+	  N_("Create a Filter Rule for _Subject…"),
+	  NULL,
+	  N_("Create a rule to filter messages with this subject"),
+	  G_CALLBACK (action_mail_filter_on_subject_cb) },
+
+	{ "mail-filters-apply",
+	  "stock_mail-filters-apply",
+	  N_("A_pply Filters"),
+	  "<Control>y",
+	  N_("Apply filter rules to the selected messages"),
+	  G_CALLBACK (action_mail_filters_apply_cb) },
+
+	{ "mail-find",
+	  "edit-find",
+	  N_("_Find in Message…"),
+	  "<Shift><Control>f",
+	  N_("Search for text in the body of the displayed message"),
+	  G_CALLBACK (action_mail_find_cb) },
+
+	{ "mail-flag-clear",
+	  NULL,
+	  N_("_Clear Flag"),
+	  NULL,
+	  N_("Remove the follow-up flag from the selected messages"),
+	  G_CALLBACK (action_mail_flag_clear_cb) },
+
+	{ "mail-flag-completed",
+	  NULL,
+	  N_("_Flag Completed"),
+	  NULL,
+	  N_("Set the follow-up flag to completed on the selected messages"),
+	  G_CALLBACK (action_mail_flag_completed_cb) },
+
+	{ "mail-flag-for-followup",
+	  "stock_mail-flag-for-followup",
+	  N_("Follow _Up…"),
+	  "<Shift><Control>g",
+	  N_("Flag the selected messages for follow-up"),
+	  G_CALLBACK (action_mail_flag_for_followup_cb) },
+
+	{ "mail-forward-attached",
+	  NULL,
+	  N_("_Attached"),
+	  NULL,
+	  N_("Forward the selected message to someone as an attachment"),
+	  G_CALLBACK (action_mail_forward_attached_cb) },
+
+	{ "mail-forward-attached-full",
+	  NULL,
+	  N_("Forward As _Attached"),
+	  NULL,
+	  N_("Forward the selected message to someone as an attachment"),
+	  G_CALLBACK (action_mail_forward_attached_cb) },
+
+	{ "mail-forward-inline",
+	  NULL,
+	  N_("_Inline"),
+	  NULL,
+	  N_("Forward the selected message in the body of a new message"),
+	  G_CALLBACK (action_mail_forward_inline_cb) },
+
+	{ "mail-forward-inline-full",
+	  NULL,
+	  N_("Forward As _Inline"),
+	  NULL,
+	  N_("Forward the selected message in the body of a new message"),
+	  G_CALLBACK (action_mail_forward_inline_cb) },
+
+	{ "mail-forward-quoted",
+	  NULL,
+	  N_("_Quoted"),
+	  NULL,
+	  N_("Forward the selected message quoted like a reply"),
+	  G_CALLBACK (action_mail_forward_quoted_cb) },
+
+	{ "mail-forward-quoted-full",
+	  NULL,
+	  N_("Forward As _Quoted"),
+	  NULL,
+	  N_("Forward the selected message quoted like a reply"),
+	  G_CALLBACK (action_mail_forward_quoted_cb) },
+
+	{ "mail-label-new",
+	  NULL,
+	  N_("_New Label"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_mail_label_new_cb) },
+
+	{ "mail-label-none",
+	  NULL,
+	  /* Translators: "None" is used in the message label context menu.
+	   *              It removes all labels from the selected messages. */
+	  N_("N_one"),
+	  "0",
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_mail_label_none_cb) },
+
+	{ "mail-load-images",
+	  "image-x-generic",
+	  N_("_Load Images"),
+	  "<Control>i",
+	  N_("Force images in HTML mail to be loaded"),
+	  G_CALLBACK (action_mail_load_images_cb) },
+
+	{ "mail-mark-ignore-thread-sub",
+	  NULL,
+	  N_("_Ignore Subthread"),
+	  NULL,
+	  N_("Mark new mails in a subthread as read automatically"),
+	  G_CALLBACK (action_mail_mark_ignore_thread_sub_cb) },
+
+	{ "mail-mark-ignore-thread-whole",
+	  NULL,
+	  N_("_Ignore Thread"),
+	  NULL,
+	  N_("Mark new mails in this thread as read automatically"),
+	  G_CALLBACK (action_mail_mark_ignore_thread_whole_cb) },
+
+	{ "mail-mark-important",
+	  "mail-mark-important",
+	  N_("_Important"),
+	  NULL,
+	  N_("Mark the selected messages as important"),
+	  G_CALLBACK (action_mail_mark_important_cb) },
+
+	{ "mail-mark-junk",
+	  "mail-mark-junk",
+	  N_("_Junk"),
+	  "<Control>j",
+	  N_("Mark the selected messages as junk"),
+	  G_CALLBACK (action_mail_mark_junk_cb) },
+
+	{ "mail-mark-notjunk",
+	  "mail-mark-notjunk",
+	  N_("_Not Junk"),
+	  "<Shift><Control>j",
+	  N_("Mark the selected messages as not being junk"),
+	  G_CALLBACK (action_mail_mark_notjunk_cb) },
+
+	{ "mail-mark-read",
+	  "mail-mark-read",
+	  N_("_Read"),
+	  "<Control>k",
+	  N_("Mark the selected messages as having been read"),
+	  G_CALLBACK (action_mail_mark_read_cb) },
+
+	{ "mail-mark-unignore-thread-sub",
+	  NULL,
+	  N_("Do not _Ignore Subthread"),
+	  NULL,
+	  N_("Do not mark new mails in a subthread as read automatically"),
+	  G_CALLBACK (action_mail_mark_unignore_thread_sub_cb) },
+
+	{ "mail-mark-unignore-thread-whole",
+	  NULL,
+	  N_("Do not _Ignore Thread"),
+	  NULL,
+	  N_("Do not mark new mails in this thread as read automatically"),
+	  G_CALLBACK (action_mail_mark_unignore_thread_whole_cb) },
+
+	{ "mail-mark-unimportant",
+	  NULL,
+	  N_("Uni_mportant"),
+	  NULL,
+	  N_("Mark the selected messages as unimportant"),
+	  G_CALLBACK (action_mail_mark_unimportant_cb) },
+
+	{ "mail-mark-unread",
+	  "mail-mark-unread",
+	  N_("_Unread"),
+	  "<Shift><Control>k",
+	  N_("Mark the selected messages as not having been read"),
+	  G_CALLBACK (action_mail_mark_unread_cb) },
+
+	{ "mail-message-edit",
+	  NULL,
+	  N_("_Edit as New Message…"),
+	  NULL,
+	  N_("Open the selected messages in the composer for editing"),
+	  G_CALLBACK (action_mail_message_edit_cb) },
+
+	{ "mail-message-new",
+	  "mail-message-new",
+	  N_("Compose _New Message"),
+	  "<Shift><Control>m",
+	  N_("Open a window for composing a mail message"),
+	  G_CALLBACK (action_mail_message_new_cb) },
+
+	{ "mail-message-open",
+	  NULL,
+	  N_("_Open in New Window"),
+	  "<Control>o",
+	  N_("Open the selected messages in a new window"),
+	  G_CALLBACK (action_mail_message_open_cb) },
+
+	{ "mail-move",
+	  "mail-move",
+	  N_("_Move to Folder…"),
+	  "<Shift><Control>v",
+	  N_("Move selected messages to another folder"),
+	  G_CALLBACK (action_mail_move_cb) },
+
+	{ "mail-next",
+	  "go-next",
+	  N_("_Next Message"),
+	  "<Control>Page_Down",
+	  N_("Display the next message"),
+	  G_CALLBACK (action_mail_next_cb) },
+
+	{ "mail-next-important",
+	  NULL,
+	  N_("Next _Important Message"),
+	  NULL,
+	  N_("Display the next important message"),
+	  G_CALLBACK (action_mail_next_important_cb) },
+
+	{ "mail-next-thread",
+	  NULL,
+	  N_("Next _Thread"),
+	  NULL,
+	  N_("Display the next thread"),
+	  G_CALLBACK (action_mail_next_thread_cb) },
+
+	{ "mail-next-unread",
+	  "go-jump",
+	  N_("Next _Unread Message"),
+	  "<Control>bracketright",
+	  N_("Display the next unread message"),
+	  G_CALLBACK (action_mail_next_unread_cb) },
+
+	{ "mail-previous",
+	  "go-previous",
+	  N_("_Previous Message"),
+	  "<Control>Page_Up",
+	  N_("Display the previous message"),
+	  G_CALLBACK (action_mail_previous_cb) },
+
+	{ "mail-previous-important",
+	  NULL,
+	  N_("Pr_evious Important Message"),
+	  NULL,
+	  N_("Display the previous important message"),
+	  G_CALLBACK (action_mail_previous_important_cb) },
+
+	{ "mail-previous-thread",
+	  NULL,
+	  N_("Previous T_hread"),
+	  NULL,
+	  N_("Display the previous thread"),
+	  G_CALLBACK (action_mail_previous_thread_cb) },
+
+	{ "mail-previous-unread",
+	  NULL,
+	  N_("P_revious Unread Message"),
+	  "<Control>bracketleft",
+	  N_("Display the previous unread message"),
+	  G_CALLBACK (action_mail_previous_unread_cb) },
+
+	{ "mail-print",
+	  "document-print",
+	  N_("_Print…"),
+	  "<Control>p",
+	  N_("Print this message"),
+	  G_CALLBACK (action_mail_print_cb) },
+
+	{ "mail-print-preview",
+	  "document-print-preview",
+	  N_("Pre_view…"),
+	  NULL,
+	  N_("Preview the message to be printed"),
+	  G_CALLBACK (action_mail_print_preview_cb) },
+
+	{ "mail-redirect",
+	  NULL,
+	  N_("Re_direct"),
+	  NULL,
+	  N_("Redirect (bounce) the selected message to someone"),
+	  G_CALLBACK (action_mail_redirect_cb) },
+
+	{ "mail-remove-attachments",
+	  "edit-delete",
+	  N_("Remo_ve Attachments"),
+	  NULL,
+	  N_("Remove attachments"),
+	  G_CALLBACK (action_mail_remove_attachments_cb) },
+
+	{ "mail-remove-duplicates",
+	   NULL,
+	   N_("Remove Du_plicate Messages"),
+	   NULL,
+	   N_("Checks selected messages for duplicates"),
+	   G_CALLBACK (action_mail_remove_duplicates_cb) },
+
+	{ "mail-reply-all",
+	  NULL,
+	  N_("Reply to _All"),
+	  "<Shift><Control>r",
+	  N_("Compose a reply to all the recipients of the selected message"),
+	  G_CALLBACK (action_mail_reply_all_cb) },
+
+	{ "mail-reply-alternative",
+	  NULL,
+	  N_("Al_ternative Reply…"),
+	  "<Alt><Control>r",
+	  N_("Choose reply options for the selected message"),
+	  G_CALLBACK (action_mail_reply_alternative_cb) },
+
+	{ "mail-reply-list",
+	  NULL,
+	  N_("Reply to _List"),
+	  "<Control>l",
+	  N_("Compose a reply to the mailing list of the selected message"),
+	  G_CALLBACK (action_mail_reply_list_cb) },
+
+	{ "mail-reply-sender",
+	  "mail-reply-sender",
+	  N_("_Reply to Sender"),
+	  "<Control>r",
+	  N_("Compose a reply to the sender of the selected message"),
+	  G_CALLBACK (action_mail_reply_sender_cb) },
+
+	{ "mail-reply-template",
+	  NULL,
+	  N_("Repl_y with Template"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-save-as",
+	  "document-save-as",
+	  N_("_Save as mbox…"),
+	  "<Control>s",
+	  N_("Save selected messages as an mbox file"),
+	  G_CALLBACK (action_mail_save_as_cb) },
+
+	{ "mail-search-web",
+	  NULL,
+	  N_("Search _Web…"),
+	  NULL,
+	  N_("Search the Web with the selected text"),
+	  G_CALLBACK (action_mail_search_web_cb) },
+
+	{ "mail-show-source",
+	  NULL,
+	  N_("_Message Source"),
+	  "<Control>u",
+	  N_("Show the raw email source of the message"),
+	  G_CALLBACK (action_mail_show_source_cb) },
+
+	{ "mail-toggle-important",
+	  NULL,
+	  NULL,  /* No menu item; key press only */
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_mail_toggle_important_cb) },
+
+	{ "mail-undelete",
+	  NULL,
+	  N_("_Undelete Message"),
+	  "<Shift><Control>d",
+	  N_("Undelete the selected messages"),
+	  G_CALLBACK (action_mail_undelete_cb) },
+
+	{ "mail-zoom-100",
+	  "zoom-original",
+	  N_("_Normal Size"),
+	  "<Control>0",
+	  N_("Reset the text to its original size"),
+	  G_CALLBACK (action_mail_zoom_100_cb) },
+
+	{ "mail-zoom-in",
+	  "zoom-in",
+	  N_("_Zoom In"),
+	  "<Control>plus",
+	  N_("Increase the text size"),
+	  G_CALLBACK (action_mail_zoom_in_cb) },
+
+	{ "mail-zoom-out",
+	  "zoom-out",
+	  N_("Zoom _Out"),
+	  "<Control>minus",
+	  N_("Decrease the text size"),
+	  G_CALLBACK (action_mail_zoom_out_cb) },
+
+	/*** Menus ***/
+
+	{ "mail-create-menu",
+	  NULL,
+	  N_("Cre_ate"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-encoding-menu",
+	  NULL,
+	  N_("Ch_aracter Encoding"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-forward-as-menu",
+	  NULL,
+	  N_("F_orward As"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-label-menu",
+	  NULL,
+	  N_("_Label"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-reply-group-menu",
+	  NULL,
+	  N_("_Group Reply"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-goto-menu",
+	  NULL,
+	  N_("_Go To"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-mark-as-menu",
+	  NULL,
+	  N_("Mar_k As"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-message-menu",
+	  NULL,
+	  N_("_Message"),
+	  NULL,
+	  NULL,
+	  NULL },
+
+	{ "mail-zoom-menu",
+	  NULL,
+	  N_("_Zoom"),
+	  NULL,
+	  NULL,
+	  NULL }
+};
+
+static GtkActionEntry mail_reader_search_folder_entries[] = {
+
+	{ "mail-search-folder-from-mailing-list",
+	  NULL,
+	  N_("Create a Search Folder from Mailing _List…"),
+	  NULL,
+	  N_("Create a search folder for this mailing list"),
+	  G_CALLBACK (action_mail_search_folder_from_mailing_list_cb) },
+
+	{ "mail-search-folder-from-recipients",
+	  NULL,
+	  N_("Create a Search Folder from Recipien_ts…"),
+	  NULL,
+	  N_("Create a search folder for these recipients"),
+	  G_CALLBACK (action_mail_search_folder_from_recipients_cb) },
+
+	{ "mail-search-folder-from-sender",
+	  NULL,
+	  N_("Create a Search Folder from Sen_der…"),
+	  NULL,
+	  N_("Create a search folder for this sender"),
+	  G_CALLBACK (action_mail_search_folder_from_sender_cb) },
+
+	{ "mail-search-folder-from-subject",
+	  NULL,
+	  N_("Create a Search Folder from S_ubject…"),
+	  NULL,
+	  N_("Create a search folder for this subject"),
+	  G_CALLBACK (action_mail_search_folder_from_subject_cb) },
+};
+
+static EPopupActionEntry mail_reader_popup_entries[] = {
+
+	{ "mail-popup-archive",
+	  NULL,
+	  "mail-archive" },
+
+	{ "mail-popup-color-assign",
+	  NULL,
+	  "mail-color-assign" },
+
+	{ "mail-popup-color-unset",
+	  NULL,
+	  "mail-color-unset" },
+
+	{ "mail-popup-copy",
+	  NULL,
+	  "mail-copy" },
+
+	{ "mail-popup-delete",
+	  NULL,
+	  "mail-delete" },
+
+	{ "mail-popup-add-note",
+	  NULL,
+	  "mail-add-note" },
+
+	{ "mail-popup-delete-note",
+	  NULL,
+	  "mail-delete-note" },
+
+	{ "mail-popup-edit-note",
+	  NULL,
+	  "mail-edit-note" },
+
+	{ "mail-popup-flag-clear",
+	  NULL,
+	  "mail-flag-clear" },
+
+	{ "mail-popup-flag-completed",
+	  NULL,
+	  "mail-flag-completed" },
+
+	{ "mail-popup-flag-for-followup",
+	  N_("Mark for Follo_w Up…"),
+	  "mail-flag-for-followup" },
+
+	{ "mail-popup-forward",
+	  NULL,
+	  "mail-forward" },
+
+	{ "mail-popup-mark-ignore-thread-sub",
+	  N_("_Ignore Subthread"),
+	  "mail-mark-ignore-thread-sub" },
+
+	{ "mail-popup-mark-ignore-thread-whole",
+	  N_("_Ignore Thread"),
+	  "mail-mark-ignore-thread-whole" },
+
+	{ "mail-popup-mark-important",
+	  N_("Mark as _Important"),
+	  "mail-mark-important" },
+
+	{ "mail-popup-mark-junk",
+	  N_("Mark as _Junk"),
+	  "mail-mark-junk" },
+
+	{ "mail-popup-mark-notjunk",
+	  N_("Mark as _Not Junk"),
+	  "mail-mark-notjunk" },
+
+	{ "mail-popup-mark-read",
+	  N_("Mar_k as Read"),
+	  "mail-mark-read" },
+
+	{ "mail-popup-mark-unignore-thread-sub",
+	  N_("Do not _Ignore Subthread"),
+	  "mail-mark-unignore-thread-sub" },
+
+	{ "mail-popup-mark-unignore-thread-whole",
+	  N_("Do not _Ignore Thread"),
+	  "mail-mark-unignore-thread-whole" },
+
+	{ "mail-popup-mark-unimportant",
+	  N_("Mark as Uni_mportant"),
+	  "mail-mark-unimportant" },
+
+	{ "mail-popup-mark-unread",
+	  N_("Mark as _Unread"),
+	  "mail-mark-unread" },
+
+	{ "mail-popup-message-edit",
+	  NULL,
+	  "mail-message-edit" },
+
+	{ "mail-popup-move",
+	  NULL,
+	  "mail-move" },
+
+	{ "mail-popup-print",
+	  NULL,
+	  "mail-print" },
+
+	{ "mail-popup-remove-attachments",
+	  NULL,
+	  "mail-remove-attachments" },
+
+	{ "mail-popup-remove-duplicates",
+	  NULL,
+	  "mail-remove-duplicates" },
+
+	{ "mail-popup-reply-all",
+	  NULL,
+	  "mail-reply-all" },
+
+	{ "mail-popup-reply-sender",
+	  NULL,
+	  "mail-reply-sender" },
+
+	{ "mail-popup-reply-template",
+	  NULL,
+	  "mail-reply-template" },
+
+	{ "mail-popup-save-as",
+	  NULL,
+	  "mail-save-as" },
+
+	{ "mail-popup-search-web",
+	  NULL,
+	  "mail-search-web" },
+
+	{ "mail-popup-undelete",
+	  NULL,
+	  "mail-undelete" }
+};
+
+static GtkToggleActionEntry mail_reader_toggle_entries[] = {
+
+	{ "mail-caret-mode",
+	  NULL,
+	  N_("_Caret Mode"),
+	  "F7",
+	  N_("Show a blinking cursor in the body of displayed messages"),
+	  NULL,  /* No callback required */
+	  FALSE },
+
+	{ "mail-show-all-headers",
+	  NULL,
+	  N_("All Message _Headers"),
+	  NULL,
+	  N_("Show messages with all email headers"),
+	  G_CALLBACK (action_mail_show_all_headers_cb),
+	  FALSE }
+};
+
+static void
+mail_reader_double_click_cb (EMailReader *reader,
+                             gint row,
+                             ETreePath path,
+                             gint col,
+                             GdkEvent *event)
+{
+	GtkAction *action;
+
+	/* Ignore double clicks on columns that handle their own state. */
+	if (MESSAGE_LIST_COLUMN_IS_ACTIVE (col))
+		return;
+
+	action = e_mail_reader_get_action (reader, "mail-message-open");
+	gtk_action_activate (action);
+}
+
+static gboolean
+mail_reader_key_press_event_cb (EMailReader *reader,
+                                GdkEventKey *event)
+{
+	GtkAction *action;
+	const gchar *action_name;
+
+	if (!gtk_widget_has_focus (GTK_WIDGET (reader))) {
+		EMailDisplay *display;
+
+		display = e_mail_reader_get_mail_display (reader);
+		if (e_web_view_get_need_input (E_WEB_VIEW (display)) &&
+		    gtk_widget_has_focus (GTK_WIDGET (display)))
+			return FALSE;
+	}
+
+	if ((event->state & GDK_CONTROL_MASK) != 0)
+		goto ctrl;
+
+	/* <keyval> alone */
+	switch (event->keyval) {
+		case GDK_KEY_Delete:
+		case GDK_KEY_KP_Delete:
+			action_name = "mail-delete";
+			break;
+
+		case GDK_KEY_Return:
+		case GDK_KEY_KP_Enter:
+		case GDK_KEY_ISO_Enter:
+			if (E_IS_MAIL_BROWSER (reader))
+				return FALSE;
+
+			action_name = "mail-message-open";
+			break;
+
+		case GDK_KEY_period:
+		case GDK_KEY_bracketright:
+			action_name = "mail-next-unread";
+			break;
+
+		case GDK_KEY_comma:
+		case GDK_KEY_bracketleft:
+			action_name = "mail-previous-unread";
+			break;
+
+#ifdef HAVE_XFREE
+		case XF86XK_Reply:
+			action_name = "mail-reply-all";
+			break;
+
+		case XF86XK_MailForward:
+			action_name = "mail-forward";
+			break;
+#endif
+
+		case GDK_KEY_exclam:
+			action_name = "mail-toggle-important";
+			break;
+
+		case GDK_KEY_ZoomIn:
+			action_name = "mail-zoom-in";
+			break;
+
+		case GDK_KEY_ZoomOut:
+			action_name = "mail-zoom-out";
+			break;
+
+		default:
+			return FALSE;
+	}
+
+	goto exit;
+
+ctrl:
+
+	/* Ctrl + <keyval> */
+	switch (event->keyval) {
+		case GDK_KEY_period:
+			action_name = "mail-next-unread";
+			break;
+
+		case GDK_KEY_comma:
+			action_name = "mail-previous-unread";
+			break;
+
+		case GDK_KEY_equal:
+		case GDK_KEY_KP_Add:
+			action_name = "mail-zoom-in";
+			break;
+
+		case GDK_KEY_KP_Subtract:
+			action_name = "mail-zoom-out";
+			break;
+
+		default:
+			return FALSE;
+	}
+
+exit:
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_activate (action);
+
+	return TRUE;
+}
+
+static gint
+mail_reader_key_press_cb (EMailReader *reader,
+                          gint row,
+                          ETreePath path,
+                          gint col,
+                          GdkEvent *event)
+{
+	return mail_reader_key_press_event_cb (reader, &event->key);
+}
+
+static gboolean
+mail_reader_message_seen_cb (gpointer user_data)
+{
+	EMailReaderClosure *closure = user_data;
+	EMailReader *reader;
+	GtkWidget *message_list;
+	EMailPartList *parts;
+	EMailDisplay *display;
+	CamelMimeMessage *message;
+	const gchar *current_uid;
+	const gchar *message_uid;
+	gboolean uid_is_current = TRUE;
+
+	reader = closure->reader;
+	message_uid = closure->message_uid;
+
+	display = e_mail_reader_get_mail_display (reader);
+	parts = e_mail_display_get_part_list (display);
+	message_list = e_mail_reader_get_message_list (reader);
+
+	g_return_val_if_fail (IS_MESSAGE_LIST (message_list), FALSE);
+
+	/* zero the timeout id now, if it was not rescheduled */
+	if (g_source_get_id (g_main_current_source ()) == MESSAGE_LIST (message_list)->seen_id)
+		MESSAGE_LIST (message_list)->seen_id = 0;
+
+	if (e_tree_is_dragging (E_TREE (message_list)))
+		return FALSE;
+
+	current_uid = MESSAGE_LIST (message_list)->cursor_uid;
+	uid_is_current &= (g_strcmp0 (current_uid, message_uid) == 0);
+
+	if (parts != NULL)
+		message = e_mail_part_list_get_message (parts);
+	else
+		message = NULL;
+
+	if (uid_is_current && message != NULL)
+		g_signal_emit (
+			reader, signals[MESSAGE_SEEN], 0,
+			message_uid, message);
+
+	return FALSE;
+}
+
+static void
+schedule_timeout_mark_seen (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	MessageList *message_list;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+	g_return_if_fail (message_list != NULL);
+
+	if (message_list->cursor_uid) {
+		EMailReaderClosure *timeout_closure;
+
+		if (message_list->seen_id > 0) {
+			g_source_remove (message_list->seen_id);
+			message_list->seen_id = 0;
+		}
+
+		timeout_closure = g_slice_new0 (EMailReaderClosure);
+		timeout_closure->reader = g_object_ref (reader);
+		timeout_closure->message_uid = g_strdup (message_list->cursor_uid);
+
+		MESSAGE_LIST (message_list)->seen_id =
+			e_named_timeout_add_full (
+				G_PRIORITY_DEFAULT, priv->schedule_mark_seen_interval,
+				mail_reader_message_seen_cb,
+				timeout_closure, (GDestroyNotify)
+				mail_reader_closure_free);
+	}
+}
+
+static void
+mail_reader_load_changed_cb (EMailReader *reader,
+                             WebKitLoadEvent event,
+                             EMailDisplay *display)
+{
+	EMailReaderPrivate *priv;
+
+	if (event != WEBKIT_LOAD_FINISHED)
+		return;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	if (priv->schedule_mark_seen &&
+	    E_IS_MAIL_VIEW (reader) &&
+	    e_mail_display_get_part_list (display) &&
+	    e_mail_view_get_preview_visible (E_MAIL_VIEW (reader))) {
+		if (priv->folder_was_just_selected)
+			priv->folder_was_just_selected = FALSE;
+		else
+			schedule_timeout_mark_seen (reader);
+	}
+}
+
+static void
+mail_reader_remote_content_clicked_cb (EMailReader *reader,
+				       const GdkRectangle *position,
+				       gpointer user_data)
+{
+	GtkWidget *mail_display = user_data;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+	g_return_if_fail (E_IS_MAIL_DISPLAY (mail_display));
+
+	e_mail_remote_content_popover_run (reader, mail_display, position);
+}
+
+static void
+maybe_schedule_timeout_mark_seen (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	MessageList *message_list;
+	gboolean schedule_timeout;
+	gint timeout_interval = -1;
+	const gchar *message_uid;
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+
+	message_uid = message_list->cursor_uid;
+	if (message_uid == NULL ||
+	    e_tree_is_dragging (E_TREE (message_list)))
+		return;
+
+	schedule_timeout =
+		(message_uid != NULL) &&
+		e_mail_reader_utils_get_mark_seen_setting (reader, &timeout_interval);
+
+	if (message_list->seen_id > 0) {
+		g_source_remove (message_list->seen_id);
+		message_list->seen_id = 0;
+	}
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	priv->schedule_mark_seen = schedule_timeout;
+	priv->schedule_mark_seen_interval = timeout_interval;
+}
+
+static gboolean
+discard_timeout_mark_seen_cb (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	MessageList *message_list;
+
+	g_return_val_if_fail (reader != NULL, FALSE);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	priv->schedule_mark_seen = FALSE;
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+	g_return_val_if_fail (message_list != NULL, FALSE);
+
+	if (message_list->seen_id > 0) {
+		g_source_remove (message_list->seen_id);
+		message_list->seen_id = 0;
+	}
+
+	return FALSE;
+}
+
+
+static void
+mail_reader_preview_pane_visible_changed_cb (EMailReader *reader,
+					     GParamSpec *param,
+					     GtkWidget *widget)
+{
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+	g_return_if_fail (GTK_IS_WIDGET (widget));
+
+	if (!gtk_widget_get_visible (widget))
+		discard_timeout_mark_seen_cb (reader);
+}
+
+static void
+mail_reader_remove_followup_alert (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	if (!priv)
+		return;
+
+	if (priv->followup_alert)
+		e_alert_response (priv->followup_alert, GTK_RESPONSE_OK);
+}
+
+static void
+mail_reader_manage_followup_flag (EMailReader *reader,
+				  CamelFolder *folder,
+				  const gchar *message_uid)
+{
+	EMailReaderPrivate *priv;
+	CamelMessageInfo *info;
+	const gchar *followup, *completed_on, *due_by;
+	time_t date;
+	gchar *date_str = NULL;
+	gboolean alert_added = FALSE;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+	g_return_if_fail (CAMEL_IS_FOLDER (folder));
+	g_return_if_fail (message_uid != NULL);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	if (!priv)
+		return;
+
+	info = camel_folder_get_message_info (folder, message_uid);
+	if (!info)
+		return;
+
+	followup = camel_message_info_get_user_tag (info, "follow-up");
+	if (followup && *followup) {
+		EPreviewPane *preview_pane;
+		const gchar *alert_tag;
+		EAlert *alert;
+
+		completed_on = camel_message_info_get_user_tag (info, "completed-on");
+		due_by = camel_message_info_get_user_tag (info, "due-by");
+
+		if (completed_on && *completed_on) {
+			alert_tag = "mail:follow-up-completed-info";
+			date = camel_header_decode_date (completed_on, NULL);
+			date_str = e_datetime_format_format ("mail", "header", DTFormatKindDateTime, date);
+		} else if (due_by && *due_by) {
+			time_t now;
+
+			alert_tag = "mail:follow-up-dueby-info";
+			date = camel_header_decode_date (due_by, NULL);
+			date_str = e_datetime_format_format ("mail", "header", DTFormatKindDateTime, date);
+
+			now = time (NULL);
+			if (now > date)
+				alert_tag = "mail:follow-up-overdue-error";
+		} else {
+			alert_tag = "mail:follow-up-flag-info";
+		}
+
+		alert = e_alert_new (alert_tag, followup, date_str ? date_str : "???", NULL);
+
+		g_free (date_str);
+
+		preview_pane = e_mail_reader_get_preview_pane (reader);
+		e_alert_sink_submit_alert (E_ALERT_SINK (preview_pane), alert);
+
+		alert_added = TRUE;
+
+		mail_reader_remove_followup_alert (reader);
+		priv->followup_alert = alert;
+		g_object_add_weak_pointer (G_OBJECT (priv->followup_alert), &priv->followup_alert);
+
+		g_object_unref (alert);
+	}
+
+	g_clear_object (&info);
+
+	if (!alert_added)
+		mail_reader_remove_followup_alert (reader);
+}
+
+static void
+mail_reader_reload (EMailReader *reader)
+{
+	CamelFolder *folder;
+	GPtrArray *uids;
+	EMailDisplay *mail_display;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+	if (uids && uids->len == 1)
+		mail_reader_manage_followup_flag (reader, folder, uids->pdata[0]);
+
+	g_clear_object (&folder);
+	if (uids)
+		g_ptr_array_unref (uids);
+
+	mail_display = e_mail_reader_get_mail_display (reader);
+	e_mail_display_reload (mail_display);
+}
+
+static void
+mail_reader_remove_ui (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	GtkWindow *window;
+	GtkUIManager *ui_manager = NULL;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (!priv->main_menu_label_merge_id)
+		return;
+
+	window = e_mail_reader_get_window (reader);
+	g_return_if_fail (window != NULL);
+
+	if (E_IS_SHELL_WINDOW (window))
+		ui_manager = e_shell_window_get_ui_manager (E_SHELL_WINDOW (window));
+	else if (E_IS_MAIL_BROWSER (window))
+		ui_manager = e_mail_browser_get_ui_manager (E_MAIL_BROWSER (window));
+
+	g_return_if_fail (ui_manager != NULL);
+	g_return_if_fail (GTK_IS_UI_MANAGER (ui_manager));
+
+	gtk_ui_manager_remove_ui (ui_manager, priv->main_menu_label_merge_id);
+}
+
+static void
+mail_reader_message_loaded_cb (CamelFolder *folder,
+                               GAsyncResult *result,
+                               EMailReaderClosure *closure)
+{
+	EMailReader *reader;
+	EMailReaderPrivate *priv;
+	CamelMimeMessage *message = NULL;
+	GtkWidget *message_list;
+	const gchar *message_uid;
+	GError *error = NULL;
+
+	reader = closure->reader;
+	message_uid = closure->message_uid;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	/* If the private struct is NULL, the EMailReader was destroyed
+	 * while we were loading the message and we're likely holding the
+	 * last reference.  Nothing to do but drop the reference.
+	 * FIXME Use a GWeakRef instead of this hack. */
+	if (priv == NULL) {
+		mail_reader_closure_free (closure);
+		return;
+	}
+
+	message = camel_folder_get_message_finish (folder, result, &error);
+
+	/* If the user picked a different message in the time it took
+	 * to fetch this message, then don't bother rendering it. */
+	if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+		g_clear_error (&error);
+		goto exit;
+	}
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	if (message_list == NULL) {
+		/* For cases where message fetching took so long that
+		 * user closed the message window before this was called. */
+		goto exit;
+	}
+
+	if (message != NULL) {
+		CamelMessageInfo *mi;
+
+		mail_reader_manage_followup_flag (reader, folder, message_uid);
+
+		mi = camel_folder_get_message_info (folder, message_uid);
+		if (mi) {
+			if (camel_util_fill_message_info_user_headers (mi, camel_medium_get_headers (CAMEL_MEDIUM (message))))
+				gtk_widget_queue_draw (message_list);
+
+			g_object_unref (mi);
+		}
+
+		g_signal_emit (
+			reader, signals[MESSAGE_LOADED], 0,
+			message_uid, message);
+	}
+
+exit:
+	if (error != NULL) {
+		EPreviewPane *preview_pane;
+		EWebView *web_view;
+
+		preview_pane = e_mail_reader_get_preview_pane (reader);
+		web_view = e_preview_pane_get_web_view (preview_pane);
+
+		if (g_error_matches (error, CAMEL_SERVICE_ERROR, CAMEL_SERVICE_ERROR_UNAVAILABLE) &&
+		    CAMEL_IS_OFFLINE_FOLDER (folder) &&
+		    camel_service_get_connection_status (CAMEL_SERVICE (camel_folder_get_parent_store (folder))) != CAMEL_SERVICE_CONNECTED)
+			e_alert_submit (
+				E_ALERT_SINK (web_view),
+				"mail:no-retrieve-message-offline",
+				NULL);
+		else
+			e_alert_submit (
+				E_ALERT_SINK (web_view),
+				"mail:no-retrieve-message",
+				error->message, NULL);
+	}
+
+	g_clear_error (&error);
+
+	mail_reader_closure_free (closure);
+
+	g_clear_object (&message);
+}
+
+static gboolean
+mail_reader_message_selected_timeout_cb (gpointer user_data)
+{
+	EMailReader *reader;
+	EMailReaderPrivate *priv;
+	EMailDisplay *display;
+	GtkWidget *message_list;
+	const gchar *cursor_uid;
+	const gchar *format_uid;
+	EMailPartList *parts;
+
+	reader = E_MAIL_READER (user_data);
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	message_list = e_mail_reader_get_message_list (reader);
+	display = e_mail_reader_get_mail_display (reader);
+	parts = e_mail_display_get_part_list (display);
+
+	cursor_uid = MESSAGE_LIST (message_list)->cursor_uid;
+	if (parts != NULL)
+		format_uid = e_mail_part_list_get_message_uid (parts);
+	else
+		format_uid = NULL;
+
+	if (MESSAGE_LIST (message_list)->last_sel_single) {
+		GtkWidget *widget;
+		gboolean display_visible;
+		gboolean selected_uid_changed;
+
+		/* Decide whether to download the full message now. */
+		widget = GTK_WIDGET (display);
+		display_visible = gtk_widget_get_mapped (widget);
+
+		selected_uid_changed = (g_strcmp0 (cursor_uid, format_uid) != 0);
+
+		if (display_visible && selected_uid_changed) {
+			EMailReaderClosure *closure;
+			GCancellable *cancellable;
+			CamelFolder *folder;
+			EActivity *activity;
+			gchar *string;
+
+			string = g_strdup_printf (
+				_("Retrieving message “%s”"), cursor_uid);
+			e_mail_display_set_part_list (display, NULL);
+			e_mail_display_set_status (display, string);
+			g_free (string);
+
+			activity = e_mail_reader_new_activity (reader);
+			e_activity_set_text (activity, _("Retrieving message"));
+			cancellable = e_activity_get_cancellable (activity);
+
+			closure = g_slice_new0 (EMailReaderClosure);
+			closure->activity = activity;
+			closure->reader = g_object_ref (reader);
+			closure->message_uid = g_strdup (cursor_uid);
+
+			folder = e_mail_reader_ref_folder (reader);
+
+			camel_folder_get_message (
+				folder, cursor_uid, G_PRIORITY_DEFAULT,
+				cancellable, (GAsyncReadyCallback)
+				mail_reader_message_loaded_cb, closure);
+
+			g_clear_object (&folder);
+
+			if (priv->retrieving_message != NULL)
+				g_object_unref (priv->retrieving_message);
+			priv->retrieving_message = g_object_ref (cancellable);
+		}
+	} else {
+		e_mail_display_set_part_list (display, NULL);
+	}
+
+	priv->message_selected_timeout_id = 0;
+
+	return FALSE;
+}
+
+static void
+mail_reader_message_selected_cb (EMailReader *reader,
+                                 const gchar *message_uid)
+{
+	EMailReaderPrivate *priv;
+	MessageList *message_list;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	/* Cancel the previous message retrieval activity. */
+	g_cancellable_cancel (priv->retrieving_message);
+
+	/* Cancel the message selected timer. */
+	if (priv->message_selected_timeout_id > 0) {
+		g_source_remove (priv->message_selected_timeout_id);
+		priv->message_selected_timeout_id = 0;
+	}
+
+	if (priv->folder_was_just_selected && message_uid) {
+		if (priv->did_try_to_open_message)
+			priv->folder_was_just_selected = FALSE;
+		else
+			priv->did_try_to_open_message = TRUE;
+	}
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+	if (message_list) {
+		EMailPartList *parts;
+		const gchar *cursor_uid, *format_uid;
+
+		parts = e_mail_display_get_part_list (e_mail_reader_get_mail_display (reader));
+
+		cursor_uid = MESSAGE_LIST (message_list)->cursor_uid;
+		if (parts != NULL)
+			format_uid = e_mail_part_list_get_message_uid (parts);
+		else
+			format_uid = NULL;
+
+		/* It can happen when the message was loaded that quickly that
+		   it was delivered before this callback. */
+		if (g_strcmp0 (cursor_uid, format_uid) == 0) {
+			e_mail_reader_changed (reader);
+			return;
+		}
+	}
+
+	/* Cancel the seen timer. */
+	if (message_list != NULL && message_list->seen_id) {
+		g_source_remove (message_list->seen_id);
+		message_list->seen_id = 0;
+	}
+
+	if (message_list_selected_count (message_list) != 1) {
+		EMailDisplay *display;
+
+		display = e_mail_reader_get_mail_display (reader);
+		e_mail_display_set_part_list (display, NULL);
+		e_web_view_clear (E_WEB_VIEW (display));
+
+	} else if (priv->folder_was_just_selected) {
+		/* Skip the timeout if we're restoring the previous message
+		 * selection.  The timeout is there for when we're scrolling
+		 * rapidly through the message list. */
+		mail_reader_message_selected_timeout_cb (reader);
+
+	} else {
+		priv->message_selected_timeout_id = e_named_timeout_add (
+			100, mail_reader_message_selected_timeout_cb, reader);
+	}
+
+	e_mail_reader_changed (reader);
+}
+
+static void
+mail_reader_message_cursor_change_cb (EMailReader *reader)
+{
+	MessageList *message_list;
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (reader != NULL);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	g_return_if_fail (priv != NULL);
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+	g_return_if_fail (message_list != NULL);
+
+	if (message_list->seen_id == 0 &&
+	    E_IS_MAIL_VIEW (reader) &&
+	    e_mail_view_get_preview_visible (E_MAIL_VIEW (reader)) &&
+	    !priv->avoid_next_mark_as_seen)
+		maybe_schedule_timeout_mark_seen (reader);
+}
+
+static void
+mail_reader_emit_folder_loaded (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	MessageList *message_list;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+
+	if (priv && (message_list_count (message_list) <= 0 ||
+	    message_list_selected_count (message_list) <= 0))
+		priv->avoid_next_mark_as_seen = FALSE;
+
+	g_signal_emit (reader, signals[FOLDER_LOADED], 0);
+}
+
+static void
+mail_reader_message_list_built_cb (MessageList *message_list,
+				   EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	mail_reader_emit_folder_loaded (reader);
+
+	/* No cursor_uid means that there will not be emitted any
+	   "cursor-changed" and "message-selected" signal, thus
+	   unset the "just selected folder" flag */
+	if (!message_list->cursor_uid)
+		priv->folder_was_just_selected = FALSE;
+}
+
+static EAlertSink *
+mail_reader_get_alert_sink (EMailReader *reader)
+{
+	EPreviewPane *preview_pane;
+
+	preview_pane = e_mail_reader_get_preview_pane (reader);
+
+	if (!gtk_widget_is_visible (GTK_WIDGET (preview_pane))) {
+		GtkWindow *window;
+
+		window = e_mail_reader_get_window (reader);
+
+		if (E_IS_SHELL_WINDOW (window))
+			return E_ALERT_SINK (window);
+	}
+
+	return E_ALERT_SINK (preview_pane);
+}
+
+static GPtrArray *
+mail_reader_get_selected_uids (EMailReader *reader)
+{
+	GtkWidget *message_list;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	return message_list_get_selected (MESSAGE_LIST (message_list));
+}
+
+static GPtrArray *
+mail_reader_get_selected_uids_with_collapsed_threads (EMailReader *reader)
+{
+	GtkWidget *message_list;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	return message_list_get_selected_with_collapsed_threads (MESSAGE_LIST (message_list));
+}
+
+static CamelFolder *
+mail_reader_ref_folder (EMailReader *reader)
+{
+	GtkWidget *message_list;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	return message_list_ref_folder (MESSAGE_LIST (message_list));
+}
+
+static void
+mail_reader_set_folder (EMailReader *reader,
+                        CamelFolder *folder)
+{
+	EMailReaderPrivate *priv;
+	EMailDisplay *display;
+	CamelFolder *previous_folder;
+	GtkWidget *message_list;
+	EMailBackend *backend;
+	EShell *shell;
+	gboolean sync_folder;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	display = e_mail_reader_get_mail_display (reader);
+	message_list = e_mail_reader_get_message_list (reader);
+
+	previous_folder = e_mail_reader_ref_folder (reader);
+
+	backend = e_mail_reader_get_backend (reader);
+	shell = e_shell_backend_get_shell (E_SHELL_BACKEND (backend));
+
+	/* Only synchronize the real folder if we're online. */
+	sync_folder =
+		(previous_folder != NULL) &&
+		(CAMEL_IS_VEE_FOLDER (previous_folder) ||
+		e_shell_get_online (shell));
+	if (sync_folder)
+		mail_sync_folder (previous_folder, TRUE, NULL, NULL);
+
+	/* Skip the rest if we're already viewing the folder. */
+	if (folder != previous_folder) {
+		e_web_view_clear (E_WEB_VIEW (display));
+
+		priv->folder_was_just_selected = (folder != NULL) && !priv->mark_seen_always;
+		priv->did_try_to_open_message = FALSE;
+
+		/* This is to make sure any post-poned changes in Search
+		 * Folders will be propagated on folder selection. */
+		if (CAMEL_IS_VEE_FOLDER (folder))
+			mail_sync_folder (folder, FALSE, NULL, NULL);
+
+		message_list_set_folder (MESSAGE_LIST (message_list), folder);
+
+		mail_reader_emit_folder_loaded (reader);
+	}
+
+	g_clear_object (&previous_folder);
+}
+
+static void
+mail_reader_set_message (EMailReader *reader,
+                         const gchar *message_uid)
+{
+	GtkWidget *message_list;
+	EMailReaderPrivate *priv;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	/* For a case when the preview panel had been disabled */
+	priv->folder_was_just_selected = FALSE;
+
+	message_list = e_mail_reader_get_message_list (reader);
+
+	message_list_select_uid (
+		MESSAGE_LIST (message_list), message_uid, FALSE);
+}
+
+static void
+mail_reader_folder_loaded (EMailReader *reader)
+{
+	guint32 state;
+
+	state = e_mail_reader_check_state (reader);
+	e_mail_reader_update_actions (reader, state);
+}
+
+static void
+mail_reader_message_list_suggest_update_actions_cb (EMailReader *reader)
+{
+	guint32 state;
+
+	state = e_mail_reader_check_state (reader);
+	e_mail_reader_update_actions (reader, state);
+}
+
+static void
+set_mail_display_part_list (GObject *object,
+                            GAsyncResult *result,
+                            gpointer user_data)
+{
+	EMailPartList *part_list;
+	EMailReader *reader;
+	EMailDisplay *display;
+	GError *local_error = NULL;
+
+	reader = E_MAIL_READER (object);
+
+	part_list = e_mail_reader_parse_message_finish (reader, result, &local_error);
+
+	if (local_error) {
+		g_warn_if_fail (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED));
+
+		g_clear_error (&local_error);
+		return;
+	}
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	e_mail_display_set_part_list (display, part_list);
+	e_mail_display_load (display, NULL);
+
+	/* Remove the reference added when parts list was
+	 * created, so that only owners are EMailDisplays. */
+	g_object_unref (part_list);
+}
+
+static void
+mail_reader_set_display_formatter_for_message (EMailReader *reader,
+                                               EMailDisplay *display,
+                                               const gchar *message_uid,
+                                               CamelMimeMessage *message,
+                                               CamelFolder *folder)
+{
+	CamelObjectBag *registry;
+	EMailPartList *parts;
+	EMailReaderPrivate *priv;
+	gchar *mail_uri;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	mail_uri = e_mail_part_build_uri (folder, message_uid, NULL, NULL);
+	registry = e_mail_part_list_get_registry ();
+	parts = camel_object_bag_peek (registry, mail_uri);
+	g_free (mail_uri);
+
+	if (parts == NULL) {
+		if (!priv->retrieving_message)
+			priv->retrieving_message = camel_operation_new ();
+
+		e_mail_reader_parse_message (
+			reader, folder, message_uid, message,
+			priv->retrieving_message,
+			set_mail_display_part_list, NULL);
+	} else {
+		e_mail_display_set_part_list (display, parts);
+		e_mail_display_load (display, NULL);
+		g_object_unref (parts);
+	}
+}
+
+static void
+mail_reader_message_loaded (EMailReader *reader,
+                            const gchar *message_uid,
+                            CamelMimeMessage *message)
+{
+	EMailReaderPrivate *priv;
+	GtkWidget *message_list;
+	EMailBackend *backend;
+	CamelFolder *folder;
+	EMailDisplay *display;
+	EShellBackend *shell_backend;
+	EShell *shell;
+	EMEvent *event;
+	EMEventTargetMessage *target;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	folder = e_mail_reader_ref_folder (reader);
+	backend = e_mail_reader_get_backend (reader);
+	display = e_mail_reader_get_mail_display (reader);
+	message_list = e_mail_reader_get_message_list (reader);
+
+	shell_backend = E_SHELL_BACKEND (backend);
+	shell = e_shell_backend_get_shell (shell_backend);
+
+	/** @Event: message.reading
+	 * @Title: Viewing a message
+	 * @Target: EMEventTargetMessage
+	 *
+	 * message.reading is emitted whenever a user views a message.
+	 */
+	event = em_event_peek ();
+	target = em_event_target_new_message (
+		event, folder, message, message_uid, 0, NULL);
+	e_event_emit (
+		(EEvent *) event, "message.reading",
+		(EEventTarget *) target);
+
+	mail_reader_set_display_formatter_for_message (
+		reader, display, message_uid, message, folder);
+
+	/* Reset the shell view icon. */
+	e_shell_event (shell, "mail-icon", (gpointer) "evolution-mail");
+
+	if (MESSAGE_LIST (message_list)->seen_id > 0) {
+		g_source_remove (MESSAGE_LIST (message_list)->seen_id);
+		MESSAGE_LIST (message_list)->seen_id = 0;
+	}
+
+	/* Determine whether to mark the message as read. */
+	if (message != NULL &&
+	    !priv->avoid_next_mark_as_seen)
+		maybe_schedule_timeout_mark_seen (reader);
+
+	priv->avoid_next_mark_as_seen = FALSE;
+
+	g_clear_object (&folder);
+}
+
+static void
+mail_reader_message_seen (EMailReader *reader,
+                          const gchar *message_uid,
+                          CamelMimeMessage *message)
+{
+	CamelFolder *folder;
+	guint32 mask, set;
+
+	mask = CAMEL_MESSAGE_SEEN;
+	set = CAMEL_MESSAGE_SEEN;
+
+	folder = e_mail_reader_ref_folder (reader);
+	camel_folder_set_message_flags (folder, message_uid, mask, set);
+	g_clear_object (&folder);
+}
+
+static void
+mail_reader_show_search_bar (EMailReader *reader)
+{
+	EPreviewPane *preview_pane;
+
+	preview_pane = e_mail_reader_get_preview_pane (reader);
+	e_preview_pane_show_search_bar (preview_pane);
+}
+
+static void
+action_mail_label_cb (GtkToggleAction *action,
+                      EMailReader *reader)
+{
+	CamelFolder *folder;
+	GPtrArray *uids;
+	const gchar *tag;
+	gint ii;
+
+	tag = g_object_get_data (G_OBJECT (action), "tag");
+	g_return_if_fail (tag != NULL);
+
+	uids = e_mail_reader_get_selected_uids (reader);
+	if (!uids)
+		return;
+
+	folder = e_mail_reader_ref_folder (reader);
+
+	camel_folder_freeze (folder);
+	for (ii = 0; ii < uids->len; ii++) {
+		if (gtk_toggle_action_get_active (action))
+			camel_folder_set_message_user_flag (
+				folder, uids->pdata[ii], tag, TRUE);
+		else {
+			camel_folder_set_message_user_flag (
+				folder, uids->pdata[ii], tag, FALSE);
+			camel_folder_set_message_user_tag (
+				folder, uids->pdata[ii], "label", NULL);
+		}
+	}
+	camel_folder_thaw (folder);
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+}
+
+#define LABEL_UNKNOWN	0
+#define LABEL_EXISTS	(1 << 0)
+#define LABEL_NOTEXIST	(1 << 1)
+
+static GHashTable *
+mail_reader_gather_labels_info (EMailReader *reader,
+				EMailLabelListStore *label_store,
+				GPtrArray *uids)
+{
+	GHashTable *labels_info;
+	CamelFolder *folder;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	gboolean valid;
+	guint ii;
+
+	labels_info = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+
+	model = GTK_TREE_MODEL (label_store);
+	folder = e_mail_reader_ref_folder (reader);
+
+	if (!folder)
+		return labels_info;
+
+	for (ii = 0; ii < uids->len; ii++) {
+		CamelMessageInfo *info;
+
+		info = camel_folder_get_message_info (folder, uids->pdata[ii]);
+		if (!info)
+			continue;
+
+		for (valid = gtk_tree_model_get_iter_first (model, &iter);
+		     valid;
+		     valid = gtk_tree_model_iter_next (model, &iter)) {
+			gchar *tag;
+			guint value;
+
+			tag = e_mail_label_list_store_get_tag (label_store, &iter);
+			value = GPOINTER_TO_UINT (g_hash_table_lookup (labels_info, tag));
+			if ((!(value & LABEL_EXISTS)) || (!(value & LABEL_NOTEXIST))) {
+				gboolean exists = FALSE, notexist = FALSE;
+
+				/* Check for new-style labels. */
+				if (camel_message_info_get_user_flag (info, tag)) {
+					exists = TRUE;
+				} else {
+					/* Check for old-style labels. */
+					const gchar *old_label = camel_message_info_get_user_tag (info, "label");
+					if (old_label) {
+						gchar *new_label;
+
+						/* Convert old-style labels ("<name>") to "$Label<name>". */
+						new_label = g_alloca (strlen (old_label) + 10);
+						g_stpcpy (g_stpcpy (new_label, "$Label"), old_label);
+
+						if (g_strcmp0 (new_label, tag) == 0)
+							exists = TRUE;
+						else
+							notexist = TRUE;
+					} else {
+						notexist = TRUE;
+					}
+				}
+
+				value = value |
+					(exists ? LABEL_EXISTS : LABEL_UNKNOWN) |
+					(notexist ? LABEL_NOTEXIST : LABEL_UNKNOWN);
+
+				g_hash_table_insert (labels_info, tag, GUINT_TO_POINTER (value));
+
+				/* the hash table took the 'tag' */
+				tag = NULL;
+			}
+
+			g_free (tag);
+		}
+
+		g_clear_object (&info);
+	}
+
+	g_clear_object (&folder);
+
+	return labels_info;
+}
+
+static void
+mail_reader_update_label_action (GtkToggleAction *action,
+				 GHashTable *labels_info, /* gchar * ~> guint */
+				 const gchar *label_tag)
+{
+	gboolean exists = FALSE;
+	gboolean not_exists = FALSE;
+	gboolean sensitive;
+	guint value;
+
+	/* Figure out the proper label action state for the selected
+	 * messages.  If all the selected messages have the given label,
+	 * make the toggle action active.  If all the selected message
+	 * DO NOT have the given label, make the toggle action inactive.
+	 * If some do and some don't, make the action insensitive. */
+
+	value = GPOINTER_TO_UINT (g_hash_table_lookup (labels_info, label_tag));
+	exists = (value & LABEL_EXISTS) != 0;
+	not_exists = (value & LABEL_NOTEXIST) != 0;
+
+	sensitive = !(exists && not_exists);
+	gtk_toggle_action_set_active (action, exists);
+	gtk_action_set_sensitive (GTK_ACTION (action), sensitive);
+}
+
+static void
+mail_reader_update_labels_menu (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	EMailLabelListStore *label_store;
+	EMailBackend *backend;
+	EMailSession *session;
+	GtkWindow *window;
+	GtkUIManager *ui_manager = NULL;
+	GtkActionGroup *action_group;
+	GtkTreeIter iter;
+	GHashTable *labels_info; /* gchar * ~> guint { LABEL_EXISTS | LABEL_NOTEXIST | LABEL_UNKNOWN } */
+	GPtrArray *uids;
+	const gchar *main_menu_path, *popup_menu_path;
+	gboolean valid;
+	gint ii = 0;
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	window = e_mail_reader_get_window (reader);
+	g_return_if_fail (window != NULL);
+
+	if (E_IS_SHELL_WINDOW (window))
+		ui_manager = e_shell_window_get_ui_manager (E_SHELL_WINDOW (window));
+	else if (E_IS_MAIL_BROWSER (window))
+		ui_manager = e_mail_browser_get_ui_manager (E_MAIL_BROWSER (window));
+
+	g_return_if_fail (ui_manager != NULL);
+	g_return_if_fail (GTK_IS_UI_MANAGER (ui_manager));
+
+	backend = e_mail_reader_get_backend (reader);
+	session = e_mail_backend_get_session (backend);
+	label_store = e_mail_ui_session_get_label_store (E_MAIL_UI_SESSION (session));
+
+	action_group = e_mail_reader_get_action_group (reader, E_MAIL_READER_ACTION_GROUP_LABELS);
+	main_menu_path = "/main-menu/custom-menus/mail-message-menu/mail-mark-as-menu/mail-label-menu/mail-label-actions";
+	popup_menu_path = "/mail-message-popup/mail-label-menu/mail-label-actions";
+
+	/* Unmerge the previous menu items. */
+	if (priv->main_menu_label_merge_id)
+		gtk_ui_manager_remove_ui (ui_manager, priv->main_menu_label_merge_id);
+	else
+		priv->main_menu_label_merge_id = gtk_ui_manager_new_merge_id (ui_manager);
+
+	if (priv->popup_menu_label_merge_id)
+		gtk_ui_manager_remove_ui (ui_manager, priv->popup_menu_label_merge_id);
+	else
+		priv->popup_menu_label_merge_id = gtk_ui_manager_new_merge_id (ui_manager);
+
+	e_action_group_remove_all_actions (action_group);
+	gtk_ui_manager_ensure_update (ui_manager);
+
+	uids = e_mail_reader_get_selected_uids (reader);
+	labels_info = mail_reader_gather_labels_info (reader, label_store, uids);
+
+	valid = gtk_tree_model_get_iter_first (GTK_TREE_MODEL (label_store), &iter);
+
+	while (valid) {
+		EMailLabelAction *label_action;
+		GtkAction *action;
+		gchar *action_name;
+		gchar *stock_id;
+		gchar *label;
+		gchar *tag;
+
+		label = e_mail_label_list_store_get_name (label_store, &iter);
+		stock_id = e_mail_label_list_store_get_stock_id (label_store, &iter);
+		tag = e_mail_label_list_store_get_tag (label_store, &iter);
+		action_name = g_strdup_printf ("mail-label-%d", ii);
+
+		/* XXX Add a tooltip! */
+		label_action = e_mail_label_action_new (action_name, label, NULL, stock_id);
+
+		g_object_set_data_full (
+			G_OBJECT (label_action), "tag",
+			tag, (GDestroyNotify) g_free);
+
+		/* Configure the action before we connect to signals. */
+		mail_reader_update_label_action (GTK_TOGGLE_ACTION (label_action), labels_info, tag);
+
+		g_signal_connect (
+			label_action, "toggled",
+			G_CALLBACK (action_mail_label_cb), reader);
+
+		/* The action group takes ownership of the action. */
+		action = GTK_ACTION (label_action);
+
+		if (ii + 1 < 10) {
+			gchar accel[5];
+
+			accel[0] = '1' + ii;
+			accel[1] = '\0';
+
+			gtk_action_group_add_action_with_accel (action_group, action, accel);
+		} else {
+			gtk_action_group_add_action (action_group, action);
+		}
+		g_object_unref (label_action);
+
+		gtk_ui_manager_add_ui (
+			ui_manager, priv->main_menu_label_merge_id, main_menu_path,
+			action_name, action_name, GTK_UI_MANAGER_AUTO, FALSE);
+
+		gtk_ui_manager_add_ui (
+			ui_manager, priv->popup_menu_label_merge_id, popup_menu_path,
+			action_name, action_name, GTK_UI_MANAGER_AUTO, FALSE);
+
+		g_free (label);
+		g_free (stock_id);
+		g_free (action_name);
+
+		valid = gtk_tree_model_iter_next (
+			GTK_TREE_MODEL (label_store), &iter);
+		ii++;
+	}
+
+	g_hash_table_destroy (labels_info);
+	g_ptr_array_unref (uids);
+}
+
+static void
+mail_reader_update_actions (EMailReader *reader,
+                            guint32 state)
+{
+	GtkAction *action;
+	const gchar *action_name;
+	gboolean sensitive;
+	EMailDisplay *mail_display;
+
+	/* Be descriptive. */
+	gboolean any_messages_selected;
+	gboolean enable_flag_clear;
+	gboolean enable_flag_completed;
+	gboolean have_enabled_account;
+	gboolean multiple_messages_selected;
+	gboolean selection_has_attachment_messages;
+	gboolean selection_has_deleted_messages;
+	gboolean selection_has_ignore_thread_messages;
+	gboolean selection_has_notignore_thread_messages;
+	gboolean selection_has_important_messages;
+	gboolean selection_has_junk_messages;
+	gboolean selection_has_not_junk_messages;
+	gboolean selection_has_read_messages;
+	gboolean selection_has_undeleted_messages;
+	gboolean selection_has_unimportant_messages;
+	gboolean selection_has_unread_messages;
+	gboolean selection_has_mail_note;
+	gboolean selection_has_color;
+	gboolean selection_is_mailing_list;
+	gboolean single_message_selected;
+	gboolean first_message_selected = FALSE;
+	gboolean last_message_selected = FALSE;
+
+	have_enabled_account =
+		(state & E_MAIL_READER_HAVE_ENABLED_ACCOUNT);
+	single_message_selected =
+		(state & E_MAIL_READER_SELECTION_SINGLE);
+	multiple_messages_selected =
+		(state & E_MAIL_READER_SELECTION_MULTIPLE);
+	/* FIXME Missing CAN_ADD_SENDER */
+	enable_flag_clear =
+		(state & E_MAIL_READER_SELECTION_FLAG_CLEAR);
+	enable_flag_completed =
+		(state & E_MAIL_READER_SELECTION_FLAG_COMPLETED);
+	selection_has_attachment_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_ATTACHMENTS);
+	selection_has_deleted_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_DELETED);
+	selection_has_ignore_thread_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_IGNORE_THREAD);
+	selection_has_notignore_thread_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_NOTIGNORE_THREAD);
+	selection_has_important_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_IMPORTANT);
+	selection_has_junk_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_JUNK);
+	selection_has_not_junk_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_NOT_JUNK);
+	selection_has_read_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_READ);
+	selection_has_undeleted_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_UNDELETED);
+	selection_has_unimportant_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_UNIMPORTANT);
+	selection_has_unread_messages =
+		(state & E_MAIL_READER_SELECTION_HAS_UNREAD);
+	selection_has_mail_note =
+		(state & E_MAIL_READER_SELECTION_HAS_MAIL_NOTE);
+	selection_has_color =
+		(state & E_MAIL_READER_SELECTION_HAS_COLOR);
+	selection_is_mailing_list =
+		(state & E_MAIL_READER_SELECTION_IS_MAILING_LIST);
+
+	any_messages_selected =
+		(single_message_selected || multiple_messages_selected);
+
+	mail_display = e_mail_reader_get_mail_display (reader);
+
+	if (any_messages_selected) {
+		MessageList *message_list;
+		gint row = -1, count = -1;
+		ETreeTableAdapter *etta;
+		ETreePath node = NULL;
+
+		message_list = MESSAGE_LIST (
+			e_mail_reader_get_message_list (reader));
+		etta = e_tree_get_table_adapter (E_TREE (message_list));
+
+		if (message_list->cursor_uid != NULL)
+			node = g_hash_table_lookup (
+				message_list->uid_nodemap,
+				message_list->cursor_uid);
+
+		if (node != NULL) {
+			row = e_tree_table_adapter_row_of_node (etta, node);
+			count = e_table_model_row_count (E_TABLE_MODEL (etta));
+		}
+
+		first_message_selected = row <= 0;
+		last_message_selected = row < 0 || row + 1 >= count;
+	}
+
+	action_name = "mail-add-sender";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-archive";
+	sensitive = any_messages_selected && (state & E_MAIL_READER_FOLDER_ARCHIVE_FOLDER_SET) != 0;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-check-for-junk";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-color-assign";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-color-unset";
+	sensitive = any_messages_selected && selection_has_color;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-copy";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-create-menu";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	/* If a single message is selected, let the user hit delete to
+	 * advance the cursor even if the message is already deleted. */
+	action_name = "mail-delete";
+	sensitive =
+		(single_message_selected ||
+		selection_has_undeleted_messages) &&
+		(state & E_MAIL_READER_FOLDER_IS_VTRASH) == 0;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-add-note";
+	sensitive = single_message_selected && !selection_has_mail_note;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-edit-note";
+	sensitive = single_message_selected && selection_has_mail_note;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-delete-note";
+	sensitive = single_message_selected && selection_has_mail_note;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-filters-apply";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-filter-rule-for-mailing-list";
+	sensitive = single_message_selected && selection_is_mailing_list;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-find";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-flag-clear";
+	sensitive = enable_flag_clear;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-flag-completed";
+	sensitive = enable_flag_completed;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-flag-for-followup";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward";
+	sensitive = have_enabled_account && any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-attached";
+	sensitive = have_enabled_account && any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-attached-full";
+	sensitive = have_enabled_account && any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-as-menu";
+	sensitive = have_enabled_account && any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-inline";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-inline-full";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-quoted";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-forward-quoted-full";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-goto-menu";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-load-images";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-as-menu";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-ignore-thread-sub";
+	sensitive = selection_has_notignore_thread_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-mark-ignore-thread-whole";
+	sensitive = selection_has_notignore_thread_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-mark-important";
+	sensitive = selection_has_unimportant_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-junk";
+	sensitive = selection_has_not_junk_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-notjunk";
+	sensitive = selection_has_junk_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-read";
+	sensitive = selection_has_unread_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-unignore-thread-sub";
+	sensitive = selection_has_ignore_thread_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-mark-unignore-thread-whole";
+	sensitive = selection_has_ignore_thread_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+	gtk_action_set_visible (action, sensitive);
+
+	action_name = "mail-mark-unimportant";
+	sensitive = selection_has_important_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-mark-unread";
+	sensitive = selection_has_read_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-message-edit";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-message-new";
+	sensitive = have_enabled_account;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-message-open";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-move";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-next";
+	sensitive = any_messages_selected && !last_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-next-important";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-next-thread";
+	sensitive = single_message_selected && !last_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-next-unread";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-previous";
+	sensitive = any_messages_selected && !first_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-previous-important";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-previous-unread";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-previous-thread";
+	sensitive = any_messages_selected && !first_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-print";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-print-preview";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-redirect";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-remove-attachments";
+	sensitive = any_messages_selected && selection_has_attachment_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-remove-duplicates";
+	sensitive = multiple_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-reply-all";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-reply-alternative";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-reply-group";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-reply-group-menu";
+	sensitive = have_enabled_account && any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-reply-list";
+	sensitive = have_enabled_account && single_message_selected &&
+		selection_is_mailing_list;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-reply-sender";
+	sensitive = have_enabled_account && single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-save-as";
+	sensitive = any_messages_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-show-source";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-undelete";
+	sensitive = selection_has_deleted_messages;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-zoom-100";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-zoom-in";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action_name = "mail-zoom-out";
+	sensitive = single_message_selected;
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_sensitive (action, sensitive);
+
+	action = e_mail_reader_get_action (reader, "mail-search-web");
+	gtk_action_set_sensitive (action, single_message_selected &&
+		mail_display && e_web_view_has_selection (E_WEB_VIEW (mail_display)));
+
+	mail_reader_update_labels_menu (reader);
+}
+
+static gboolean
+mail_reader_close_on_delete_or_junk (EMailReader *reader)
+{
+	return FALSE;
+}
+
+static void
+mail_reader_init_charset_actions (EMailReader *reader,
+                                  GtkActionGroup *action_group)
+{
+	GtkRadioAction *default_action;
+	GSList *radio_group;
+
+	radio_group = e_charset_add_radio_actions (
+		action_group, "mail-charset-", NULL,
+		G_CALLBACK (action_mail_charset_cb), reader);
+
+	/* XXX Add a tooltip! */
+	default_action = gtk_radio_action_new (
+		"mail-charset-default", _("Default"), NULL, NULL, -1);
+
+	gtk_radio_action_set_group (default_action, radio_group);
+
+	g_signal_connect (
+		default_action, "changed",
+		G_CALLBACK (action_mail_charset_cb), reader);
+
+	gtk_action_group_add_action (
+		action_group, GTK_ACTION (default_action));
+
+	gtk_radio_action_set_current_value (default_action, -1);
+}
+
+static void
+e_mail_reader_default_init (EMailReaderInterface *iface)
+{
+	quark_private = g_quark_from_static_string ("e-mail-reader-private");
+
+	iface->get_alert_sink = mail_reader_get_alert_sink;
+	iface->get_selected_uids = mail_reader_get_selected_uids;
+	iface->get_selected_uids_with_collapsed_threads = mail_reader_get_selected_uids_with_collapsed_threads;
+	iface->ref_folder = mail_reader_ref_folder;
+	iface->set_folder = mail_reader_set_folder;
+	iface->set_message = mail_reader_set_message;
+	iface->open_selected_mail = e_mail_reader_open_selected;
+	iface->folder_loaded = mail_reader_folder_loaded;
+	iface->message_loaded = mail_reader_message_loaded;
+	iface->message_seen = mail_reader_message_seen;
+	iface->show_search_bar = mail_reader_show_search_bar;
+	iface->update_actions = mail_reader_update_actions;
+	iface->close_on_delete_or_junk = mail_reader_close_on_delete_or_junk;
+	iface->reload = mail_reader_reload;
+	iface->remove_ui = mail_reader_remove_ui;
+
+	g_object_interface_install_property (
+		iface,
+		g_param_spec_enum (
+			"forward-style",
+			"Forward Style",
+			"How to forward messages",
+			E_TYPE_MAIL_FORWARD_STYLE,
+			E_MAIL_FORWARD_STYLE_ATTACHED,
+			G_PARAM_READWRITE));
+
+	g_object_interface_install_property (
+		iface,
+		g_param_spec_boolean (
+			"group-by-threads",
+			"Group by Threads",
+			"Whether to group messages by threads",
+			FALSE,
+			G_PARAM_READWRITE));
+
+	g_object_interface_install_property (
+		iface,
+		g_param_spec_enum (
+			"reply-style",
+			"Reply Style",
+			"How to reply to messages",
+			E_TYPE_MAIL_REPLY_STYLE,
+			E_MAIL_REPLY_STYLE_QUOTED,
+			G_PARAM_READWRITE));
+
+	g_object_interface_install_property (
+		iface,
+		g_param_spec_boolean (
+			"mark-seen-always",
+			"Mark Seen Always",
+			"Whether to mark unread message seen even after folder change",
+			FALSE,
+			G_PARAM_READWRITE));
+
+	g_object_interface_install_property (
+		iface,
+		g_param_spec_boolean (
+			"delete-selects-previous",
+			"Delete Selects Previous",
+			"Whether go to the previous message after message deletion",
+			FALSE,
+			G_PARAM_READWRITE));
+
+	signals[CHANGED] = g_signal_new (
+		"changed",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_FIRST,
+		0, NULL, NULL,
+		g_cclosure_marshal_VOID__VOID,
+		G_TYPE_NONE, 0);
+
+	signals[COMPOSER_CREATED] = g_signal_new (
+		"composer-created",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_FIRST,
+		G_STRUCT_OFFSET (EMailReaderInterface, composer_created),
+		NULL, NULL, NULL,
+		G_TYPE_NONE, 2,
+		E_TYPE_MSG_COMPOSER,
+		CAMEL_TYPE_MIME_MESSAGE);
+
+	signals[FOLDER_LOADED] = g_signal_new (
+		"folder-loaded",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_FIRST,
+		G_STRUCT_OFFSET (EMailReaderInterface, folder_loaded),
+		NULL, NULL,
+		g_cclosure_marshal_VOID__VOID,
+		G_TYPE_NONE, 0);
+
+	signals[MESSAGE_LOADED] = g_signal_new (
+		"message-loaded",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_LAST,
+		G_STRUCT_OFFSET (EMailReaderInterface, message_loaded),
+		NULL, NULL,
+		e_marshal_VOID__STRING_OBJECT,
+		G_TYPE_NONE, 2,
+		G_TYPE_STRING,
+		CAMEL_TYPE_MIME_MESSAGE);
+
+	signals[MESSAGE_SEEN] = g_signal_new (
+		"message-seen",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_LAST,
+		G_STRUCT_OFFSET (EMailReaderInterface, message_seen),
+		NULL, NULL,
+		e_marshal_VOID__STRING_OBJECT,
+		G_TYPE_NONE, 2,
+		G_TYPE_STRING,
+		CAMEL_TYPE_MIME_MESSAGE);
+
+	signals[SHOW_SEARCH_BAR] = g_signal_new (
+		"show-search-bar",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,
+		G_STRUCT_OFFSET (EMailReaderInterface, show_search_bar),
+		NULL, NULL,
+		g_cclosure_marshal_VOID__VOID,
+		G_TYPE_NONE, 0);
+
+	signals[UPDATE_ACTIONS] = g_signal_new (
+		"update-actions",
+		G_OBJECT_CLASS_TYPE (iface),
+		G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,
+		G_STRUCT_OFFSET (EMailReaderInterface, update_actions),
+		NULL, NULL,
+		g_cclosure_marshal_VOID__UINT,
+		G_TYPE_NONE, 1,
+		G_TYPE_UINT);
+}
+
+void
+e_mail_reader_init (EMailReader *reader,
+                    gboolean init_actions,
+                    gboolean connect_signals)
+{
+	EMenuToolAction *menu_tool_action;
+	GtkActionGroup *action_group;
+	GtkWidget *message_list;
+	GtkAction *action;
+	const gchar *action_name;
+	EMailDisplay *display;
+	GSettings *settings;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	message_list = e_mail_reader_get_message_list (reader);
+	display = e_mail_reader_get_mail_display (reader);
+
+	/* Initialize a private struct. */
+	g_object_set_qdata_full (
+		G_OBJECT (reader), quark_private,
+		g_slice_new0 (EMailReaderPrivate),
+		(GDestroyNotify) mail_reader_private_free);
+
+	e_binding_bind_property (
+		reader, "group-by-threads",
+		message_list, "group-by-threads",
+		G_BINDING_SYNC_CREATE);
+
+	if (!init_actions)
+		goto connect_signals;
+
+	/* Add the "standard" EMailReader actions. */
+
+	action_group = e_mail_reader_get_action_group (
+		reader, E_MAIL_READER_ACTION_GROUP_STANDARD);
+
+	/* The "mail-forward" action is special: it uses a GtkMenuToolButton
+	 * for its toolbar item type.  So we have to create it separately. */
+
+	menu_tool_action = e_menu_tool_action_new (
+		"mail-forward", _("_Forward"),
+		_("Forward the selected message to someone"));
+
+	gtk_action_set_icon_name (
+		GTK_ACTION (menu_tool_action), "mail-forward");
+
+	g_signal_connect (
+		menu_tool_action, "activate",
+		G_CALLBACK (action_mail_forward_cb), reader);
+
+	gtk_action_group_add_action_with_accel (
+		action_group, GTK_ACTION (menu_tool_action), "<Control>f");
+
+	/* Likewise the "mail-reply-group" action. */
+
+	menu_tool_action = e_menu_tool_action_new (
+		/* For Translators: "Group Reply" will reply either to a mailing list
+		 * (if possible and if that configuration option is enabled), or else
+		 * it will reply to all. The word "Group" was chosen because it covers
+		 * either of those, without too strongly implying one or the other. */
+		"mail-reply-group", _("Group Reply"),
+		_("Reply to the mailing list, or to all recipients"));
+
+	gtk_action_set_icon_name (
+		GTK_ACTION (menu_tool_action), "mail-reply-all");
+
+	g_signal_connect (
+		menu_tool_action, "activate",
+		G_CALLBACK (action_mail_reply_group_cb), reader);
+
+	gtk_action_group_add_action_with_accel (
+		action_group, GTK_ACTION (menu_tool_action), "<Control>g");
+
+	/* Add the other actions the normal way. */
+	gtk_action_group_add_actions (
+		action_group, mail_reader_entries,
+		G_N_ELEMENTS (mail_reader_entries), reader);
+	e_action_group_add_popup_actions (
+		action_group, mail_reader_popup_entries,
+		G_N_ELEMENTS (mail_reader_popup_entries));
+	gtk_action_group_add_toggle_actions (
+		action_group, mail_reader_toggle_entries,
+		G_N_ELEMENTS (mail_reader_toggle_entries), reader);
+
+	mail_reader_init_charset_actions (reader, action_group);
+
+	/* Add EMailReader actions for Search Folders.  The action group
+	 * should be made invisible if Search Folders are disabled. */
+
+	action_group = e_mail_reader_get_action_group (
+		reader, E_MAIL_READER_ACTION_GROUP_SEARCH_FOLDERS);
+
+	gtk_action_group_add_actions (
+		action_group, mail_reader_search_folder_entries,
+		G_N_ELEMENTS (mail_reader_search_folder_entries), reader);
+
+	display = e_mail_reader_get_mail_display (reader);
+
+	/* Bind GObject properties to GSettings keys. */
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	action_name = "mail-caret-mode";
+	action = e_mail_reader_get_action (reader, action_name);
+	g_settings_bind (
+		settings, "caret-mode",
+		action, "active", G_SETTINGS_BIND_DEFAULT);
+
+	action_name = "mail-show-all-headers";
+	action = e_mail_reader_get_action (reader, action_name);
+	g_settings_bind (
+		settings, "show-all-headers",
+		action, "active", G_SETTINGS_BIND_DEFAULT);
+
+	/* Mode change when viewing message source is ignored. */
+	if (e_mail_display_get_mode (display) == E_MAIL_FORMATTER_MODE_SOURCE ||
+	    e_mail_display_get_mode (display) == E_MAIL_FORMATTER_MODE_RAW) {
+		gtk_action_set_sensitive (action, FALSE);
+		gtk_action_set_visible (action, FALSE);
+	}
+
+	g_object_unref (settings);
+
+	/* Fine tuning. */
+
+	action_name = "mail-delete";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_short_label (action, _("Delete"));
+
+	action_name = "mail-forward";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_is_important (action, TRUE);
+
+	action_name = "mail-reply-group";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_is_important (action, TRUE);
+
+	action_name = "mail-next";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_short_label (action, _("Next"));
+
+	action_name = "mail-previous";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_short_label (action, _("Previous"));
+
+	action_name = "mail-reply-all";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_is_important (action, TRUE);
+
+	action_name = "mail-reply-sender";
+	action = e_mail_reader_get_action (reader, action_name);
+	gtk_action_set_is_important (action, TRUE);
+	gtk_action_set_short_label (action, _("Reply"));
+
+	action_name = "add-to-address-book";
+	action = e_mail_display_get_action (display, action_name);
+	g_signal_connect (
+		action, "activate",
+		G_CALLBACK (action_add_to_address_book_cb), reader);
+
+	action_name = "send-reply";
+	action = e_mail_display_get_action (display, action_name);
+	g_signal_connect (
+		action, "activate",
+		G_CALLBACK (action_mail_reply_recipient_cb), reader);
+
+	action_name = "search-folder-recipient";
+	action = e_mail_display_get_action (display, action_name);
+	g_signal_connect (
+		action, "activate",
+		G_CALLBACK (action_search_folder_recipient_cb), reader);
+
+	action_name = "search-folder-sender";
+	action = e_mail_display_get_action (display, action_name);
+	g_signal_connect (
+		action, "activate",
+		G_CALLBACK (action_search_folder_sender_cb), reader);
+
+#ifndef G_OS_WIN32
+	/* Lockdown integration. */
+
+	settings = e_util_ref_settings ("org.gnome.desktop.lockdown");
+
+	action_name = "mail-print";
+	action = e_mail_reader_get_action (reader, action_name);
+	g_settings_bind (
+		settings, "disable-printing",
+		action, "visible",
+		G_SETTINGS_BIND_GET |
+		G_SETTINGS_BIND_NO_SENSITIVITY |
+		G_SETTINGS_BIND_INVERT_BOOLEAN);
+
+	action_name = "mail-print-preview";
+	action = e_mail_reader_get_action (reader, action_name);
+	g_settings_bind (
+		settings, "disable-printing",
+		action, "visible",
+		G_SETTINGS_BIND_GET |
+		G_SETTINGS_BIND_NO_SENSITIVITY |
+		G_SETTINGS_BIND_INVERT_BOOLEAN);
+
+	action_name = "mail-save-as";
+	action = e_mail_reader_get_action (reader, action_name);
+	g_settings_bind (
+		settings, "disable-save-to-disk",
+		action, "visible",
+		G_SETTINGS_BIND_GET |
+		G_SETTINGS_BIND_NO_SENSITIVITY |
+		G_SETTINGS_BIND_INVERT_BOOLEAN);
+
+	g_object_unref (settings);
+#endif
+
+	/* Bind properties. */
+
+	action_name = "mail-caret-mode";
+	action = e_mail_reader_get_action (reader, action_name);
+
+	e_binding_bind_property (
+		action, "active",
+		display, "caret-mode",
+		G_BINDING_BIDIRECTIONAL |
+		G_BINDING_SYNC_CREATE);
+
+connect_signals:
+
+	if (!connect_signals)
+		return;
+
+	/* Connect signals. */
+	g_signal_connect_swapped (
+		display, "key-press-event",
+		G_CALLBACK (mail_reader_key_press_event_cb), reader);
+
+	g_signal_connect_swapped (
+		display, "load-changed",
+		G_CALLBACK (mail_reader_load_changed_cb), reader);
+
+	g_signal_connect_swapped (
+		display, "remote-content-clicked",
+		G_CALLBACK (mail_reader_remote_content_clicked_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "message-selected",
+		G_CALLBACK (mail_reader_message_selected_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "update-actions",
+		G_CALLBACK (mail_reader_message_list_suggest_update_actions_cb), reader);
+
+	/* re-schedule mark-as-seen,... */
+	g_signal_connect_swapped (
+		message_list, "cursor-change",
+		G_CALLBACK (mail_reader_message_cursor_change_cb), reader);
+
+	/* but do not mark-as-seen if... */
+	g_signal_connect_swapped (
+		message_list, "tree-drag-begin",
+		G_CALLBACK (discard_timeout_mark_seen_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "tree-drag-end",
+		G_CALLBACK (discard_timeout_mark_seen_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "right-click",
+		G_CALLBACK (discard_timeout_mark_seen_cb), reader);
+
+	g_signal_connect_swapped (
+		e_mail_reader_get_preview_pane (reader), "notify::visible",
+		G_CALLBACK (mail_reader_preview_pane_visible_changed_cb), reader);
+
+	g_signal_connect_after (
+		message_list, "message-list-built",
+		G_CALLBACK (mail_reader_message_list_built_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "double-click",
+		G_CALLBACK (mail_reader_double_click_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "key-press",
+		G_CALLBACK (mail_reader_key_press_cb), reader);
+
+	g_signal_connect_swapped (
+		message_list, "selection-change",
+		G_CALLBACK (e_mail_reader_changed), reader);
+}
+
+static void
+mail_reader_ongoing_operation_destroyed (gpointer user_data,
+					 GObject *cancellable)
+{
+	EMailReader *reader = user_data;
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	priv->ongoing_operations = g_slist_remove (priv->ongoing_operations, cancellable);
+}
+
+void
+e_mail_reader_dispose (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	EMailDisplay *mail_display;
+	GtkWidget *message_list;
+	GSList *ongoing_operations, *link;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (priv->message_selected_timeout_id > 0) {
+		g_source_remove (priv->message_selected_timeout_id);
+		priv->message_selected_timeout_id = 0;
+	}
+
+	if (priv->retrieving_message)
+		g_cancellable_cancel (priv->retrieving_message);
+
+	ongoing_operations = g_slist_copy_deep (priv->ongoing_operations, (GCopyFunc) g_object_ref, NULL);
+	g_slist_free (priv->ongoing_operations);
+	priv->ongoing_operations = NULL;
+
+	for (link = ongoing_operations; link; link = g_slist_next (link)) {
+		GCancellable *cancellable = link->data;
+
+		g_object_weak_unref (G_OBJECT (cancellable), mail_reader_ongoing_operation_destroyed, reader);
+
+		g_cancellable_cancel (cancellable);
+	}
+
+	g_slist_free_full (ongoing_operations, g_object_unref);
+
+	mail_display = e_mail_reader_get_mail_display (reader);
+	if (mail_display)
+		g_signal_handlers_disconnect_by_data (mail_display, reader);
+
+	message_list = e_mail_reader_get_message_list (reader);
+	if (message_list)
+		g_signal_handlers_disconnect_by_data (message_list, reader);
+}
+
+void
+e_mail_reader_changed (EMailReader *reader)
+{
+	MessageList *message_list;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	g_signal_emit (reader, signals[CHANGED], 0);
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+
+	if (!message_list || message_list_selected_count (message_list) != 1)
+		mail_reader_remove_followup_alert (reader);
+}
+
+guint32
+e_mail_reader_check_state (EMailReader *reader)
+{
+	EShell *shell;
+	GPtrArray *uids;
+	CamelFolder *folder;
+	CamelStore *store = NULL;
+	EMailBackend *backend;
+	ESourceRegistry *registry;
+	EMailSession *mail_session;
+	EMailAccountStore *account_store;
+	const gchar *tag;
+	gboolean can_clear_flags = FALSE;
+	gboolean can_flag_completed = FALSE;
+	gboolean can_flag_for_followup = FALSE;
+	gboolean has_attachments = FALSE;
+	gboolean has_deleted = FALSE;
+	gboolean has_ignore_thread = FALSE;
+	gboolean has_notignore_thread = FALSE;
+	gboolean has_important = FALSE;
+	gboolean has_junk = FALSE;
+	gboolean has_not_junk = FALSE;
+	gboolean has_read = FALSE;
+	gboolean has_undeleted = FALSE;
+	gboolean has_unimportant = FALSE;
+	gboolean has_unread = FALSE;
+	gboolean has_mail_note = FALSE;
+	gboolean has_color = FALSE;
+	gboolean have_enabled_account = FALSE;
+	gboolean drafts_or_outbox = FALSE;
+	gboolean is_mailing_list;
+	gboolean is_junk_folder = FALSE;
+	gboolean is_vtrash_folder = FALSE;
+	gboolean archive_folder_set = FALSE;
+	guint32 state = 0;
+	guint ii;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), 0);
+
+	backend = e_mail_reader_get_backend (reader);
+	shell = e_shell_backend_get_shell (E_SHELL_BACKEND (backend));
+	registry = e_shell_get_registry (shell);
+	mail_session = e_mail_backend_get_session (backend);
+	account_store = e_mail_ui_session_get_account_store (
+		E_MAIL_UI_SESSION (mail_session));
+
+	folder = e_mail_reader_ref_folder (reader);
+	uids = e_mail_reader_get_selected_uids_with_collapsed_threads (reader);
+
+	if (folder != NULL) {
+		gchar *archive_folder;
+		guint32 folder_flags;
+
+		store = camel_folder_get_parent_store (folder);
+		folder_flags = camel_folder_get_flags (folder);
+		is_junk_folder = (folder_flags & CAMEL_FOLDER_IS_JUNK) != 0;
+		is_vtrash_folder = (camel_store_get_flags (store) & CAMEL_STORE_VTRASH) != 0 && (folder_flags & CAMEL_FOLDER_IS_TRASH) != 0;
+		drafts_or_outbox =
+			em_utils_folder_is_drafts (registry, folder) ||
+			em_utils_folder_is_outbox (registry, folder);
+
+		archive_folder = em_utils_get_archive_folder_uri_from_folder (folder, backend, uids, TRUE);
+		if (archive_folder && *archive_folder)
+			archive_folder_set = TRUE;
+
+		g_free (archive_folder);
+	}
+
+	/* Initialize this flag based on whether there are any
+	 * messages selected.  We will update it in the loop. */
+	is_mailing_list = (uids->len > 0);
+
+	for (ii = 0; ii < uids->len; ii++) {
+		CamelMessageInfo *info;
+		const gchar *string;
+		guint32 flags;
+
+		info = camel_folder_get_message_info (
+			folder, uids->pdata[ii]);
+		if (info == NULL)
+			continue;
+
+		flags = camel_message_info_get_flags (info);
+
+		if (flags & CAMEL_MESSAGE_SEEN)
+			has_read = TRUE;
+		else
+			has_unread = TRUE;
+
+		if (flags & CAMEL_MESSAGE_ATTACHMENTS)
+			has_attachments = TRUE;
+
+		if (drafts_or_outbox) {
+			has_junk = FALSE;
+			has_not_junk = FALSE;
+		} else {
+			guint32 bitmask;
+
+			/* XXX Strictly speaking, this logic is correct.
+			 *     Problem is there's nothing in the message
+			 *     list that indicates whether a message is
+			 *     already marked "Not Junk".  So the user may
+			 *     think the "Not Junk" button is enabling and
+			 *     disabling itself randomly as he reads mail. */
+
+			if (flags & CAMEL_MESSAGE_JUNK)
+				has_junk = TRUE;
+			if (flags & CAMEL_MESSAGE_NOTJUNK)
+				has_not_junk = TRUE;
+
+			bitmask = CAMEL_MESSAGE_JUNK | CAMEL_MESSAGE_NOTJUNK;
+
+			/* If neither junk flag is set, the
+			 * message can be marked either way. */
+			if ((flags & bitmask) == 0) {
+				has_junk = TRUE;
+				has_not_junk = TRUE;
+			}
+		}
+
+		if (flags & CAMEL_MESSAGE_DELETED)
+			has_deleted = TRUE;
+		else
+			has_undeleted = TRUE;
+
+		if (flags & CAMEL_MESSAGE_FLAGGED)
+			has_important = TRUE;
+		else
+			has_unimportant = TRUE;
+
+		tag = camel_message_info_get_user_tag (info, "follow-up");
+		if (tag != NULL && *tag != '\0') {
+			can_clear_flags = TRUE;
+			tag = camel_message_info_get_user_tag (
+				info, "completed-on");
+			if (tag == NULL || *tag == '\0')
+				can_flag_completed = TRUE;
+		} else
+			can_flag_for_followup = TRUE;
+
+		string = camel_message_info_get_mlist (info);
+		is_mailing_list &= (string != NULL && *string != '\0');
+
+		has_ignore_thread = has_ignore_thread || camel_message_info_get_user_flag (info, "ignore-thread");
+		has_notignore_thread = has_notignore_thread || !camel_message_info_get_user_flag (info, "ignore-thread");
+		has_mail_note = has_mail_note || camel_message_info_get_user_flag (info, E_MAIL_NOTES_USER_FLAG);
+		has_color = has_color || camel_message_info_get_user_tag (info, "color") != NULL;
+
+		g_clear_object (&info);
+	}
+
+	have_enabled_account =
+		e_mail_account_store_have_enabled_service (
+		account_store, CAMEL_TYPE_STORE);
+
+	if (have_enabled_account)
+		state |= E_MAIL_READER_HAVE_ENABLED_ACCOUNT;
+	if (uids->len == 1)
+		state |= E_MAIL_READER_SELECTION_SINGLE;
+	if (uids->len > 1)
+		state |= E_MAIL_READER_SELECTION_MULTIPLE;
+	if (!drafts_or_outbox && uids->len == 1)
+		state |= E_MAIL_READER_SELECTION_CAN_ADD_SENDER;
+	if (can_clear_flags)
+		state |= E_MAIL_READER_SELECTION_FLAG_CLEAR;
+	if (can_flag_completed)
+		state |= E_MAIL_READER_SELECTION_FLAG_COMPLETED;
+	if (can_flag_for_followup)
+		state |= E_MAIL_READER_SELECTION_FLAG_FOLLOWUP;
+	if (has_attachments)
+		state |= E_MAIL_READER_SELECTION_HAS_ATTACHMENTS;
+	if (has_deleted)
+		state |= E_MAIL_READER_SELECTION_HAS_DELETED;
+	if (has_ignore_thread)
+		state |= E_MAIL_READER_SELECTION_HAS_IGNORE_THREAD;
+	if (has_notignore_thread)
+		state |= E_MAIL_READER_SELECTION_HAS_NOTIGNORE_THREAD;
+	if (has_important)
+		state |= E_MAIL_READER_SELECTION_HAS_IMPORTANT;
+	if (has_junk)
+		state |= E_MAIL_READER_SELECTION_HAS_JUNK;
+	if (has_not_junk)
+		state |= E_MAIL_READER_SELECTION_HAS_NOT_JUNK;
+	if (has_read)
+		state |= E_MAIL_READER_SELECTION_HAS_READ;
+	if (has_undeleted)
+		state |= E_MAIL_READER_SELECTION_HAS_UNDELETED;
+	if (has_unimportant)
+		state |= E_MAIL_READER_SELECTION_HAS_UNIMPORTANT;
+	if (has_unread)
+		state |= E_MAIL_READER_SELECTION_HAS_UNREAD;
+	if (is_mailing_list)
+		state |= E_MAIL_READER_SELECTION_IS_MAILING_LIST;
+	if (is_junk_folder)
+		state |= E_MAIL_READER_FOLDER_IS_JUNK;
+	if (is_vtrash_folder)
+		state |= E_MAIL_READER_FOLDER_IS_VTRASH;
+	if (archive_folder_set)
+		state |= E_MAIL_READER_FOLDER_ARCHIVE_FOLDER_SET;
+	if (has_mail_note)
+		state |= E_MAIL_READER_SELECTION_HAS_MAIL_NOTE;
+	if (has_color)
+		state |= E_MAIL_READER_SELECTION_HAS_COLOR;
+
+	if (!(state & E_MAIL_READER_SELECTION_SINGLE)) {
+		GPtrArray *real_selected_uids;
+
+		real_selected_uids = e_mail_reader_get_selected_uids (reader);
+
+		if (real_selected_uids && real_selected_uids->len == 1) {
+			state |= E_MAIL_READER_SELECTION_SINGLE;
+		}
+
+		if (real_selected_uids)
+			g_ptr_array_unref (real_selected_uids);
+	}
+
+	g_clear_object (&folder);
+	g_ptr_array_unref (uids);
+
+	return state;
+}
+
+EActivity *
+e_mail_reader_new_activity (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	EActivity *activity;
+	EMailBackend *backend;
+	EAlertSink *alert_sink;
+	GCancellable *cancellable;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	activity = e_activity_new ();
+
+	alert_sink = e_mail_reader_get_alert_sink (reader);
+	e_activity_set_alert_sink (activity, alert_sink);
+
+	cancellable = camel_operation_new ();
+
+	priv->ongoing_operations = g_slist_prepend (priv->ongoing_operations, cancellable);
+	g_object_weak_ref (G_OBJECT (cancellable), mail_reader_ongoing_operation_destroyed, reader);
+
+	e_activity_set_cancellable (activity, cancellable);
+	g_object_unref (cancellable);
+
+	backend = e_mail_reader_get_backend (reader);
+	e_shell_backend_add_activity (E_SHELL_BACKEND (backend), activity);
+
+	return activity;
+}
+
+void
+e_mail_reader_update_actions (EMailReader *reader,
+                              guint32 state)
+{
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	g_signal_emit (reader, signals[UPDATE_ACTIONS], 0, state);
+}
+
+GtkAction *
+e_mail_reader_get_action (EMailReader *reader,
+                          const gchar *action_name)
+{
+	GtkAction *action = NULL;
+	gint ii;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+	g_return_val_if_fail (action_name != NULL, NULL);
+
+	for (ii = 0; ii < E_MAIL_READER_NUM_ACTION_GROUPS; ii++) {
+		GtkActionGroup *group;
+
+		group = e_mail_reader_get_action_group (reader, ii);
+		action = gtk_action_group_get_action (group, action_name);
+
+		if (action != NULL)
+			break;
+	}
+
+	if (action == NULL)
+		g_critical (
+			"%s: action '%s' not found", G_STRFUNC, action_name);
+
+	return action;
+}
+
+GtkActionGroup *
+e_mail_reader_get_action_group (EMailReader *reader,
+                                EMailReaderActionGroup group)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_action_group != NULL, NULL);
+
+	return iface->get_action_group (reader, group);
+}
+
+EAlertSink *
+e_mail_reader_get_alert_sink (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_alert_sink != NULL, NULL);
+
+	return iface->get_alert_sink (reader);
+}
+
+EMailBackend *
+e_mail_reader_get_backend (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_backend != NULL, NULL);
+
+	return iface->get_backend (reader);
+}
+
+EMailDisplay *
+e_mail_reader_get_mail_display (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_mail_display != NULL, NULL);
+
+	return iface->get_mail_display (reader);
+}
+
+gboolean
+e_mail_reader_get_hide_deleted (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), FALSE);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_hide_deleted != NULL, FALSE);
+
+	return iface->get_hide_deleted (reader);
+}
+
+GtkWidget *
+e_mail_reader_get_message_list (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_message_list != NULL, NULL);
+
+	return iface->get_message_list (reader);
+}
+
+static void
+e_mail_reader_popup_menu_deactivate_cb (GtkMenu *popup_menu,
+					EMailReader *reader)
+{
+	g_return_if_fail (GTK_IS_MENU (popup_menu));
+
+	g_signal_handlers_disconnect_by_func (popup_menu, e_mail_reader_popup_menu_deactivate_cb, reader);
+	gtk_menu_detach (popup_menu);
+}
+
+GtkMenu *
+e_mail_reader_get_popup_menu (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+	GtkMenu *menu;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_popup_menu != NULL, NULL);
+
+	menu = iface->get_popup_menu (reader);
+	if (!gtk_menu_get_attach_widget (GTK_MENU (menu))) {
+		gtk_menu_attach_to_widget (GTK_MENU (menu),
+					   GTK_WIDGET (reader),
+					   NULL);
+		g_signal_connect (
+			menu, "deactivate",
+			G_CALLBACK (e_mail_reader_popup_menu_deactivate_cb), reader);
+	}
+
+	return menu;
+}
+
+EPreviewPane *
+e_mail_reader_get_preview_pane (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_preview_pane != NULL, NULL);
+
+	return iface->get_preview_pane (reader);
+}
+
+GPtrArray *
+e_mail_reader_get_selected_uids (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_selected_uids != NULL, NULL);
+
+	return iface->get_selected_uids (reader);
+}
+
+GPtrArray *
+e_mail_reader_get_selected_uids_with_collapsed_threads (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_selected_uids_with_collapsed_threads != NULL, NULL);
+
+	return iface->get_selected_uids_with_collapsed_threads (reader);
+}
+
+GtkWindow *
+e_mail_reader_get_window (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->get_window != NULL, NULL);
+
+	return iface->get_window (reader);
+}
+
+gboolean
+e_mail_reader_close_on_delete_or_junk (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), FALSE);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+
+	return iface->close_on_delete_or_junk != NULL &&
+	       iface->close_on_delete_or_junk (reader);
+}
+
+CamelFolder *
+e_mail_reader_ref_folder (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), NULL);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->ref_folder != NULL, NULL);
+
+	return iface->ref_folder (reader);
+}
+
+void
+e_mail_reader_set_folder (EMailReader *reader,
+                          CamelFolder *folder)
+{
+	EMailReaderInterface *iface;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_if_fail (iface->set_folder != NULL);
+
+	iface->set_folder (reader, folder);
+}
+
+void
+e_mail_reader_set_message (EMailReader *reader,
+                           const gchar *message_uid)
+{
+	EMailReaderInterface *iface;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_if_fail (iface->set_message != NULL);
+
+	iface->set_message (reader, message_uid);
+}
+
+guint
+e_mail_reader_open_selected_mail (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), 0);
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_val_if_fail (iface->open_selected_mail != NULL, 0);
+
+	return iface->open_selected_mail (reader);
+}
+
+EMailForwardStyle
+e_mail_reader_get_forward_style (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), 0);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	return priv->forward_style;
+}
+
+void
+e_mail_reader_set_forward_style (EMailReader *reader,
+                                 EMailForwardStyle style)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (priv->forward_style == style)
+		return;
+
+	priv->forward_style = style;
+
+	g_object_notify (G_OBJECT (reader), "forward-style");
+}
+
+gboolean
+e_mail_reader_get_group_by_threads (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), FALSE);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	return priv->group_by_threads;
+}
+
+void
+e_mail_reader_set_group_by_threads (EMailReader *reader,
+                                    gboolean group_by_threads)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (priv->group_by_threads == group_by_threads)
+		return;
+
+	priv->group_by_threads = group_by_threads;
+
+	g_object_notify (G_OBJECT (reader), "group-by-threads");
+}
+
+EMailReplyStyle
+e_mail_reader_get_reply_style (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), 0);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	return priv->reply_style;
+}
+
+void
+e_mail_reader_set_reply_style (EMailReader *reader,
+                               EMailReplyStyle style)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (priv->reply_style == style)
+		return;
+
+	priv->reply_style = style;
+
+	g_object_notify (G_OBJECT (reader), "reply-style");
+}
+
+gboolean
+e_mail_reader_get_mark_seen_always (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), FALSE);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	return priv->mark_seen_always;
+}
+
+void
+e_mail_reader_set_mark_seen_always (EMailReader *reader,
+                                    gboolean mark_seen_always)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (priv->mark_seen_always == mark_seen_always)
+		return;
+
+	priv->mark_seen_always = mark_seen_always;
+
+	g_object_notify (G_OBJECT (reader), "mark-seen-always");
+}
+
+gboolean
+e_mail_reader_get_delete_selects_previous (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_val_if_fail (E_IS_MAIL_READER (reader), FALSE);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	return priv->delete_selects_previous;
+}
+
+void
+e_mail_reader_set_delete_selects_previous (EMailReader *reader,
+					   gboolean delete_selects_previous)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+
+	if (priv->delete_selects_previous == delete_selects_previous)
+		return;
+
+	priv->delete_selects_previous = delete_selects_previous;
+
+	g_object_notify (G_OBJECT (reader), "delete-selects-previous");
+}
+
+void
+e_mail_reader_create_charset_menu (EMailReader *reader,
+                                   GtkUIManager *ui_manager,
+                                   guint merge_id)
+{
+	GtkAction *action;
+	const gchar *action_name;
+	const gchar *path;
+	GSList *list;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+	g_return_if_fail (GTK_IS_UI_MANAGER (ui_manager));
+
+	action_name = "mail-charset-default";
+	action = e_mail_reader_get_action (reader, action_name);
+	g_return_if_fail (action != NULL);
+
+	list = gtk_radio_action_get_group (GTK_RADIO_ACTION (action));
+	list = g_slist_copy (list);
+	list = g_slist_remove (list, action);
+	list = g_slist_sort (list, (GCompareFunc) e_action_compare_by_label);
+
+	path = "/main-menu/view-menu/mail-message-view-actions/mail-encoding-menu";
+
+	while (list != NULL) {
+		action = list->data;
+
+		gtk_ui_manager_add_ui (
+			ui_manager, merge_id, path,
+			gtk_action_get_name (action),
+			gtk_action_get_name (action),
+			GTK_UI_MANAGER_AUTO, FALSE);
+
+		list = g_slist_delete_link (list, list);
+	}
+
+	gtk_ui_manager_ensure_update (ui_manager);
+}
+
+void
+e_mail_reader_show_search_bar (EMailReader *reader)
+{
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	g_signal_emit (reader, signals[SHOW_SEARCH_BAR], 0);
+}
+
+void
+e_mail_reader_avoid_next_mark_as_seen (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+	MessageList *message_list;
+
+	g_return_if_fail (reader != NULL);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	g_return_if_fail (priv != NULL);
+
+	message_list = MESSAGE_LIST (e_mail_reader_get_message_list (reader));
+	g_return_if_fail (message_list != NULL);
+
+	priv->avoid_next_mark_as_seen = TRUE;
+}
+
+void
+e_mail_reader_unset_folder_just_selected (EMailReader *reader)
+{
+	EMailReaderPrivate *priv;
+
+	g_return_if_fail (reader != NULL);
+
+	priv = E_MAIL_READER_GET_PRIVATE (reader);
+	g_return_if_fail (priv != NULL);
+
+	priv->folder_was_just_selected = FALSE;
+}
+
+/**
+ * e_mail_reader_composer_created:
+ * @reader: an #EMailReader
+ * @composer: an #EMsgComposer
+ * @message: the source #CamelMimeMessage, or %NULL
+ *
+ * Emits an #EMailReader::composer-created signal to indicate the @composer
+ * window was created in response to a user action on @reader.  Examples of
+ * such actions include replying, forwarding, and composing a new message.
+ * If applicable, the source @message (i.e. the message being replied to or
+ * forwarded) should be included.
+ **/
+void
+e_mail_reader_composer_created (EMailReader *reader,
+                                EMsgComposer *composer,
+                                CamelMimeMessage *message)
+{
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+	g_return_if_fail (E_IS_MSG_COMPOSER (composer));
+
+	if (message != NULL)
+		g_return_if_fail (CAMEL_IS_MIME_MESSAGE (message));
+
+	g_signal_emit (
+		reader, signals[COMPOSER_CREATED], 0, composer, message);
+}
+
+void
+e_mail_reader_reload (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_if_fail (iface->reload != NULL);
+
+	iface->reload (reader);
+}
+
+void
+e_mail_reader_remove_ui (EMailReader *reader)
+{
+	EMailReaderInterface *iface;
+
+	g_return_if_fail (E_IS_MAIL_READER (reader));
+
+	iface = E_MAIL_READER_GET_INTERFACE (reader);
+	g_return_if_fail (iface->remove_ui != NULL);
+
+	iface->remove_ui (reader);
+}
diff -urN a/src/modules/addressbook/e-book-shell-backend.c b/src/modules/addressbook/e-book-shell-backend.c
--- a/src/modules/addressbook/e-book-shell-backend.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/addressbook/e-book-shell-backend.c	2022-01-08 18:47:17.611545254 -0800
@@ -276,14 +276,14 @@
 	{ "contact-new",
 	  "contact-new",
 	  NC_("New", "_Contact"),
-	  "<Shift><Control>c",
+	  "<Shift><Super>c",
 	  N_("Create a new contact"),
 	  G_CALLBACK (action_contact_new_cb) },
 
 	{ "contact-new-list",
 	  "stock_contact-list",
 	  NC_("New", "Contact _List"),
-	  "<Shift><Control>l",
+	  "<Shift><Super>l",
 	  N_("Create a new contact list"),
 	  G_CALLBACK (action_contact_new_cb) }
 };
diff -urN a/src/modules/addressbook/e-book-shell-view-actions.c b/src/modules/addressbook/e-book-shell-view-actions.c
--- a/src/modules/addressbook/e-book-shell-view-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/addressbook/e-book-shell-view-actions.c	2022-01-08 18:47:17.611545254 -0800
@@ -1090,21 +1090,21 @@
 	{ "contact-copy",
 	  NULL,
 	  N_("_Copy Contact To…"),
-	  "<Control><Shift>y",
+	  "<Super><Shift>y",
 	  N_("Copy selected contacts to another address book"),
 	  G_CALLBACK (action_contact_copy_cb) },
 
 	{ "contact-delete",
 	  "edit-delete",
 	  N_("_Delete Contact"),
-	  "<Control>d",
+	  "<Super>d",
 	  N_("Delete selected contacts"),
 	  G_CALLBACK (action_contact_delete_cb) },
 
 	{ "contact-find",
 	  "edit-find",
 	  N_("_Find in Contact…"),
-	  "<Shift><Control>f",
+	  "<Shift><Super>f",
 	  N_("Search for text in the displayed contact"),
 	  G_CALLBACK (action_contact_find_cb) },
 
@@ -1118,7 +1118,7 @@
 	{ "contact-move",
 	  NULL,
 	  N_("_Move Contact To…"),
-	  "<Control><Shift>v",
+	  "<Super><Shift>v",
 	  N_("Move selected contacts to another address book"),
 	  G_CALLBACK (action_contact_move_cb) },
 
@@ -1139,7 +1139,7 @@
 	{ "contact-open",
 	  NULL,
 	  N_("_Open Contact"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("View the current contact"),
 	  G_CALLBACK (action_contact_open_cb) },
 
@@ -1223,7 +1223,7 @@
 	{ "contact-preview",
 	  NULL,
 	  N_("Contact _Preview"),
-	  "<Control>m",
+	  "<Super>m",
 	  N_("Show contact preview window"),
 	  G_CALLBACK (action_contact_preview_cb),
 	  TRUE },
@@ -1317,7 +1317,7 @@
 	{ "address-book-print",
 	  "document-print",
 	  N_("_Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  N_("Print all shown contacts"),
 	  G_CALLBACK (action_address_book_print_cb) },
 
diff -urN a/src/modules/calendar/e-cal-shell-backend.c b/src/modules/calendar/e-cal-shell-backend.c
--- a/src/modules/calendar/e-cal-shell-backend.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-cal-shell-backend.c	2022-01-08 18:47:17.611545254 -0800
@@ -116,7 +116,7 @@
 	{ "event-new",
 	  "appointment-new",
 	  NC_("New", "_Appointment"),
-	  "<Shift><Control>a",
+	  "<Shift><Super>a",
 	  N_("Create a new appointment"),
 	  G_CALLBACK (action_event_new_cb) },
 
@@ -130,7 +130,7 @@
 	{ "event-meeting-new",
 	  "stock_people",
 	  NC_("New", "M_eeting"),
-	  "<Shift><Control>e",
+	  "<Shift><Super>e",
 	  N_("Create a new meeting request"),
 	  G_CALLBACK (action_event_new_cb) }
 };
diff -urN a/src/modules/calendar/e-cal-shell-view-actions.c b/src/modules/calendar/e-cal-shell-view-actions.c
--- a/src/modules/calendar/e-cal-shell-view-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-cal-shell-view-actions.c	2022-01-08 18:47:17.614878237 -0800
@@ -1297,7 +1297,7 @@
 	{ "calendar-copy",
 	  "edit-copy",
 	  N_("_Copy…"),
-	  "<Control>c",
+	  "<Super>c",
 	  NULL,  /* XXX Add a tooltip! */
 	  G_CALLBACK (action_calendar_copy_cb) },
 
@@ -1325,14 +1325,14 @@
 	{ "calendar-go-today",
 	  "go-today",
 	  N_("Select _Today"),
-	  "<Control>t",
+	  "<Super>t",
 	  N_("Select today"),
 	  G_CALLBACK (action_calendar_go_today_cb) },
 
 	{ "calendar-jump-to",
 	  "go-jump",
 	  N_("Select _Date"),
-	  "<Control>g",
+	  "<Super>g",
 	  N_("Select a specific date"),
 	  G_CALLBACK (action_calendar_jump_to_cb) },
 
@@ -1360,7 +1360,7 @@
 	{ "calendar-purge",
 	  NULL,
 	  N_("Purg_e"),
-	  "<Control>e",
+	  "<Super>e",
 	  N_("Purge old appointments and meetings"),
 	  G_CALLBACK (action_calendar_purge_cb) },
 
@@ -1388,14 +1388,14 @@
 	{ "calendar-search-next",
 	  "go-next",
 	  N_("Find _Next"),
-	  "<Control><Shift>n",
+	  "<Super><Shift>n",
 	  N_("Find next occurrence of the current search string"),
 	  G_CALLBACK (action_calendar_search_next_cb) },
 
 	{ "calendar-search-prev",
 	  "go-previous",
 	  N_("Find _Previous"),
-	  "<Control><Shift>p",
+	  "<Super><Shift>p",
 	  N_("Find previous occurrence of the current search string"),
 	  G_CALLBACK (action_calendar_search_prev_cb) },
 
@@ -1437,7 +1437,7 @@
 	{ "event-delete",
 	  "edit-delete",
 	  N_("_Delete Appointment"),
-	  "<Control>d",
+	  "<Super>d",
 	  N_("Delete selected appointments"),
 	  G_CALLBACK (action_event_delete_cb) },
 
@@ -1563,7 +1563,7 @@
 	{ "event-open",
 	  "document-open",
 	  N_("_Open Appointment"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("View the current appointment"),
 	  G_CALLBACK (action_event_open_cb) },
 
@@ -1598,7 +1598,7 @@
 	{ "quit-calendar",
 	  "window-close",
 	  N_("Quit"),
-	  "<Control>w",
+	  "<Super>w",
 	  NULL,  /* XXX Add a tooltip! */
 	  G_CALLBACK (quit_calendar_cb) },
 
@@ -1749,35 +1749,35 @@
 	{ "calendar-view-day",
 	  "view-calendar-day",
 	  N_("Day"),
-	  "<Control>y",
+	  "<Super>y",
 	  N_("Show one day"),
 	  E_CAL_VIEW_KIND_DAY },
 
 	{ "calendar-view-list",
 	  "view-calendar-list",
 	  N_("List"),
-	  "<Control>l",
+	  "<Super>l",
 	  N_("Show as list"),
 	  E_CAL_VIEW_KIND_LIST },
 
 	{ "calendar-view-month",
 	  "view-calendar-month",
 	  N_("Month"),
-	  "<Control>m",
+	  "<Super>m",
 	  N_("Show one month"),
 	  E_CAL_VIEW_KIND_MONTH },
 
 	{ "calendar-view-week",
 	  "view-calendar-week",
 	  N_("Week"),
-	  "<Control>k",
+	  "<Super>k",
 	  N_("Show one week"),
 	  E_CAL_VIEW_KIND_WEEK },
 
 	{ "calendar-view-workweek",
 	  "view-calendar-workweek",
 	  N_("Work Week"),
-	  "<Control>j",
+	  "<Super>j",
 	  N_("Show one work week"),
 	  E_CAL_VIEW_KIND_WORKWEEK }
 };
@@ -1856,7 +1856,7 @@
 	{ "calendar-print",
 	  "document-print",
 	  N_("Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  N_("Print this calendar"),
 	  G_CALLBACK (action_calendar_print_cb) },
 
diff -urN a/src/modules/calendar/e-cal-shell-view-actions.c.orig b/src/modules/calendar/e-cal-shell-view-actions.c.orig
--- a/src/modules/calendar/e-cal-shell-view-actions.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/modules/calendar/e-cal-shell-view-actions.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,2094 @@
+/*
+ * e-cal-shell-view-actions.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ */
+
+#include "evolution-config.h"
+
+#include "calendar/gui/e-cal-dialogs.h"
+#include "calendar/gui/e-cal-ops.h"
+#include "calendar/gui/e-comp-editor.h"
+#include "calendar/gui/itip-utils.h"
+#include "calendar/gui/print.h"
+
+#include "e-cal-base-shell-view.h"
+#include "e-cal-shell-view-private.h"
+#include "e-cal-shell-view.h"
+
+/* This is for radio action groups whose value is persistent.  We
+ * initialize it to a bogus value to ensure a "changed" signal is
+ * emitted when a valid value is restored. */
+#define BOGUS_INITIAL_VALUE G_MININT
+
+static void
+action_calendar_copy_cb (GtkAction *action,
+			 EShellView *shell_view)
+{
+	e_cal_base_shell_view_copy_calendar (shell_view);
+}
+
+static void
+action_calendar_delete_cb (GtkAction *action,
+                           ECalShellView *cal_shell_view)
+{
+	ECalBaseShellSidebar *cal_shell_sidebar;
+	EShellWindow *shell_window;
+	EShellView *shell_view;
+	ESource *source;
+	ESourceSelector *selector;
+	gint response;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	cal_shell_sidebar = cal_shell_view->priv->cal_shell_sidebar;
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_sidebar);
+
+	source = e_source_selector_ref_primary_selection (selector);
+	g_return_if_fail (source != NULL);
+
+	if (e_source_get_remote_deletable (source)) {
+		response = e_alert_run_dialog_for_args (
+			GTK_WINDOW (shell_window),
+			"calendar:prompt-delete-remote-calendar",
+			e_source_get_display_name (source), NULL);
+
+		if (response == GTK_RESPONSE_YES)
+			e_shell_view_remote_delete_source (shell_view, source);
+
+	} else {
+		response = e_alert_run_dialog_for_args (
+			GTK_WINDOW (shell_window),
+			"calendar:prompt-delete-calendar",
+			e_source_get_display_name (source), NULL);
+
+		if (response == GTK_RESPONSE_YES)
+			e_shell_view_remove_source (shell_view, source);
+	}
+
+	g_object_unref (source);
+}
+
+static void
+action_calendar_go_back_cb (GtkAction *action,
+                            ECalShellView *cal_shell_view)
+{
+	e_cal_shell_content_move_view_range (
+		cal_shell_view->priv->cal_shell_content, E_CALENDAR_VIEW_MOVE_PREVIOUS, 0);
+}
+
+static void
+action_calendar_go_forward_cb (GtkAction *action,
+                               ECalShellView *cal_shell_view)
+{
+	e_cal_shell_content_move_view_range (
+		cal_shell_view->priv->cal_shell_content, E_CALENDAR_VIEW_MOVE_NEXT, 0);
+}
+
+static void
+action_calendar_go_today_cb (GtkAction *action,
+                             ECalShellView *cal_shell_view)
+{
+	e_cal_shell_content_move_view_range (
+		cal_shell_view->priv->cal_shell_content, E_CALENDAR_VIEW_MOVE_TO_TODAY, 0);
+}
+
+static void
+action_calendar_jump_to_cb (GtkAction *action,
+                            ECalShellView *cal_shell_view)
+{
+	ECalDataModel *data_model;
+	ECalShellContent *cal_shell_content;
+	EShellWindow *shell_window;
+	EShellView *shell_view;
+	GDate range_start, range_end;
+	ECalendarViewMoveType move_type;
+	time_t exact_date = time (NULL);
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	e_cal_shell_content_get_current_range_dates (cal_shell_content, &range_start, &range_end);
+	data_model = e_cal_base_shell_content_get_data_model (E_CAL_BASE_SHELL_CONTENT (cal_shell_content));
+
+	if (e_cal_dialogs_goto_run (GTK_WINDOW (shell_window), data_model, &range_start, &move_type, &exact_date))
+		e_cal_shell_content_move_view_range (cal_shell_content, move_type, exact_date);
+}
+
+static void
+action_calendar_manage_groups_cb (GtkAction *action,
+				  ECalShellView *cal_shell_view)
+{
+	EShellView *shell_view;
+	ESourceSelector *selector;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_view->priv->cal_shell_sidebar);
+
+	if (e_source_selector_manage_groups (selector) &&
+	    e_source_selector_save_groups_setup (selector, e_shell_view_get_state_key_file (shell_view)))
+		e_shell_view_set_state_dirty (shell_view);
+}
+
+static void
+action_calendar_new_cb (GtkAction *action,
+                        ECalShellView *cal_shell_view)
+{
+	EShell *shell;
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	ESourceRegistry *registry;
+	ECalClientSourceType source_type;
+	GtkWidget *config;
+	GtkWidget *dialog;
+	const gchar *icon_name;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	shell = e_shell_window_get_shell (shell_window);
+
+	registry = e_shell_get_registry (shell);
+	source_type = E_CAL_CLIENT_SOURCE_TYPE_EVENTS;
+	config = e_cal_source_config_new (registry, NULL, source_type);
+
+	e_cal_base_shell_view_preselect_source_config (shell_view, config);
+
+	dialog = e_source_config_dialog_new (E_SOURCE_CONFIG (config));
+
+	gtk_window_set_transient_for (
+		GTK_WINDOW (dialog), GTK_WINDOW (shell_window));
+
+	icon_name = gtk_action_get_icon_name (action);
+	gtk_window_set_icon_name (GTK_WINDOW (dialog), icon_name);
+
+	gtk_window_set_title (GTK_WINDOW (dialog), _("New Calendar"));
+
+	gtk_widget_show (dialog);
+}
+
+static void
+cal_shell_view_actions_print_or_preview (ECalShellView *cal_shell_view,
+					 GtkPrintOperationAction print_action)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *cal_view;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	cal_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	if (E_IS_CAL_LIST_VIEW (cal_view)) {
+		ETable *table;
+
+		table = e_cal_list_view_get_table (E_CAL_LIST_VIEW (cal_view));
+		print_table (table, _("Print"), _("Calendar"), print_action);
+	} else {
+		EPrintView print_view_type;
+		ETable *tasks_table;
+		time_t start = 0, end = 0;
+
+		switch (e_cal_shell_content_get_current_view_id (cal_shell_content)) {
+			case E_CAL_VIEW_KIND_DAY:
+				print_view_type = E_PRINT_VIEW_DAY;
+				break;
+			case E_CAL_VIEW_KIND_WORKWEEK:
+				print_view_type = E_PRINT_VIEW_WORKWEEK;
+				break;
+			case E_CAL_VIEW_KIND_WEEK:
+				print_view_type = E_PRINT_VIEW_WEEK;
+				break;
+			case E_CAL_VIEW_KIND_MONTH:
+				print_view_type = E_PRINT_VIEW_MONTH;
+				break;
+			case E_CAL_VIEW_KIND_LIST:
+				print_view_type = E_PRINT_VIEW_LIST;
+				break;
+			default:
+				g_warn_if_reached ();
+				return;
+		}
+
+		tasks_table = E_TABLE (e_cal_shell_content_get_task_table (cal_shell_content));
+
+		g_warn_if_fail (e_calendar_view_get_selected_time_range (cal_view, &start, &end));
+
+		print_calendar (cal_view, tasks_table, print_view_type, print_action, start);
+	}
+}
+
+static void
+action_calendar_print_cb (GtkAction *action,
+                          ECalShellView *cal_shell_view)
+{
+	cal_shell_view_actions_print_or_preview (cal_shell_view, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG);
+}
+
+static void
+action_calendar_print_preview_cb (GtkAction *action,
+                                  ECalShellView *cal_shell_view)
+{
+	cal_shell_view_actions_print_or_preview (cal_shell_view, GTK_PRINT_OPERATION_ACTION_PREVIEW);
+}
+
+static void
+action_calendar_properties_cb (GtkAction *action,
+                               ECalShellView *cal_shell_view)
+{
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	ECalBaseShellSidebar *cal_shell_sidebar;
+	ECalClientSourceType source_type;
+	ESource *source;
+	ESourceSelector *selector;
+	ESourceRegistry *registry;
+	GtkWidget *config;
+	GtkWidget *dialog;
+	const gchar *icon_name;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	cal_shell_sidebar = cal_shell_view->priv->cal_shell_sidebar;
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_sidebar);
+	source = e_source_selector_ref_primary_selection (selector);
+	g_return_if_fail (source != NULL);
+
+	source_type = E_CAL_CLIENT_SOURCE_TYPE_EVENTS;
+	registry = e_source_selector_get_registry (selector);
+	config = e_cal_source_config_new (registry, source, source_type);
+
+	g_object_unref (source);
+
+	dialog = e_source_config_dialog_new (E_SOURCE_CONFIG (config));
+
+	gtk_window_set_transient_for (
+		GTK_WINDOW (dialog), GTK_WINDOW (shell_window));
+
+	icon_name = gtk_action_get_icon_name (action);
+	gtk_window_set_icon_name (GTK_WINDOW (dialog), icon_name);
+
+	gtk_window_set_title (GTK_WINDOW (dialog), _("Calendar Properties"));
+
+	gtk_widget_show (dialog);
+}
+
+static void
+action_calendar_purge_cb (GtkAction *action,
+                          ECalShellView *cal_shell_view)
+{
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	ECalShellContent *cal_shell_content;
+	GtkSpinButton *spin_button;
+	GtkWidget *container;
+	GtkWidget *dialog;
+	GtkWidget *widget;
+	gint days;
+	time_t tt;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+
+	dialog = gtk_message_dialog_new (
+		GTK_WINDOW (shell_window),
+		GTK_DIALOG_DESTROY_WITH_PARENT,
+		GTK_MESSAGE_WARNING,
+		GTK_BUTTONS_OK_CANCEL,
+		_("This operation will permanently erase all events older "
+		"than the selected amount of time. If you continue, you "
+		"will not be able to recover these events."));
+
+	gtk_dialog_set_default_response (
+		GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);
+
+	container = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+
+	widget = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
+	gtk_box_pack_start (GTK_BOX (container), widget, TRUE, FALSE, 6);
+	gtk_widget_show (widget);
+
+	container = widget;
+
+	/* Translators: This is the first part of the sentence:
+	 * "Purge events older than <<spin-button>> days" */
+	widget = gtk_label_new (_("Purge events older than"));
+	gtk_box_pack_start (GTK_BOX (container), widget, TRUE, FALSE, 6);
+	gtk_widget_show (widget);
+
+	widget = gtk_spin_button_new_with_range (0.0, 1000.0, 1.0);
+	gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), 60.0);
+	gtk_box_pack_start (GTK_BOX (container), widget, FALSE, FALSE, 6);
+	gtk_widget_show (widget);
+
+	spin_button = GTK_SPIN_BUTTON (widget);
+
+	/* Translators: This is the last part of the sentence:
+	 * "Purge events older than <<spin-button>> days" */
+	widget = gtk_label_new (_("days"));
+	gtk_box_pack_start (GTK_BOX (container), widget, TRUE, FALSE, 6);
+	gtk_widget_show (widget);
+
+	if (gtk_dialog_run (GTK_DIALOG (dialog)) != GTK_RESPONSE_OK)
+		goto exit;
+
+	days = gtk_spin_button_get_value_as_int (spin_button);
+
+	tt = time (NULL);
+	tt -= (days * (24 * 3600));
+
+	e_cal_ops_purge_components (e_cal_base_shell_content_get_model (E_CAL_BASE_SHELL_CONTENT (cal_shell_content)), tt);
+
+ exit:
+	gtk_widget_destroy (dialog);
+}
+
+static void
+action_calendar_refresh_cb (GtkAction *action,
+                           ECalShellView *cal_shell_view)
+{
+	ECalBaseShellSidebar *cal_shell_sidebar;
+	ESourceSelector *selector;
+	EClient *client = NULL;
+	ESource *source;
+
+	cal_shell_sidebar = cal_shell_view->priv->cal_shell_sidebar;
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_sidebar);
+
+	source = e_source_selector_ref_primary_selection (selector);
+
+	if (source != NULL) {
+		client = e_client_selector_ref_cached_client (
+			E_CLIENT_SELECTOR (selector), source);
+		g_object_unref (source);
+	}
+
+	if (client == NULL)
+		return;
+
+	g_return_if_fail (e_client_check_refresh_supported (client));
+
+	e_cal_base_shell_view_allow_auth_prompt_and_refresh (E_SHELL_VIEW (cal_shell_view), client);
+
+	g_object_unref (client);
+}
+
+static void
+action_calendar_refresh_backend_cb (GtkAction *action,
+				    EShellView *shell_view)
+{
+	ESource *source;
+
+	g_return_if_fail (E_IS_CAL_SHELL_VIEW (shell_view));
+
+	source = e_cal_base_shell_view_get_clicked_source (shell_view);
+
+	if (source && e_source_has_extension (source, E_SOURCE_EXTENSION_COLLECTION))
+		e_cal_base_shell_view_refresh_backend (shell_view, source);
+}
+
+static void
+action_calendar_rename_cb (GtkAction *action,
+                           ECalShellView *cal_shell_view)
+{
+	ECalBaseShellSidebar *cal_shell_sidebar;
+	ESourceSelector *selector;
+
+	cal_shell_sidebar = cal_shell_view->priv->cal_shell_sidebar;
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_sidebar);
+
+	e_source_selector_edit_primary_selection (selector);
+}
+
+static void
+action_calendar_search_next_cb (GtkAction *action,
+                                ECalShellView *cal_shell_view)
+{
+	e_cal_shell_view_search_events (cal_shell_view, TRUE);
+}
+
+static void
+action_calendar_search_prev_cb (GtkAction *action,
+                                ECalShellView *cal_shell_view)
+{
+	e_cal_shell_view_search_events (cal_shell_view, FALSE);
+}
+
+static void
+action_calendar_search_stop_cb (GtkAction *action,
+                                ECalShellView *cal_shell_view)
+{
+	e_cal_shell_view_search_stop (cal_shell_view);
+}
+
+static void
+action_calendar_select_all_cb (GtkAction *action,
+			       ECalShellView *cal_shell_view)
+{
+	ECalBaseShellSidebar *cal_shell_sidebar;
+	ESourceSelector *selector;
+
+	cal_shell_sidebar = cal_shell_view->priv->cal_shell_sidebar;
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_sidebar);
+
+	e_source_selector_select_all (selector);
+}
+
+static void
+action_calendar_select_one_cb (GtkAction *action,
+                               ECalShellView *cal_shell_view)
+{
+	ECalBaseShellSidebar *cal_shell_sidebar;
+	ESourceSelector *selector;
+	ESource *primary;
+
+	cal_shell_sidebar = cal_shell_view->priv->cal_shell_sidebar;
+	selector = e_cal_base_shell_sidebar_get_selector (cal_shell_sidebar);
+
+	primary = e_source_selector_ref_primary_selection (selector);
+	g_return_if_fail (primary != NULL);
+
+	e_source_selector_select_exclusive (selector, primary);
+
+	g_object_unref (primary);
+}
+
+static void
+action_calendar_view_cb (GtkRadioAction *action,
+                         GtkRadioAction *current,
+                         ECalShellView *cal_shell_view)
+{
+	EShellView *shell_view;
+	ECalViewKind view_kind;
+	const gchar *view_id;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	view_kind = gtk_radio_action_get_current_value (action);
+
+	switch (view_kind) {
+		case E_CAL_VIEW_KIND_DAY:
+			view_id = "Day_View";
+			break;
+
+		case E_CAL_VIEW_KIND_WORKWEEK:
+			view_id = "Work_Week_View";
+			break;
+
+		case E_CAL_VIEW_KIND_WEEK:
+			view_id = "Week_View";
+			break;
+
+		case E_CAL_VIEW_KIND_MONTH:
+			view_id = "Month_View";
+			break;
+
+		case E_CAL_VIEW_KIND_LIST:
+			view_id = "List_View";
+			break;
+
+		default:
+			g_return_if_reached ();
+	}
+
+	e_shell_view_set_view_id (shell_view, view_id);
+}
+
+static void
+cal_shell_view_transfer_selected (ECalShellView *cal_shell_view,
+				  gboolean is_move)
+{
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ESource *source_source = NULL;
+	ESource *destination_source = NULL;
+	ESourceRegistry *registry;
+	GList *selected, *link;
+	GHashTable *by_source; /* ESource ~> GSList{ICalComponent} */
+	GHashTableIter iter;
+	gpointer key, value;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	registry = e_shell_get_registry (e_shell_window_get_shell (shell_window));
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (selected != NULL);
+
+	if (selected->data && is_move) {
+		ECalendarViewEvent *event = selected->data;
+
+		if (is_comp_data_valid (event) && event->comp_data->client)
+			source_source = e_client_get_source (
+				E_CLIENT (event->comp_data->client));
+	}
+
+	/* Get a destination source from the user. */
+	destination_source = e_cal_dialogs_select_source (
+		GTK_WINDOW (shell_window), registry,
+		E_CAL_CLIENT_SOURCE_TYPE_EVENTS, source_source);
+	if (destination_source == NULL) {
+		g_list_free (selected);
+		return;
+	}
+
+	by_source = g_hash_table_new ((GHashFunc) e_source_hash, (GEqualFunc) e_source_equal);
+
+	for (link = selected; link != NULL; link = g_list_next (link)) {
+		ECalendarViewEvent *event = link->data;
+		ESource *source;
+		GSList *icomps;
+
+		if (!event || !event->comp_data)
+			continue;
+
+		source = e_client_get_source (E_CLIENT (event->comp_data->client));
+		if (!source)
+			continue;
+
+		icomps = g_hash_table_lookup (by_source, source);
+		icomps = g_slist_prepend (icomps, event->comp_data->icalcomp);
+		g_hash_table_insert (by_source, source, icomps);
+	}
+
+	e_cal_ops_transfer_components (shell_view, e_calendar_view_get_model (calendar_view),
+		E_CAL_CLIENT_SOURCE_TYPE_EVENTS, by_source, destination_source, is_move);
+
+	g_hash_table_iter_init (&iter, by_source);
+	while (g_hash_table_iter_next (&iter, &key, &value)) {
+		GSList *icomps = value;
+
+		g_slist_free (icomps);
+	}
+
+	g_hash_table_destroy (by_source);
+	g_clear_object (&destination_source);
+	g_list_free (selected);
+}
+
+static void
+action_event_copy_cb (GtkAction *action,
+                      ECalShellView *cal_shell_view)
+{
+	cal_shell_view_transfer_selected (cal_shell_view, FALSE);
+}
+
+static void
+action_event_move_cb (GtkAction *action,
+                      ECalShellView *cal_shell_view)
+{
+	cal_shell_view_transfer_selected (cal_shell_view, TRUE);
+}
+
+static void
+action_event_delegate_cb (GtkAction *action,
+                          ECalShellView *cal_shell_view)
+{
+	ESourceRegistry *registry;
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalComponent *component;
+	ECalClient *client;
+	ECalModel *model;
+	GList *selected;
+	ICalComponent *clone;
+	ICalProperty *prop;
+	gboolean found = FALSE;
+	gchar *attendee;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	model = e_calendar_view_get_model (calendar_view);
+	registry = e_cal_model_get_registry (model);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	clone = i_cal_component_clone (event->comp_data->icalcomp);
+
+	/* Set the attendee status for the delegate. */
+
+	component = e_cal_component_new_from_icalcomponent (i_cal_component_clone (clone));
+
+	attendee = itip_get_comp_attendee (registry, component, client);
+
+	for (prop = i_cal_component_get_first_property (clone, I_CAL_ATTENDEE_PROPERTY);
+	     prop;
+	     g_object_unref (prop), prop = i_cal_component_get_next_property (clone, I_CAL_ATTENDEE_PROPERTY)) {
+		const gchar *candidate;
+
+		candidate = i_cal_property_get_attendee (prop);
+		candidate = itip_strip_mailto (candidate);
+
+		if (candidate && g_ascii_strcasecmp (candidate, attendee) == 0) {
+			ICalParameter *param;
+
+			param = i_cal_parameter_new_role (I_CAL_ROLE_NONPARTICIPANT);
+			i_cal_property_set_parameter (prop, param);
+			g_clear_object (&param);
+
+			param = i_cal_parameter_new_partstat (I_CAL_PARTSTAT_DELEGATED);
+			i_cal_property_set_parameter (prop, param);
+			g_clear_object (&param);
+
+			found = TRUE;
+			break;
+		}
+	}
+
+	g_clear_object (&prop);
+
+	/* If the attendee is not already in the component, add it. */
+	if (!found) {
+		ICalParameter *param;
+		gchar *address;
+
+		address = g_strdup_printf ("mailto:%s", attendee);
+
+		prop = i_cal_property_new_attendee (address);
+
+		param = i_cal_parameter_new_role (I_CAL_ROLE_NONPARTICIPANT);
+		i_cal_property_take_parameter (prop, param);
+
+		param = i_cal_parameter_new_cutype (I_CAL_CUTYPE_INDIVIDUAL);
+		i_cal_property_take_parameter (prop, param);
+
+		param = i_cal_parameter_new_rsvp (I_CAL_RSVP_TRUE);
+		i_cal_property_take_parameter (prop, param);
+
+		i_cal_component_take_property (clone, prop);
+		g_free (address);
+	}
+
+	g_free (attendee);
+	g_object_unref (component);
+
+	e_calendar_view_open_event_with_flags (
+		calendar_view, event->comp_data->client, clone,
+		E_COMP_EDITOR_FLAG_WITH_ATTENDEES | E_COMP_EDITOR_FLAG_DELEGATE);
+
+	g_object_unref (clone);
+	g_list_free (selected);
+}
+
+static void
+action_event_delete_cb (GtkAction *action,
+                        ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	e_selectable_delete_selection (E_SELECTABLE (calendar_view));
+}
+
+static void
+action_event_delete_occurrence_cb (GtkAction *action,
+                                   ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	e_calendar_view_delete_selected_occurrence (calendar_view, E_CAL_OBJ_MOD_THIS);
+}
+
+static void
+action_event_delete_occurrence_this_and_future_cb (GtkAction *action,
+						   ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	e_calendar_view_delete_selected_occurrence (calendar_view, E_CAL_OBJ_MOD_THIS_AND_FUTURE);
+}
+
+static void
+action_event_forward_cb (GtkAction *action,
+                         ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalComponent *component;
+	ECalClient *client;
+	ICalComponent *icomp;
+	GList *selected;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	icomp = event->comp_data->icalcomp;
+
+	component = e_cal_component_new_from_icalcomponent (i_cal_component_clone (icomp));
+	g_return_if_fail (component != NULL);
+
+	itip_send_component_with_model (e_calendar_view_get_model (calendar_view),
+		I_CAL_METHOD_PUBLISH, component, client,
+		NULL, NULL, NULL, E_ITIP_SEND_COMPONENT_FLAG_STRIP_ALARMS | E_ITIP_SEND_COMPONENT_FLAG_ENSURE_MASTER_OBJECT);
+
+	g_object_unref (component);
+	g_list_free (selected);
+}
+
+static void
+action_event_popup_new_cb (GtkAction *action,
+			   ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	const gchar *action_name;
+	gboolean is_all_day, is_meeting;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	action_name = gtk_action_get_name (action);
+	is_all_day = g_strcmp0 (action_name, "event-popup-all-day-new") == 0;
+	is_meeting = g_strcmp0 (action_name, "event-popup-meeting-new") == 0;
+
+	e_calendar_view_new_appointment (calendar_view,
+		(is_all_day ? E_NEW_APPOINTMENT_FLAG_ALL_DAY : 0) |
+		(is_meeting ? E_NEW_APPOINTMENT_FLAG_MEETING : 0) |
+		(e_shell_view_is_active (E_SHELL_VIEW (cal_shell_view)) ? 0 : E_NEW_APPOINTMENT_FLAG_FORCE_CURRENT_TIME));
+}
+
+static void
+action_event_popup_rsvp_response_cb (GtkAction *action,
+				     ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalClient *client;
+	ECalComponent *comp;
+	ECalModel *model;
+	ICalParameterPartstat partstat = I_CAL_PARTSTAT_NONE;
+	ICalComponent *clone;
+	GList *selected;
+	const gchar *action_name;
+	gboolean ensure_master_object;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+	action_name = gtk_action_get_name (action);
+
+	if (g_strcmp0 (action_name, "event-popup-rsvp-accept") == 0 ||
+	    g_strcmp0 (action_name, "event-popup-rsvp-accept-1") == 0)
+		partstat = I_CAL_PARTSTAT_ACCEPTED;
+	else if (g_strcmp0 (action_name, "event-popup-rsvp-decline") == 0 ||
+		 g_strcmp0 (action_name, "event-popup-rsvp-decline-1") == 0)
+		partstat = I_CAL_PARTSTAT_DECLINED;
+	else if (g_strcmp0 (action_name, "event-popup-rsvp-tentative") == 0 ||
+		 g_strcmp0 (action_name, "event-popup-rsvp-tentative-1") == 0)
+		partstat = I_CAL_PARTSTAT_TENTATIVE;
+	else {
+		g_warning ("%s: Do not know what to do with '%s'", G_STRFUNC, action_name);
+	}
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	g_list_free (selected);
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	model = e_calendar_view_get_model (calendar_view);
+
+	clone = i_cal_component_clone (event->comp_data->icalcomp);
+	comp = e_cal_component_new_from_icalcomponent (clone);
+
+	if (!comp) {
+		g_warn_if_reached ();
+		return;
+	}
+
+	ensure_master_object = (e_cal_util_component_is_instance (clone) ||
+				e_cal_util_component_has_recurrences (clone)) &&
+				!g_str_has_suffix (action_name, "-1");
+
+	itip_send_component_with_model (model, I_CAL_METHOD_REPLY,
+		comp, client, NULL, NULL, NULL,
+		E_ITIP_SEND_COMPONENT_FLAG_STRIP_ALARMS |
+		(ensure_master_object ? E_ITIP_SEND_COMPONENT_FLAG_ENSURE_MASTER_OBJECT : 0) |
+		(partstat == I_CAL_PARTSTAT_ACCEPTED ? E_ITIP_SEND_COMPONENT_FLAG_SAVE_RESPONSE_ACCEPTED : 0) |
+		(partstat == I_CAL_PARTSTAT_DECLINED ? E_ITIP_SEND_COMPONENT_FLAG_SAVE_RESPONSE_DECLINED : 0) |
+		(partstat == I_CAL_PARTSTAT_TENTATIVE ? E_ITIP_SEND_COMPONENT_FLAG_SAVE_RESPONSE_TENTATIVE : 0));
+
+	g_clear_object (&comp);
+}
+
+typedef struct {
+	ECalClient *client;
+	gchar *remove_uid;
+	gchar *remove_rid;
+	ICalComponent *create_icomp;
+} MakeMovableData;
+
+static void
+make_movable_data_free (gpointer ptr)
+{
+	MakeMovableData *mmd = ptr;
+
+	if (mmd) {
+		g_clear_object (&mmd->client);
+		g_free (mmd->remove_uid);
+		g_free (mmd->remove_rid);
+		g_clear_object (&mmd->create_icomp);
+		g_slice_free (MakeMovableData, mmd);
+	}
+}
+
+static void
+make_movable_thread (EAlertSinkThreadJobData *job_data,
+		     gpointer user_data,
+		     GCancellable *cancellable,
+		     GError **error)
+{
+	MakeMovableData *mmd = user_data;
+
+	g_return_if_fail (mmd != NULL);
+
+	if (!e_cal_client_remove_object_sync (mmd->client, mmd->remove_uid, mmd->remove_rid, E_CAL_OBJ_MOD_THIS, E_CAL_OPERATION_FLAG_NONE, cancellable, error))
+		return;
+
+	e_cal_client_create_object_sync (mmd->client, mmd->create_icomp, E_CAL_OPERATION_FLAG_NONE, NULL, cancellable, error);
+}
+
+static void
+action_event_occurrence_movable_cb (GtkAction *action,
+                                    ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalModel *model;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalComponent *exception_component;
+	ECalComponent *recurring_component;
+	ECalComponentDateTime *date;
+	ECalComponentId *id;
+	ECalClient *client;
+	ICalComponent *icomp;
+	ICalTimezone *timezone;
+	GList *selected;
+	gchar *uid;
+	EActivity *activity;
+	MakeMovableData *mmd;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	model = e_calendar_view_get_model (calendar_view);
+	timezone = e_cal_model_get_timezone (model);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	icomp = event->comp_data->icalcomp;
+
+	/* For the recurring object, we add an exception
+	 * to get rid of the instance. */
+
+	recurring_component = e_cal_component_new_from_icalcomponent (i_cal_component_clone (icomp));
+	id = e_cal_component_get_id (recurring_component);
+
+	/* For the unrecurred instance, we duplicate the original object,
+	 * create a new UID for it, get rid of the recurrence rules, and
+	 * set the start and end times to the instance times. */
+
+	exception_component = e_cal_component_new_from_icalcomponent (i_cal_component_clone (icomp));
+
+	uid = e_util_generate_uid ();
+	e_cal_component_set_uid (exception_component, uid);
+	g_free (uid);
+
+	e_cal_component_set_recurid (exception_component, NULL);
+	e_cal_component_set_rdates (exception_component, NULL);
+	e_cal_component_set_rrules (exception_component, NULL);
+	e_cal_component_set_exdates (exception_component, NULL);
+	e_cal_component_set_exrules (exception_component, NULL);
+
+	date = e_cal_component_datetime_new_take (i_cal_time_new_from_timet_with_zone (event->comp_data->instance_start, FALSE, timezone),
+		timezone ? g_strdup (i_cal_timezone_get_tzid (timezone)) : NULL);
+	cal_comp_set_dtstart_with_oldzone (client, exception_component, date);
+	e_cal_component_datetime_take_value (date, i_cal_time_new_from_timet_with_zone (event->comp_data->instance_end, FALSE, timezone));
+	cal_comp_set_dtend_with_oldzone (client, exception_component, date);
+	e_cal_component_datetime_free (date);
+
+	e_cal_component_commit_sequence (exception_component);
+
+	mmd = g_slice_new0 (MakeMovableData);
+	mmd->client = g_object_ref (client);
+	mmd->remove_uid = g_strdup (e_cal_component_id_get_uid (id));
+	mmd->remove_rid = g_strdup (e_cal_component_id_get_rid (id));
+	mmd->create_icomp = i_cal_component_clone (e_cal_component_get_icalcomponent (exception_component));
+
+	activity = e_shell_view_submit_thread_job (E_SHELL_VIEW (cal_shell_view),
+		_("Making an occurrence movable"), "calendar:failed-make-movable",
+		NULL, make_movable_thread, mmd, make_movable_data_free);
+
+	g_clear_object (&activity);
+	e_cal_component_id_free (id);
+	g_object_unref (recurring_component);
+	g_object_unref (exception_component);
+	g_list_free (selected);
+}
+
+static void
+action_event_open_cb (GtkAction *action,
+                      ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *view;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	e_calendar_view_open_event (view);
+}
+
+static void
+action_event_edit_as_new_cb (GtkAction *action,
+			     ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	GList *selected;
+	ICalComponent *clone;
+	gchar *uid;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event) ||
+	    e_cal_util_component_is_instance (event->comp_data->icalcomp)) {
+		g_list_free (selected);
+		return;
+	}
+
+	clone = i_cal_component_clone (event->comp_data->icalcomp);
+
+	uid = e_util_generate_uid ();
+	i_cal_component_set_uid (clone, uid);
+	g_free (uid);
+
+	e_calendar_view_open_event_with_flags (
+		calendar_view, event->comp_data->client, clone,
+		E_COMP_EDITOR_FLAG_IS_NEW);
+
+	g_clear_object (&clone);
+	g_list_free (selected);
+}
+
+static void
+action_event_print_cb (GtkAction *action,
+                       ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalComponent *component;
+	ECalModel *model;
+	ECalClient *client;
+	ICalComponent *icomp;
+	GList *selected;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+	model = e_calendar_view_get_model (calendar_view);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	icomp = event->comp_data->icalcomp;
+
+	component = e_cal_component_new_from_icalcomponent (i_cal_component_clone (icomp));
+
+	print_comp (
+		component, client,
+		e_cal_model_get_timezone (model),
+		e_cal_model_get_use_24_hour_format (model),
+		GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG);
+
+	g_object_unref (component);
+	g_list_free (selected);
+}
+
+static void
+cal_shell_view_actions_reply (ECalShellView *cal_shell_view,
+			      gboolean reply_all)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalComponent *component;
+	ECalClient *client;
+	ESourceRegistry *registry;
+	ICalComponent *icomp;
+	GList *selected;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	registry = e_shell_get_registry (e_shell_window_get_shell (e_shell_view_get_shell_window (E_SHELL_VIEW (cal_shell_view))));
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	icomp = event->comp_data->icalcomp;
+
+	component = e_cal_component_new_from_icalcomponent (i_cal_component_clone (icomp));
+
+	reply_to_calendar_comp (
+		registry, I_CAL_METHOD_REPLY,
+		component, client, reply_all, NULL, NULL);
+
+	g_object_unref (component);
+	g_list_free (selected);
+}
+
+static void
+action_event_reply_cb (GtkAction *action,
+                       ECalShellView *cal_shell_view)
+{
+	cal_shell_view_actions_reply (cal_shell_view, FALSE);
+}
+
+static void
+action_event_reply_all_cb (GtkAction *action,
+                           ECalShellView *cal_shell_view)
+{
+	cal_shell_view_actions_reply (cal_shell_view, TRUE);
+}
+
+static void
+action_event_save_as_cb (GtkAction *action,
+                         ECalShellView *cal_shell_view)
+{
+	EShell *shell;
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	EShellBackend *shell_backend;
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalClient *client;
+	ICalComponent *icomp;
+	EActivity *activity;
+	GList *selected;
+	GFile *file;
+	gchar *string = NULL;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+	shell_backend = e_shell_view_get_shell_backend (shell_view);
+	shell = e_shell_window_get_shell (shell_window);
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	icomp = event->comp_data->icalcomp;
+
+	/* Translators: Default filename part saving an event to a file when
+	 * no summary is filed, the '.ics' extension is concatenated to it. */
+	string = comp_util_suggest_filename (icomp, _("event"));
+	file = e_shell_run_save_dialog (
+		shell, _("Save as iCalendar"), string,
+		"*.ics:text/calendar", NULL, NULL);
+	g_free (string);
+	if (file == NULL)
+		return;
+
+	string = e_cal_client_get_component_as_string (client, icomp);
+	if (string == NULL) {
+		g_warning ("Could not convert item to a string");
+		goto exit;
+	}
+
+	/* XXX No callbacks means errors are discarded. */
+	activity = e_file_replace_contents_async (
+		file, string, strlen (string), NULL, FALSE,
+		G_FILE_CREATE_NONE, (GAsyncReadyCallback) NULL, NULL);
+	e_shell_backend_add_activity (shell_backend, activity);
+
+	/* Free the string when the activity is finalized. */
+	g_object_set_data_full (
+		G_OBJECT (activity),
+		"file-content", string,
+		(GDestroyNotify) g_free);
+
+exit:
+	g_object_unref (file);
+	g_list_free (selected);
+}
+
+static void
+edit_event_as (ECalShellView *cal_shell_view,
+               gboolean as_meeting)
+{
+	ECalShellContent *cal_shell_content;
+	ECalendarView *calendar_view;
+	ECalendarViewEvent *event;
+	ECalClient *client;
+	ICalComponent *icomp;
+	GList *selected;
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	calendar_view = e_cal_shell_content_get_current_calendar_view (cal_shell_content);
+
+	selected = e_calendar_view_get_selected_events (calendar_view);
+	g_return_if_fail (g_list_length (selected) == 1);
+
+	event = selected->data;
+
+	if (!is_comp_data_valid (event))
+		return;
+
+	client = event->comp_data->client;
+	icomp = event->comp_data->icalcomp;
+
+	if (!as_meeting && icomp) {
+		/* remove organizer and all attendees */
+		/* do it on a copy, as user can cancel changes */
+		icomp = i_cal_component_clone (icomp);
+
+		e_cal_util_component_remove_property_by_kind (icomp, I_CAL_ATTENDEE_PROPERTY, TRUE);
+		e_cal_util_component_remove_property_by_kind (icomp, I_CAL_ORGANIZER_PROPERTY, TRUE);
+	}
+
+	e_calendar_view_edit_appointment (
+		calendar_view, client, icomp, as_meeting ?
+		EDIT_EVENT_FORCE_MEETING : EDIT_EVENT_FORCE_APPOINTMENT);
+
+	if (!as_meeting && icomp) {
+		g_object_unref (icomp);
+	}
+
+	g_list_free (selected);
+}
+
+static void
+action_event_schedule_cb (GtkAction *action,
+                          ECalShellView *cal_shell_view)
+{
+	edit_event_as (cal_shell_view, TRUE);
+}
+
+static void
+quit_calendar_cb (GtkAction *action,
+                  ECalShellView *cal_shell_view)
+{
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	GdkWindow *window;
+	GdkEvent *event;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	/* Synthesize a delete_event on this window. */
+	event = gdk_event_new (GDK_DELETE);
+	window = gtk_widget_get_window (GTK_WIDGET (shell_window));
+	event->any.window = g_object_ref (window);
+	event->any.send_event = TRUE;
+	gtk_main_do_event (event);
+	gdk_event_free (event);
+
+}
+
+static void
+action_event_schedule_appointment_cb (GtkAction *action,
+                                      ECalShellView *cal_shell_view)
+{
+	edit_event_as (cal_shell_view, FALSE);
+}
+
+static void
+action_calendar_show_tag_vpane_cb (GtkAction *action,
+				   ECalShellView *cal_shell_view)
+{
+	g_return_if_fail (E_IS_CAL_SHELL_VIEW (cal_shell_view));
+
+	e_cal_shell_content_set_show_tag_vpane (cal_shell_view->priv->cal_shell_content, gtk_toggle_action_get_active (GTK_TOGGLE_ACTION (action)));
+}
+
+static GtkActionEntry calendar_entries[] = {
+
+	{ "calendar-copy",
+	  "edit-copy",
+	  N_("_Copy…"),
+	  "<Control>c",
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_calendar_copy_cb) },
+
+	{ "calendar-delete",
+	  "edit-delete",
+	  N_("D_elete Calendar"),
+	  NULL,
+	  N_("Delete the selected calendar"),
+	  G_CALLBACK (action_calendar_delete_cb) },
+
+	{ "calendar-go-back",
+	  "go-previous",
+	  N_("Previous"),
+	  NULL,
+	  N_("Go Back"),
+	  G_CALLBACK (action_calendar_go_back_cb) },
+
+	{ "calendar-go-forward",
+	  "go-next",
+	  N_("Next"),
+	  NULL,
+	  N_("Go Forward"),
+	  G_CALLBACK (action_calendar_go_forward_cb) },
+
+	{ "calendar-go-today",
+	  "go-today",
+	  N_("Select _Today"),
+	  "<Control>t",
+	  N_("Select today"),
+	  G_CALLBACK (action_calendar_go_today_cb) },
+
+	{ "calendar-jump-to",
+	  "go-jump",
+	  N_("Select _Date"),
+	  "<Control>g",
+	  N_("Select a specific date"),
+	  G_CALLBACK (action_calendar_jump_to_cb) },
+
+	{ "calendar-manage-groups",
+	  NULL,
+	  N_("_Manage Calendar groups…"),
+	  NULL,
+	  N_("Manage Calendar groups order and visibility"),
+	  G_CALLBACK (action_calendar_manage_groups_cb) },
+
+	{ "calendar-new",
+	  "x-office-calendar",
+	  N_("_New Calendar"),
+	  NULL,
+	  N_("Create a new calendar"),
+	  G_CALLBACK (action_calendar_new_cb) },
+
+	{ "calendar-properties",
+	  "document-properties",
+	  N_("_Properties"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_calendar_properties_cb) },
+
+	{ "calendar-purge",
+	  NULL,
+	  N_("Purg_e"),
+	  "<Control>e",
+	  N_("Purge old appointments and meetings"),
+	  G_CALLBACK (action_calendar_purge_cb) },
+
+	{ "calendar-refresh",
+	  "view-refresh",
+	  N_("Re_fresh"),
+	  NULL,
+	  N_("Refresh the selected calendar"),
+	  G_CALLBACK (action_calendar_refresh_cb) },
+
+	{ "calendar-refresh-backend",
+	  "view-refresh",
+	  N_("Re_fresh list of account calendars"),
+	  NULL,
+	  NULL,
+	  G_CALLBACK (action_calendar_refresh_backend_cb) },
+
+	{ "calendar-rename",
+	  NULL,
+	  N_("_Rename…"),
+	  "F2",
+	  N_("Rename the selected calendar"),
+	  G_CALLBACK (action_calendar_rename_cb) },
+
+	{ "calendar-search-next",
+	  "go-next",
+	  N_("Find _Next"),
+	  "<Control><Shift>n",
+	  N_("Find next occurrence of the current search string"),
+	  G_CALLBACK (action_calendar_search_next_cb) },
+
+	{ "calendar-search-prev",
+	  "go-previous",
+	  N_("Find _Previous"),
+	  "<Control><Shift>p",
+	  N_("Find previous occurrence of the current search string"),
+	  G_CALLBACK (action_calendar_search_prev_cb) },
+
+	{ "calendar-search-stop",
+	  "process-stop",
+	  N_("Stop _Running Search"),
+	  NULL,
+	  N_("Stop currently running search"),
+	  G_CALLBACK (action_calendar_search_stop_cb) },
+
+	{ "calendar-select-all",
+	  "stock_check-filled",
+	  N_("Sho_w All Calendars"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_calendar_select_all_cb) },
+
+	{ "calendar-select-one",
+	  "stock_check-filled",
+	  N_("Show _Only This Calendar"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_calendar_select_one_cb) },
+
+	{ "event-copy",
+	  NULL,
+	  N_("Cop_y to Calendar…"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_copy_cb) },
+
+	{ "event-delegate",
+	  NULL,
+	  N_("_Delegate Meeting…"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_delegate_cb) },
+
+	{ "event-delete",
+	  "edit-delete",
+	  N_("_Delete Appointment"),
+	  "<Control>d",
+	  N_("Delete selected appointments"),
+	  G_CALLBACK (action_event_delete_cb) },
+
+	{ "event-delete-occurrence",
+	  "edit-delete",
+	  N_("Delete This _Occurrence"),
+	  NULL,
+	  N_("Delete this occurrence"),
+	  G_CALLBACK (action_event_delete_occurrence_cb) },
+
+	{ "event-delete-occurrence-this-and-future",
+	  "edit-delete",
+	  N_("Delete This and F_uture Occurrences"),
+	  NULL,
+	  N_("Delete this and any future occurrences"),
+	  G_CALLBACK (action_event_delete_occurrence_this_and_future_cb) },
+
+	{ "event-delete-occurrence-all",
+	  "edit-delete",
+	  N_("Delete All Occ_urrences"),
+	  NULL,
+	  N_("Delete all occurrences"),
+	  G_CALLBACK (action_event_delete_cb) },
+
+	{ "event-edit-as-new",
+	  NULL,
+	  N_("Edit as Ne_w…"),
+	  NULL,
+	  N_("Edit the current appointment as new"),
+	  G_CALLBACK (action_event_edit_as_new_cb) },
+
+	{ "event-popup-all-day-new",
+	  "stock_new-24h-appointment",
+	  N_("New All Day _Event…"),
+	  NULL,
+	  N_("Create a new all day event"),
+	  G_CALLBACK (action_event_popup_new_cb) },
+
+	{ "event-forward",
+	  "mail-forward",
+	  N_("_Forward as iCalendar…"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_forward_cb) },
+
+	{ "event-popup-meeting-new",
+	  "stock_people",
+	  N_("New _Meeting…"),
+	  NULL,
+	  N_("Create a new meeting"),
+	  G_CALLBACK (action_event_popup_new_cb) },
+
+	{ "event-popup-rsvp-submenu",
+	  NULL,
+	  N_("Send _RSVP"),
+	  NULL,
+	  N_("Send a meeting response"),
+	  NULL },
+
+	{ "event-popup-rsvp-accept",
+	  NULL,
+	  N_("_Accept"),
+	  NULL,
+	  N_("Accept meeting request"),
+	  G_CALLBACK (action_event_popup_rsvp_response_cb) },
+
+	{ "event-popup-rsvp-accept-1",
+	  NULL,
+	  N_("A_ccept this instance"),
+	  NULL,
+	  N_("Accept meeting request for selected instance only"),
+	  G_CALLBACK (action_event_popup_rsvp_response_cb) },
+
+	{ "event-popup-rsvp-decline",
+	  NULL,
+	  N_("_Decline"),
+	  NULL,
+	  N_("Decline meeting request"),
+	  G_CALLBACK (action_event_popup_rsvp_response_cb) },
+
+	{ "event-popup-rsvp-decline-1",
+	  NULL,
+	  N_("D_ecline this instance"),
+	  NULL,
+	  N_("Decline meeting request for selected instance only"),
+	  G_CALLBACK (action_event_popup_rsvp_response_cb) },
+
+	{ "event-popup-rsvp-tentative",
+	  NULL,
+	  N_("_Tentatively accept"),
+	  NULL,
+	  N_("Tentatively accept meeting request"),
+	  G_CALLBACK (action_event_popup_rsvp_response_cb) },
+
+	{ "event-popup-rsvp-tentative-1",
+	  NULL,
+	  N_("Te_ntatively accept this instance"),
+	  NULL,
+	  N_("Tentatively accept meeting request for selected instance only"),
+	  G_CALLBACK (action_event_popup_rsvp_response_cb) },
+
+	{ "event-move",
+	  NULL,
+	  N_("Mo_ve to Calendar…"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_move_cb) },
+
+	{ "event-popup-new",
+	  "appointment-new",
+	  N_("New _Appointment…"),
+	  NULL,
+	  N_("Create a new appointment"),
+	  G_CALLBACK (action_event_popup_new_cb) },
+
+	{ "event-occurrence-movable",
+	  NULL,
+	  N_("Make this Occurrence _Movable"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_occurrence_movable_cb) },
+
+	{ "event-open",
+	  "document-open",
+	  N_("_Open Appointment"),
+	  "<Control>o",
+	  N_("View the current appointment"),
+	  G_CALLBACK (action_event_open_cb) },
+
+	{ "event-reply",
+	  "mail-reply-sender",
+	  N_("_Reply"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_reply_cb) },
+
+	{ "event-reply-all",
+	  "mail-reply-all",
+	  N_("Reply to _All"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_reply_all_cb) },
+
+	{ "event-schedule",
+	  NULL,
+	  N_("_Schedule Meeting…"),
+	  NULL,
+	  N_("Converts an appointment to a meeting"),
+	  G_CALLBACK (action_event_schedule_cb) },
+
+	{ "event-schedule-appointment",
+	  NULL,
+	  N_("Conv_ert to Appointment…"),
+	  NULL,
+	  N_("Converts a meeting to an appointment"),
+	  G_CALLBACK (action_event_schedule_appointment_cb) },
+
+	{ "quit-calendar",
+	  "window-close",
+	  N_("Quit"),
+	  "<Control>w",
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (quit_calendar_cb) },
+
+	/*** Menus ***/
+
+	{ "calendar-actions-menu",
+	  NULL,
+	  N_("_Actions"),
+	  NULL,
+	  NULL,
+	  NULL }
+};
+
+static EPopupActionEntry calendar_popup_entries[] = {
+
+	/* FIXME No equivalent main menu items for the any of the calendar
+	 *       popup menu items and for many of the event popup menu items.
+	 *       This is an accessibility issue. */
+
+	{ "calendar-popup-copy",
+	  NULL,
+	  "calendar-copy" },
+
+	{ "calendar-popup-delete",
+	  N_("_Delete"),
+	  "calendar-delete" },
+
+	{ "calendar-popup-go-today",
+	  NULL,
+	  "calendar-go-today" },
+
+	{ "calendar-popup-jump-to",
+	  NULL,
+	  "calendar-jump-to" },
+
+	{ "calendar-popup-manage-groups",
+	  N_("_Manage groups…"),
+	  "calendar-manage-groups" },
+
+	{ "calendar-popup-properties",
+	  NULL,
+	  "calendar-properties" },
+
+	{ "calendar-popup-refresh",
+	  NULL,
+	  "calendar-refresh" },
+
+	{ "calendar-popup-refresh-backend",
+	  NULL,
+	  "calendar-refresh-backend" },
+
+	{ "calendar-popup-rename",
+	  NULL,
+	  "calendar-rename" },
+
+	{ "calendar-popup-select-all",
+	  NULL,
+	  "calendar-select-all" },
+
+	{ "calendar-popup-select-one",
+	  NULL,
+	  "calendar-select-one" },
+
+	{ "event-popup-copy",
+	  NULL,
+	  "event-copy" },
+
+	{ "event-popup-delegate",
+	  NULL,
+	  "event-delegate" },
+
+	{ "event-popup-delete",
+	  NULL,
+	  "event-delete" },
+
+	{ "event-popup-delete-occurrence",
+	  NULL,
+	  "event-delete-occurrence" },
+
+	{ "event-popup-delete-occurrence-this-and-future",
+	  NULL,
+	  "event-delete-occurrence-this-and-future" },
+
+	{ "event-popup-delete-occurrence-all",
+	  NULL,
+	  "event-delete-occurrence-all" },
+
+	{ "event-popup-edit-as-new",
+	  NULL,
+	  "event-edit-as-new" },
+
+	{ "event-popup-forward",
+	  NULL,
+	  "event-forward" },
+
+	{ "event-popup-move",
+	  NULL,
+	  "event-move" },
+
+	{ "event-popup-occurrence-movable",
+	  NULL,
+	  "event-occurrence-movable" },
+
+	{ "event-popup-open",
+	  NULL,
+	  "event-open" },
+
+	{ "event-popup-reply",
+	  NULL,
+	  "event-reply" },
+
+	{ "event-popup-reply-all",
+	  NULL,
+	  "event-reply-all" },
+
+	{ "event-popup-schedule",
+	  NULL,
+	  "event-schedule" },
+
+	{ "event-popup-schedule-appointment",
+	  NULL,
+	  "event-schedule-appointment" }
+};
+
+static GtkToggleActionEntry calendar_toggle_entries[] = {
+
+	{ "calendar-show-tag-vpane",
+	  NULL,
+	  N_("Show T_asks and Memos pane"),
+	  NULL,
+	  N_("Show Tasks and Memos pane"),
+	  G_CALLBACK (action_calendar_show_tag_vpane_cb),
+	  TRUE }
+};
+
+static GtkRadioActionEntry calendar_view_entries[] = {
+
+	/* This action represents the initial calendar view.
+	 * It should not be visible in the UI, nor should it be
+	 * possible to switch to it from another calendar view. */
+	{ "calendar-view-initial",
+	  NULL,
+	  NULL,
+	  NULL,
+	  NULL,
+	  BOGUS_INITIAL_VALUE },
+
+	{ "calendar-view-day",
+	  "view-calendar-day",
+	  N_("Day"),
+	  "<Control>y",
+	  N_("Show one day"),
+	  E_CAL_VIEW_KIND_DAY },
+
+	{ "calendar-view-list",
+	  "view-calendar-list",
+	  N_("List"),
+	  "<Control>l",
+	  N_("Show as list"),
+	  E_CAL_VIEW_KIND_LIST },
+
+	{ "calendar-view-month",
+	  "view-calendar-month",
+	  N_("Month"),
+	  "<Control>m",
+	  N_("Show one month"),
+	  E_CAL_VIEW_KIND_MONTH },
+
+	{ "calendar-view-week",
+	  "view-calendar-week",
+	  N_("Week"),
+	  "<Control>k",
+	  N_("Show one week"),
+	  E_CAL_VIEW_KIND_WEEK },
+
+	{ "calendar-view-workweek",
+	  "view-calendar-workweek",
+	  N_("Work Week"),
+	  "<Control>j",
+	  N_("Show one work week"),
+	  E_CAL_VIEW_KIND_WORKWEEK }
+};
+
+static GtkRadioActionEntry calendar_filter_entries[] = {
+
+	{ "calendar-filter-active-appointments",
+	  NULL,
+	  N_("Active Appointments"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_FILTER_ACTIVE_APPOINTMENTS },
+
+	{ "calendar-filter-any-category",
+	  NULL,
+	  N_("Any Category"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_FILTER_ANY_CATEGORY },
+
+	{ "calendar-filter-next-7-days-appointments",
+	  NULL,
+	  N_("Next 7 Days’ Appointments"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_FILTER_NEXT_7_DAYS_APPOINTMENTS },
+
+	{ "calendar-filter-occurs-less-than-5-times",
+	  NULL,
+	  N_("Occurs Less Than 5 Times"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_FILTER_OCCURS_LESS_THAN_5_TIMES },
+
+	{ "calendar-filter-unmatched",
+	  NULL,
+	  N_("Unmatched"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_FILTER_UNMATCHED }
+};
+
+static GtkRadioActionEntry calendar_search_entries[] = {
+
+	{ "calendar-search-advanced-hidden",
+	  NULL,
+	  N_("Advanced Search"),
+	  NULL,
+	  NULL,
+	  CALENDAR_SEARCH_ADVANCED },
+
+	{ "calendar-search-any-field-contains",
+	  NULL,
+	  N_("Any field contains"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_SEARCH_ANY_FIELD_CONTAINS },
+
+	{ "calendar-search-description-contains",
+	  NULL,
+	  N_("Description contains"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_SEARCH_DESCRIPTION_CONTAINS },
+
+	{ "calendar-search-summary-contains",
+	  NULL,
+	  N_("Summary contains"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  CALENDAR_SEARCH_SUMMARY_CONTAINS }
+};
+
+static GtkActionEntry lockdown_printing_entries[] = {
+
+	{ "calendar-print",
+	  "document-print",
+	  N_("Print…"),
+	  "<Control>p",
+	  N_("Print this calendar"),
+	  G_CALLBACK (action_calendar_print_cb) },
+
+	{ "calendar-print-preview",
+	  "document-print-preview",
+	  N_("Pre_view…"),
+	  NULL,
+	  N_("Preview the calendar to be printed"),
+	  G_CALLBACK (action_calendar_print_preview_cb) },
+
+	{ "event-print",
+	  "document-print",
+	  N_("Print…"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_print_cb) }
+};
+
+static EPopupActionEntry lockdown_printing_popup_entries[] = {
+
+	{ "event-popup-print",
+	  NULL,
+	  "event-print" }
+};
+
+static GtkActionEntry lockdown_save_to_disk_entries[] = {
+
+	{ "event-save-as",
+	  "document-save-as",
+	  N_("_Save as iCalendar…"),
+	  NULL,
+	  NULL,  /* XXX Add a tooltip! */
+	  G_CALLBACK (action_event_save_as_cb) },
+};
+
+static EPopupActionEntry lockdown_save_to_disk_popup_entries[] = {
+
+	{ "event-popup-save-as",
+	  NULL,
+	  "event-save-as" },
+};
+
+void
+e_cal_shell_view_actions_init (ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	EShellSearchbar *searchbar;
+	GtkActionGroup *action_group;
+	GtkAction *action;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	searchbar = e_cal_shell_content_get_searchbar (cal_shell_content);
+
+	/* Calendar Actions */
+	action_group = ACTION_GROUP (CALENDAR);
+	gtk_action_group_add_actions (
+		action_group, calendar_entries,
+		G_N_ELEMENTS (calendar_entries), cal_shell_view);
+	e_action_group_add_popup_actions (
+		action_group, calendar_popup_entries,
+		G_N_ELEMENTS (calendar_popup_entries));
+	gtk_action_group_add_toggle_actions (
+		action_group, calendar_toggle_entries,
+		G_N_ELEMENTS (calendar_toggle_entries), cal_shell_view);
+	gtk_action_group_add_radio_actions (
+		action_group, calendar_view_entries,
+		G_N_ELEMENTS (calendar_view_entries), BOGUS_INITIAL_VALUE,
+		G_CALLBACK (action_calendar_view_cb), cal_shell_view);
+	gtk_action_group_add_radio_actions (
+		action_group, calendar_search_entries,
+		G_N_ELEMENTS (calendar_search_entries),
+		-1, NULL, NULL);
+
+	/* Advanced Search Action */
+	action = ACTION (CALENDAR_SEARCH_ADVANCED_HIDDEN);
+	gtk_action_set_visible (action, FALSE);
+	if (searchbar)
+		e_shell_searchbar_set_search_option (
+			searchbar, GTK_RADIO_ACTION (action));
+
+	/* Lockdown Printing Actions */
+	action_group = ACTION_GROUP (LOCKDOWN_PRINTING);
+	gtk_action_group_add_actions (
+		action_group, lockdown_printing_entries,
+		G_N_ELEMENTS (lockdown_printing_entries), cal_shell_view);
+	e_action_group_add_popup_actions (
+		action_group, lockdown_printing_popup_entries,
+		G_N_ELEMENTS (lockdown_printing_popup_entries));
+
+	/* Lockdown Save-to-Disk Actions */
+	action_group = ACTION_GROUP (LOCKDOWN_SAVE_TO_DISK);
+	gtk_action_group_add_actions (
+		action_group, lockdown_save_to_disk_entries,
+		G_N_ELEMENTS (lockdown_save_to_disk_entries), cal_shell_view);
+	e_action_group_add_popup_actions (
+		action_group, lockdown_save_to_disk_popup_entries,
+		G_N_ELEMENTS (lockdown_save_to_disk_popup_entries));
+
+	/* Fine tuning. */
+
+	action = ACTION (CALENDAR_GO_TODAY);
+	gtk_action_set_short_label (action, _("Today"));
+
+	action = ACTION (CALENDAR_JUMP_TO);
+	gtk_action_set_short_label (action, _("Go To"));
+
+	action = ACTION (CALENDAR_VIEW_DAY);
+	gtk_action_set_is_important (action, TRUE);
+
+	action = ACTION (CALENDAR_VIEW_LIST);
+	gtk_action_set_is_important (action, TRUE);
+
+	action = ACTION (CALENDAR_VIEW_MONTH);
+	gtk_action_set_is_important (action, TRUE);
+
+	action = ACTION (CALENDAR_VIEW_WEEK);
+	gtk_action_set_is_important (action, TRUE);
+
+	action = ACTION (CALENDAR_VIEW_WORKWEEK);
+	gtk_action_set_is_important (action, TRUE);
+
+	action = ACTION (CALENDAR_SHOW_TAG_VPANE);
+	g_settings_bind (
+		cal_shell_view->priv->settings, "show-tag-vpane",
+		action, "active",
+		G_SETTINGS_BIND_GET);
+
+	/* Initialize the memo and task pad actions. */
+	e_cal_shell_view_memopad_actions_init (cal_shell_view);
+	e_cal_shell_view_taskpad_actions_init (cal_shell_view);
+}
+
+void
+e_cal_shell_view_update_search_filter (ECalShellView *cal_shell_view)
+{
+	ECalShellContent *cal_shell_content;
+	EShellView *shell_view;
+	EShellWindow *shell_window;
+	EShellSearchbar *searchbar;
+	EActionComboBox *combo_box;
+	GtkActionGroup *action_group;
+	GtkRadioAction *radio_action;
+	GList *list, *iter;
+	GSList *group;
+	gint ii;
+
+	shell_view = E_SHELL_VIEW (cal_shell_view);
+	shell_window = e_shell_view_get_shell_window (shell_view);
+
+	action_group = ACTION_GROUP (CALENDAR_FILTER);
+	e_action_group_remove_all_actions (action_group);
+
+	/* Add the standard filter actions.  No callback is needed
+	 * because changes in the EActionComboBox are detected and
+	 * handled by EShellSearchbar. */
+	gtk_action_group_add_radio_actions (
+		action_group, calendar_filter_entries,
+		G_N_ELEMENTS (calendar_filter_entries),
+		CALENDAR_FILTER_ANY_CATEGORY, NULL, NULL);
+
+	/* Retrieve the radio group from an action we just added. */
+	list = gtk_action_group_list_actions (action_group);
+	radio_action = GTK_RADIO_ACTION (list->data);
+	group = gtk_radio_action_get_group (radio_action);
+	g_list_free (list);
+
+	/* Build the category actions. */
+
+	list = e_util_dup_searchable_categories ();
+	for (iter = list, ii = 0; iter != NULL; iter = iter->next, ii++) {
+		const gchar *category_name = iter->data;
+		gchar *filename;
+		GtkAction *action;
+		gchar *action_name;
+
+		action_name = g_strdup_printf (
+			"calendar-filter-category-%d", ii);
+		radio_action = gtk_radio_action_new (
+			action_name, category_name, NULL, NULL, ii);
+		g_free (action_name);
+
+		/* Convert the category icon file to a themed icon name. */
+		filename = e_categories_dup_icon_file_for (category_name);
+		if (filename != NULL && *filename != '\0') {
+			gchar *basename;
+			gchar *cp;
+
+			basename = g_path_get_basename (filename);
+
+			/* Lose the file extension. */
+			if ((cp = strrchr (basename, '.')) != NULL)
+				*cp = '\0';
+
+			g_object_set (
+				radio_action, "icon-name", basename, NULL);
+
+			g_free (basename);
+		}
+
+		g_free (filename);
+
+		gtk_radio_action_set_group (radio_action, group);
+		group = gtk_radio_action_get_group (radio_action);
+
+		/* The action group takes ownership of the action. */
+		action = GTK_ACTION (radio_action);
+		gtk_action_group_add_action (action_group, action);
+		g_object_unref (radio_action);
+	}
+	g_list_free_full (list, g_free);
+
+	cal_shell_content = cal_shell_view->priv->cal_shell_content;
+	searchbar = e_cal_shell_content_get_searchbar (cal_shell_content);
+	if (searchbar) {
+		combo_box = e_shell_searchbar_get_filter_combo_box (searchbar);
+
+		e_shell_view_block_execute_search (shell_view);
+
+		/* Use any action in the group; doesn't matter which. */
+		e_action_combo_box_set_action (combo_box, radio_action);
+
+		ii = CALENDAR_FILTER_UNMATCHED;
+		e_action_combo_box_add_separator_after (combo_box, ii);
+
+		ii = CALENDAR_FILTER_OCCURS_LESS_THAN_5_TIMES;
+		e_action_combo_box_add_separator_after (combo_box, ii);
+
+		e_shell_view_unblock_execute_search (shell_view);
+	}
+}
diff -urN a/src/modules/calendar/e-cal-shell-view-memopad.c b/src/modules/calendar/e-cal-shell-view-memopad.c
--- a/src/modules/calendar/e-cal-shell-view-memopad.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-cal-shell-view-memopad.c	2022-01-08 18:47:17.614878237 -0800
@@ -250,7 +250,7 @@
 	{ "calendar-memopad-open",
 	  "document-open",
 	  N_("_Open Memo"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("View the selected memo"),
 	  G_CALLBACK (action_calendar_memopad_open_cb) },
 
diff -urN a/src/modules/calendar/e-cal-shell-view-taskpad.c b/src/modules/calendar/e-cal-shell-view-taskpad.c
--- a/src/modules/calendar/e-cal-shell-view-taskpad.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-cal-shell-view-taskpad.c	2022-01-08 18:47:17.614878237 -0800
@@ -344,7 +344,7 @@
 	{ "calendar-taskpad-open",
 	  "document-open",
 	  N_("_Open Task"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("View the selected task"),
 	  G_CALLBACK (action_calendar_taskpad_open_cb) },
 
diff -urN a/src/modules/calendar/e-memo-shell-backend.c b/src/modules/calendar/e-memo-shell-backend.c
--- a/src/modules/calendar/e-memo-shell-backend.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-memo-shell-backend.c	2022-01-08 18:47:17.614878237 -0800
@@ -75,14 +75,14 @@
 	{ "memo-new",
 	  "stock_insert-note",
 	  NC_("New", "Mem_o"),
-	  "<Shift><Control>o",
+	  "<Shift><Super>o",
 	  N_("Create a new memo"),
 	  G_CALLBACK (action_memo_new_cb) },
 
 	{ "memo-shared-new",
 	  "stock_insert-note",
 	  NC_("New", "_Shared Memo"),
-	  "<Shift><Control>u",
+	  "<Shift><Super>u",
 	  N_("Create a new shared memo"),
 	  G_CALLBACK (action_memo_new_cb) }
 };
diff -urN a/src/modules/calendar/e-memo-shell-view-actions.c b/src/modules/calendar/e-memo-shell-view-actions.c
--- a/src/modules/calendar/e-memo-shell-view-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-memo-shell-view-actions.c	2022-01-08 18:47:17.614878237 -0800
@@ -575,21 +575,21 @@
 	{ "memo-find",
 	  "edit-find",
 	  N_("_Find in Memo…"),
-	  "<Shift><Control>f",
+	  "<Shift><Super>f",
 	  N_("Search for text in the displayed memo"),
 	  G_CALLBACK (action_memo_find_cb) },
 
 	{ "memo-forward",
 	  "mail-forward",
 	  N_("_Forward as iCalendar…"),
-	  "<Control>f",
+	  "<Super>f",
 	  NULL,  /* XXX Add a tooltip! */
 	  G_CALLBACK (action_memo_forward_cb) },
 
 	{ "memo-list-copy",
 	  "edit-copy",
 	  N_("_Copy…"),
-	  "<Control>c",
+	  "<Super>c",
 	  NULL,  /* XXX Add a tooltip! */
 	  G_CALLBACK (action_memo_list_copy_cb) },
 
@@ -666,7 +666,7 @@
 	{ "memo-open",
 	  "document-open",
 	  N_("_Open Memo"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("View the selected memo"),
 	  G_CALLBACK (action_memo_open_cb) },
 
@@ -743,7 +743,7 @@
 	{ "memo-preview",
 	  NULL,
 	  N_("Memo _Preview"),
-	  "<Control>m",
+	  "<Super>m",
 	  N_("Show memo preview pane"),
 	  G_CALLBACK (action_memo_preview_cb),
 	  TRUE }
@@ -829,7 +829,7 @@
 	{ "memo-list-print",
 	  "document-print",
 	  N_("Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  N_("Print the list of memos"),
 	  G_CALLBACK (action_memo_list_print_cb) },
 
diff -urN a/src/modules/calendar/e-task-shell-backend.c b/src/modules/calendar/e-task-shell-backend.c
--- a/src/modules/calendar/e-task-shell-backend.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-task-shell-backend.c	2022-01-08 18:47:17.614878237 -0800
@@ -73,14 +73,14 @@
 	{ "task-new",
 	  "stock_task",
 	  NC_("New", "_Task"),
-	  "<Shift><Control>t",
+	  "<Shift><Super>t",
 	  N_("Create a new task"),
 	  G_CALLBACK (action_task_new_cb) },
 
 	{ "task-assigned-new",
 	  "stock_task-assigned-to",
 	  NC_("New", "Assigne_d Task"),
-	  "<Shift><Control>i",
+	  "<Shift><Super>i",
 	  N_("Create a new assigned task"),
 	  G_CALLBACK (action_task_new_cb) }
 };
diff -urN a/src/modules/calendar/e-task-shell-view-actions.c b/src/modules/calendar/e-task-shell-view-actions.c
--- a/src/modules/calendar/e-task-shell-view-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/calendar/e-task-shell-view-actions.c	2022-01-08 18:47:17.614878237 -0800
@@ -701,21 +701,21 @@
 	{ "task-find",
 	  "edit-find",
 	  N_("_Find in Task…"),
-	  "<Shift><Control>f",
+	  "<Shift><Super>f",
 	  N_("Search for text in the displayed task"),
 	  G_CALLBACK (action_task_find_cb) },
 
 	{ "task-forward",
 	  "mail-forward",
 	  N_("_Forward as iCalendar…"),
-	  "<Control>f",
+	  "<Super>f",
 	  NULL,  /* XXX Add a tooltip! */
 	  G_CALLBACK (action_task_forward_cb) },
 
 	{ "task-list-copy",
 	  "edit-copy",
 	  N_("_Copy…"),
-	  "<Control>c",
+	  "<Super>c",
 	  NULL,  /* XXX Add a tooltip! */
 	  G_CALLBACK (action_task_list_copy_cb) },
 
@@ -785,7 +785,7 @@
 	{ "task-mark-complete",
 	  NULL,
 	  N_("_Mark as Complete"),
-	  "<Control>k",
+	  "<Super>k",
 	  N_("Mark selected tasks as complete"),
 	  G_CALLBACK (action_task_mark_complete_cb) },
 
@@ -806,7 +806,7 @@
 	{ "task-open",
 	  "document-open",
 	  N_("_Open Task"),
-	  "<Control>o",
+	  "<Super>o",
 	  N_("View the selected task"),
 	  G_CALLBACK (action_task_open_cb) },
 
@@ -820,7 +820,7 @@
 	{ "task-purge",
 	  NULL,
 	  N_("Purg_e"),
-	  "<Control>e",
+	  "<Super>e",
 	  N_("Delete completed tasks"),
 	  G_CALLBACK (action_task_purge_cb) },
 
@@ -909,7 +909,7 @@
 	{ "task-preview",
 	  NULL,
 	  N_("Task _Preview"),
-	  "<Control>m",
+	  "<Super>m",
 	  N_("Show task preview pane"),
 	  G_CALLBACK (action_task_preview_cb),
 	  TRUE }
@@ -1058,7 +1058,7 @@
 	{ "task-list-print",
 	  "document-print",
 	  N_("Print…"),
-	  "<Control>p",
+	  "<Super>p",
 	  N_("Print the list of tasks"),
 	  G_CALLBACK (action_task_list_print_cb) },
 
diff -urN a/src/modules/mail/e-mail-shell-backend.c b/src/modules/mail/e-mail-shell-backend.c
--- a/src/modules/mail/e-mail-shell-backend.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/mail/e-mail-shell-backend.c	2022-01-08 18:47:17.614878237 -0800
@@ -421,7 +421,7 @@
 	{ "mail-message-new",
 	  "mail-message-new",
 	  NC_("New", "_Mail Message"),
-	  "<Shift><Control>m",
+	  "<Shift><Super>m",
 	  N_("Compose a new mail message"),
 	  G_CALLBACK (action_mail_message_new_cb) }
 };
diff -urN a/src/modules/mail/e-mail-shell-backend.c.orig b/src/modules/mail/e-mail-shell-backend.c.orig
--- a/src/modules/mail/e-mail-shell-backend.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ b/src/modules/mail/e-mail-shell-backend.c.orig	2021-12-02 23:23:53.000000000 -0800
@@ -0,0 +1,1671 @@
+/*
+ * e-mail-shell-backend.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Copyright (C) 1999-2008 Novell, Inc. (www.novell.com)
+ *
+ */
+
+#include "evolution-config.h"
+
+#include "e-mail-shell-backend.h"
+
+#include <glib/gi18n.h>
+
+#include "shell/e-shell.h"
+#include "shell/e-shell-content.h"
+#include "shell/e-shell-searchbar.h"
+#include "shell/e-shell-view.h"
+#include "shell/e-shell-window.h"
+
+#include <composer/e-msg-composer.h>
+
+#include <mail/e-mail-browser.h>
+#include <mail/e-mail-config-assistant.h>
+#include <mail/e-mail-config-window.h>
+#include <mail/e-mail-folder-create-dialog.h>
+#include <mail/e-mail-reader.h>
+#include <mail/em-composer-utils.h>
+#include <mail/em-utils.h>
+#include <mail/mail-send-recv.h>
+#include <mail/mail-vfolder-ui.h>
+#include <mail/importers/mail-importer.h>
+#include <mail/e-mail-ui-session.h>
+#include <mail/message-list.h>
+
+#include <em-format/e-mail-parser.h>
+#include <em-format/e-mail-formatter.h>
+#include <em-format/e-mail-part-utils.h>
+
+#include "e-mail-shell-content.h"
+#include "e-mail-shell-sidebar.h"
+#include "e-mail-shell-view.h"
+#include "e-mail-shell-view-private.h"
+#include "em-account-prefs.h"
+#include "em-composer-prefs.h"
+#include "em-mailer-prefs.h"
+
+#define E_MAIL_SHELL_BACKEND_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_MAIL_SHELL_BACKEND, EMailShellBackendPrivate))
+
+#define E_MAIL_SHELL_BACKEND_GET_PRIVATE(obj) \
+	(G_TYPE_INSTANCE_GET_PRIVATE \
+	((obj), E_TYPE_MAIL_SHELL_BACKEND, EMailShellBackendPrivate))
+
+#define BACKEND_NAME "mail"
+
+struct _EMailShellBackendPrivate {
+	gint mail_sync_in_progress;
+	guint mail_sync_source_id;
+	gpointer assistant; /* weak pointer, when adding new mail account */
+	gpointer editor;    /* weak pointer, when editing a mail account */
+};
+
+enum {
+	NEW_ACCOUNT,
+	EDIT_ACCOUNT,
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL];
+
+G_DEFINE_DYNAMIC_TYPE (
+	EMailShellBackend,
+	e_mail_shell_backend,
+	E_TYPE_MAIL_BACKEND)
+
+/* utility functions for mbox importer */
+static void
+mbox_create_preview_cb (GObject *preview,
+                        GtkWidget **preview_widget)
+{
+	EMailDisplay *display;
+	EMailBackend *mail_backend;
+
+	g_return_if_fail (preview != NULL);
+	g_return_if_fail (preview_widget != NULL);
+
+	mail_backend = E_MAIL_BACKEND (e_shell_get_backend_by_name (e_shell_get_default (), BACKEND_NAME));
+	g_return_if_fail (mail_backend != NULL);
+
+	display = E_MAIL_DISPLAY (e_mail_display_new (e_mail_backend_get_remote_content (mail_backend)));
+	g_object_set_data_full (
+		preview, "mbox-imp-display",
+		g_object_ref (display), g_object_unref);
+
+	*preview_widget = GTK_WIDGET (display);
+}
+
+static void
+message_parsed_cb (GObject *source_object,
+                   GAsyncResult *res,
+                   gpointer user_data)
+{
+	EMailParser *parser = E_MAIL_PARSER (source_object);
+	EMailPartList *parts_list;
+	GObject *preview = user_data;
+	EMailDisplay *display;
+	CamelFolder *folder;
+	const gchar *message_uid;
+
+	display = g_object_get_data (preview, "mbox-imp-display");
+
+	parts_list = e_mail_parser_parse_finish (parser, res, NULL);
+	if (!parts_list) {
+		g_object_unref (parser);
+		return;
+	}
+
+	folder = e_mail_part_list_get_folder (parts_list);
+	message_uid = e_mail_part_list_get_message_uid (parts_list);
+	if (message_uid) {
+		CamelObjectBag *parts_registry;
+		EMailPartList *reserved_parts_list;
+		gchar *mail_uri;
+
+		mail_uri = e_mail_part_build_uri (folder, message_uid, NULL, NULL);
+		parts_registry = e_mail_part_list_get_registry ();
+
+		reserved_parts_list = camel_object_bag_reserve (parts_registry, mail_uri);
+		g_clear_object (&reserved_parts_list);
+
+		camel_object_bag_add (parts_registry, mail_uri, parts_list);
+
+		g_free (mail_uri);
+	}
+
+	e_mail_display_set_part_list (display, parts_list);
+	e_mail_display_load (display, NULL);
+
+	g_object_unref (parts_list);
+	g_object_unref (parser);
+}
+
+static void
+mbox_fill_preview_cb (GObject *preview,
+                      CamelMimeMessage *msg)
+{
+	EShell *shell;
+	EShellBackend *shell_backend;
+	EMailDisplay *display;
+	EMailParser *parser;
+	EMailSession *mail_session = NULL;
+
+	g_return_if_fail (preview != NULL);
+	g_return_if_fail (msg != NULL);
+
+	display = g_object_get_data (preview, "mbox-imp-display");
+	g_return_if_fail (display != NULL);
+
+	shell = e_shell_get_default ();
+	shell_backend = e_shell_get_backend_by_name (shell, BACKEND_NAME);
+
+	if (E_IS_MAIL_BACKEND (shell_backend)) {
+		mail_session = e_mail_backend_get_session (E_MAIL_BACKEND (shell_backend));
+
+		if (mail_session)
+			g_object_ref (mail_session);
+	}
+
+	if (!mail_session) {
+		ESourceRegistry *registry;
+
+		registry = e_shell_get_registry (shell);
+		mail_session = e_mail_session_new (registry);
+	}
+
+	if (!camel_mime_message_get_message_id (msg))
+		camel_mime_message_set_message_id (msg, NULL);
+
+	parser = e_mail_parser_new (CAMEL_SESSION (mail_session));
+	e_mail_parser_parse (
+		parser, NULL, camel_mime_message_get_message_id (msg), msg,
+		message_parsed_cb, NULL, preview);
+
+	g_object_unref (mail_session);
+}
+
+static void
+mail_shell_backend_init_importers (void)
+{
+	EImportClass *import_class;
+	EImportImporter *importer;
+
+	import_class = g_type_class_ref (e_import_get_type ());
+
+	importer = mbox_importer_peek ();
+	e_import_class_add_importer (import_class, importer, NULL, NULL);
+	mbox_importer_set_preview_funcs (
+		mbox_create_preview_cb, mbox_fill_preview_cb);
+
+	importer = elm_importer_peek ();
+	e_import_class_add_importer (import_class, importer, NULL, NULL);
+
+	importer = pine_importer_peek ();
+	e_import_class_add_importer (import_class, importer, NULL, NULL);
+}
+
+static void
+mail_shell_backend_mail_icon_cb (EShellWindow *shell_window,
+                                 const gchar *icon_name)
+{
+	GtkAction *action;
+
+	action = e_shell_window_get_shell_view_action (
+		shell_window, BACKEND_NAME);
+	gtk_action_set_icon_name (action, icon_name);
+}
+
+static void
+mail_shell_backend_folder_created_cb (EMailFolderCreateDialog *dialog,
+                                      CamelStore *store,
+                                      const gchar *folder_name,
+                                      GWeakRef *folder_tree_weak_ref)
+{
+	EMFolderTree *folder_tree;
+
+	folder_tree = g_weak_ref_get (folder_tree_weak_ref);
+
+	if (folder_tree != NULL) {
+		gchar *folder_uri;
+
+		/* Select the newly created folder. */
+		folder_uri = e_mail_folder_uri_build (store, folder_name);
+		em_folder_tree_set_selected (folder_tree, folder_uri, FALSE);
+		g_free (folder_uri);
+
+		g_object_unref (folder_tree);
+	}
+}
+
+static void
+action_mail_folder_new_cb (GtkAction *action,
+                           EShellWindow *shell_window)
+{
+	EMFolderTree *folder_tree = NULL;
+	EMailShellSidebar *mail_shell_sidebar;
+	EMailSession *session;
+	EShellSidebar *shell_sidebar;
+	EShellView *shell_view;
+	GtkWidget *dialog;
+	const gchar *view_name;
+
+	/* Take care not to unnecessarily load the mail shell view. */
+	view_name = e_shell_window_get_active_view (shell_window);
+	if (g_strcmp0 (view_name, BACKEND_NAME) != 0) {
+		EShell *shell;
+		EShellBackend *shell_backend;
+		EMailBackend *backend;
+
+		shell = e_shell_window_get_shell (shell_window);
+
+		shell_backend =
+			e_shell_get_backend_by_name (shell, BACKEND_NAME);
+		g_return_if_fail (E_IS_MAIL_BACKEND (shell_backend));
+
+		backend = E_MAIL_BACKEND (shell_backend);
+		session = e_mail_backend_get_session (backend);
+
+		goto exit;
+	}
+
+	shell_view = e_shell_window_get_shell_view (shell_window, view_name);
+	shell_sidebar = e_shell_view_get_shell_sidebar (shell_view);
+
+	mail_shell_sidebar = E_MAIL_SHELL_SIDEBAR (shell_sidebar);
+	folder_tree = e_mail_shell_sidebar_get_folder_tree (mail_shell_sidebar);
+	session = em_folder_tree_get_session (folder_tree);
+
+exit:
+	dialog = e_mail_folder_create_dialog_new (
+		GTK_WINDOW (shell_window),
+		E_MAIL_UI_SESSION (session));
+
+	if (folder_tree != NULL) {
+		g_signal_connect_data (
+			dialog, "folder-created",
+			G_CALLBACK (mail_shell_backend_folder_created_cb),
+			e_weak_ref_new (folder_tree),
+			(GClosureNotify) e_weak_ref_free, 0);
+	}
+
+	gtk_widget_show (GTK_WIDGET (dialog));
+}
+
+static void
+action_mail_account_new_cb (GtkAction *action,
+                            EShellWindow *shell_window)
+{
+	EShell *shell;
+	EShellBackend *shell_backend;
+
+	g_return_if_fail (shell_window != NULL);
+
+	shell = e_shell_window_get_shell (shell_window);
+	shell_backend = e_shell_get_backend_by_name (shell, BACKEND_NAME);
+	g_return_if_fail (E_IS_MAIL_SHELL_BACKEND (shell_backend));
+
+	e_mail_shell_backend_new_account (
+		E_MAIL_SHELL_BACKEND (shell_backend),
+		GTK_WINDOW (shell_window));
+}
+
+typedef struct _NewComposerData
+{
+	CamelFolder *folder;
+	const gchar *message_uid; /* In the Camel string pool */
+} NewComposerData;
+
+static void
+action_mail_message_new_composer_created_cb (GObject *source_object,
+					     GAsyncResult *result,
+					     gpointer user_data)
+{
+	NewComposerData *ncd = user_data;
+	EMsgComposer *composer;
+	GError *error = NULL;
+
+	g_return_if_fail (ncd != NULL);
+
+	if (ncd->folder)
+		g_return_if_fail (CAMEL_IS_FOLDER (ncd->folder));
+
+	composer = e_msg_composer_new_finish (result, &error);
+	if (error) {
+		g_warning ("%s: Failed to create msg composer: %s", G_STRFUNC, error->message);
+		g_clear_error (&error);
+	} else {
+		em_utils_compose_new_message_with_selection (composer, ncd->folder, ncd->message_uid);
+	}
+
+	g_clear_object (&ncd->folder);
+	camel_pstring_free (ncd->message_uid);
+	g_slice_free (NewComposerData, ncd);
+}
+
+static void
+action_mail_message_new_cb (GtkAction *action,
+                            EShellWindow *shell_window)
+{
+	EShellView *shell_view;
+	EShell *shell;
+	ESourceRegistry *registry;
+	CamelFolder *folder = NULL;
+	GList *list;
+	const gchar *extension_name;
+	const gchar *view_name;
+	gboolean no_transport_defined;
+	const gchar *message_uid = NULL;
+	GtkWidget *message_list;
+	NewComposerData *ncd;
+
+	shell = e_shell_window_get_shell (shell_window);
+	registry = e_shell_get_registry (shell);
+
+	extension_name = E_SOURCE_EXTENSION_MAIL_TRANSPORT;
+	list = e_source_registry_list_sources (registry, extension_name);
+	no_transport_defined = (list == NULL);
+	g_list_free_full (list, (GDestroyNotify) g_object_unref);
+
+	if (no_transport_defined)
+		return;
+
+	/* Take care not to unnecessarily load the mail shell view. */
+	view_name = e_shell_window_get_active_view (shell_window);
+	if (g_strcmp0 (view_name, BACKEND_NAME) != 0)
+		goto exit;
+
+	shell_view = e_shell_window_get_shell_view (shell_window, view_name);
+
+	message_list = e_mail_reader_get_message_list (E_MAIL_READER (e_shell_view_get_shell_content (shell_view)));
+	if (message_list) {
+		MessageList *ml = MESSAGE_LIST (message_list);
+		GPtrArray *selected_uids;
+
+		folder = message_list_ref_folder (ml);
+
+		selected_uids = message_list_get_selected (ml);
+		if (selected_uids && selected_uids->len > 0)
+			message_uid = camel_pstring_strdup (g_ptr_array_index (selected_uids, 0));
+
+		if (!message_uid)
+			message_uid = camel_pstring_strdup (ml->cursor_uid);
+
+		if (selected_uids)
+			g_ptr_array_unref (selected_uids);
+	}
+
+ exit:
+	ncd = g_slice_new0 (NewComposerData);
+	ncd->folder = folder;
+	ncd->message_uid = message_uid;
+
+	e_msg_composer_new (shell, action_mail_message_new_composer_created_cb, ncd);
+}
+
+static GtkActionEntry item_entries[] = {
+
+	{ "mail-message-new",
+	  "mail-message-new",
+	  NC_("New", "_Mail Message"),
+	  "<Shift><Control>m",
+	  N_("Compose a new mail message"),
+	  G_CALLBACK (action_mail_message_new_cb) }
+};
+
+static GtkActionEntry source_entries[] = {
+
+	{ "mail-account-new",
+	  "evolution-mail",
+	  NC_("New", "Mail Acco_unt"),
+	  NULL,
+	  N_("Create a new mail account"),
+	  G_CALLBACK (action_mail_account_new_cb) },
+
+	{ "mail-folder-new",
+	  "folder-new",
+	  NC_("New", "Mail _Folder"),
+	  NULL,
+	  N_("Create a new mail folder"),
+	  G_CALLBACK (action_mail_folder_new_cb) }
+};
+
+static void
+mail_shell_backend_sync_store_done_cb (CamelStore *store,
+                                       gpointer user_data)
+{
+	EMailShellBackend *mail_shell_backend = user_data;
+
+	mail_shell_backend->priv->mail_sync_in_progress--;
+}
+
+static gboolean
+mail_shell_backend_mail_sync (gpointer user_data)
+{
+	EMailShellBackend *mail_shell_backend;
+	EShell *shell;
+	EShellBackend *shell_backend;
+	EMailBackend *backend;
+	EMailSession *session;
+	GList *list, *link;
+
+	mail_shell_backend = E_MAIL_SHELL_BACKEND (user_data);
+
+	shell_backend = E_SHELL_BACKEND (mail_shell_backend);
+	shell = e_shell_backend_get_shell (shell_backend);
+
+	/* Obviously we can only sync in online mode. */
+	if (!e_shell_get_online (shell))
+		goto exit;
+
+	/* If a sync is still in progress, skip this round. */
+	if (mail_shell_backend->priv->mail_sync_in_progress)
+		goto exit;
+
+	backend = E_MAIL_BACKEND (mail_shell_backend);
+	session = e_mail_backend_get_session (backend);
+
+	list = camel_session_list_services (CAMEL_SESSION (session));
+
+	for (link = list; link != NULL; link = g_list_next (link)) {
+		CamelService *service;
+
+		service = CAMEL_SERVICE (link->data);
+
+		if (!CAMEL_IS_STORE (service))
+			continue;
+
+		mail_shell_backend->priv->mail_sync_in_progress++;
+
+		mail_sync_store (
+			CAMEL_STORE (service), FALSE,
+			mail_shell_backend_sync_store_done_cb,
+			mail_shell_backend);
+	}
+
+	g_list_free_full (list, (GDestroyNotify) g_object_unref);
+
+exit:
+	return TRUE;
+}
+
+static EShellWindow *
+mail_shell_backend_get_mail_window (EShell *shell)
+{
+	GList *link;
+
+	for (link = gtk_application_get_windows (GTK_APPLICATION (shell)); link; link = g_list_next (link)) {
+		GtkWindow *window = GTK_WINDOW (link->data);
+
+		if (E_IS_SHELL_WINDOW (window)) {
+			EShellWindow *shell_window;
+			const gchar *active_view;
+
+			shell_window = E_SHELL_WINDOW (window);
+			active_view = e_shell_window_get_active_view (shell_window);
+
+			if (g_strcmp0 (active_view, "mail") == 0)
+				return shell_window;
+		}
+	}
+
+	return E_SHELL_WINDOW (e_shell_create_shell_window (shell, "mail"));
+}
+
+static void
+mail_shell_backend_select_folder_uri (EMailShellBackend *mail_shell_backend,
+				      const gchar *in_uri)
+{
+	EMailSession *mail_session;
+	CamelSession *session;
+	CamelStore *store = NULL;
+	gchar *decoded_uri = NULL;
+	gchar *folder_uri = NULL;
+	const gchar *uri = in_uri;
+
+	g_return_if_fail (E_IS_MAIL_SHELL_BACKEND (mail_shell_backend));
+	g_return_if_fail (uri != NULL);
+	g_return_if_fail (g_str_has_prefix (uri, "folder:"));
+
+	mail_session = e_mail_backend_get_session (E_MAIL_BACKEND (mail_shell_backend));
+	session = CAMEL_SESSION (mail_session);
+
+	if (strchr (uri, '%')) {
+		decoded_uri = g_uri_unescape_string (uri, NULL);
+
+		if (decoded_uri)
+			uri = decoded_uri;
+	}
+
+	if (!e_mail_folder_uri_parse (session, uri, &store, NULL, NULL)) {
+		folder_uri = em_utils_account_path_to_folder_uri (session, uri + 7 /* strlen ("folder:") */);
+
+		if (folder_uri) {
+			if (e_mail_folder_uri_parse (session, folder_uri, &store, NULL, NULL))
+				uri = folder_uri;
+		}
+	}
+
+	if (store) {
+		EShellWindow *window;
+		EShell *shell;
+
+		shell = e_shell_backend_get_shell (E_SHELL_BACKEND (mail_shell_backend));
+		window = mail_shell_backend_get_mail_window (shell);
+
+		if (window) {
+			EShellView *shell_view;
+
+			shell_view = e_shell_window_get_shell_view (window, "mail");
+
+			if (shell_view) {
+				EShellSidebar *shell_sidebar;
+				EMFolderTree *folder_tree;
+
+				shell_sidebar = e_shell_view_get_shell_sidebar (shell_view);
+				folder_tree = e_mail_shell_sidebar_get_folder_tree (E_MAIL_SHELL_SIDEBAR (shell_sidebar));
+
+				em_folder_tree_set_selected (folder_tree, folder_uri ? folder_uri : uri, FALSE);
+			}
+
+			gtk_window_present (GTK_WINDOW (window));
+		}
+	}
+
+	g_clear_object (&store);
+	g_free (decoded_uri);
+	g_free (folder_uri);
+}
+
+static void
+mail_shell_backend_search_mid (EMailShellBackend *mail_shell_backend,
+			       const gchar *in_uri)
+{
+	EShellWindow *window;
+	EShell *shell;
+	gchar *decoded_uri = NULL;
+	const gchar *uri = in_uri, *message_id;
+
+	g_return_if_fail (E_IS_MAIL_SHELL_BACKEND (mail_shell_backend));
+	g_return_if_fail (uri != NULL);
+	g_return_if_fail (g_str_has_prefix (uri, "mid:"));
+
+	if (strchr (uri, '%')) {
+		decoded_uri = g_uri_unescape_string (uri, NULL);
+
+		if (decoded_uri)
+			uri = decoded_uri;
+	}
+
+	message_id = uri + 4; /* strlen ("mid:") */
+
+	if (!*message_id) {
+		g_free (decoded_uri);
+		return;
+	}
+
+	shell = e_shell_backend_get_shell (E_SHELL_BACKEND (mail_shell_backend));
+	window = mail_shell_backend_get_mail_window (shell);
+
+	if (window) {
+		EShellView *shell_view;
+
+		shell_view = e_shell_window_get_shell_view (window, "mail");
+
+		if (shell_view) {
+			EShellSearchbar *shell_searchbar;
+			EShellWindow *shell_window = E_SHELL_WINDOW (window);
+			GString *expr;
+			GtkAction *action;
+			gint ii;
+
+			shell_searchbar = e_mail_shell_content_get_searchbar (E_MAIL_SHELL_CONTENT (e_shell_view_get_shell_content (shell_view)));
+
+			expr = g_string_sized_new (strlen (message_id) + 4 + 2 + 1); /* strlen ("mid:") + 2 * strlen ("\"") + NUL-terminator */
+			g_string_append (expr, "mid:\"");
+
+			for (ii = 0; message_id[ii]; ii++) {
+				/* skip white-spaces and double-quotes */
+				if (!g_ascii_isspace (message_id[ii]) && message_id[ii] != '\"')
+					g_string_append_c (expr, message_id[ii]);
+			}
+
+			g_string_append_c (expr, '\"');
+
+			e_shell_view_block_execute_search (shell_view);
+
+			action = ACTION (MAIL_FILTER_ALL_MESSAGES);
+			gtk_action_activate (action);
+
+			action = ACTION (MAIL_SEARCH_FREE_FORM_EXPR);
+			gtk_action_activate (action);
+
+			action = ACTION (MAIL_SCOPE_ALL_ACCOUNTS);
+			gtk_action_activate (action);
+
+			e_shell_view_set_search_rule (shell_view, NULL);
+			e_shell_searchbar_set_search_text (shell_searchbar, expr->str);
+
+			e_shell_view_unblock_execute_search (shell_view);
+			e_shell_view_execute_search (shell_view);
+
+			g_string_free (expr, TRUE);
+		}
+
+		gtk_window_present (GTK_WINDOW (window));
+	}
+
+	g_free (decoded_uri);
+}
+
+static gboolean
+mail_shell_backend_handle_uri_cb (EShell *shell,
+                                  const gchar *uri,
+                                  EMailShellBackend *mail_shell_backend)
+{
+	gboolean handled = TRUE;
+
+	if (g_str_has_prefix (uri, "mailto:")) {
+		em_utils_compose_new_message_with_mailto (shell, uri, NULL);
+	} else if (g_str_has_prefix (uri, "folder:")) {
+		mail_shell_backend_select_folder_uri (mail_shell_backend, uri);
+	} else if (g_str_has_prefix (uri, "mid:")) {
+		mail_shell_backend_search_mid (mail_shell_backend, uri);
+	} else {
+		handled = FALSE;
+	}
+
+	return handled;
+}
+
+static void
+mail_shell_backend_prepare_for_quit_cb (EShell *shell,
+                                        EActivity *activity,
+                                        EShellBackend *shell_backend)
+{
+	EMailShellBackendPrivate *priv;
+
+	priv = E_MAIL_SHELL_BACKEND_GET_PRIVATE (shell_backend);
+
+	/* Prevent a sync from starting while trying to shutdown. */
+	if (priv->mail_sync_source_id > 0) {
+		g_source_remove (priv->mail_sync_source_id);
+		priv->mail_sync_source_id = 0;
+	}
+}
+
+static void
+mail_shell_backend_window_weak_notify_cb (EShell *shell,
+                                          GObject *where_the_object_was)
+{
+	g_signal_handlers_disconnect_by_func (
+		shell, mail_shell_backend_mail_icon_cb,
+		where_the_object_was);
+}
+
+static void
+set_preformatted_block_format_on_load_finished_cb (EContentEditor *cnt_editor,
+						   gpointer user_data)
+{
+	g_return_if_fail (E_IS_CONTENT_EDITOR (cnt_editor));
+
+	if (!e_content_editor_get_html_mode (cnt_editor)) {
+		e_content_editor_set_block_format (cnt_editor, E_CONTENT_EDITOR_BLOCK_FORMAT_PRE);
+		e_content_editor_set_changed (cnt_editor, FALSE);
+		e_content_editor_clear_undo_redo_history (cnt_editor);
+	}
+
+	g_signal_handlers_disconnect_by_func (cnt_editor,
+		G_CALLBACK (set_preformatted_block_format_on_load_finished_cb), NULL);
+}
+
+static void
+mail_shell_backend_window_added_cb (GtkApplication *application,
+                                    GtkWindow *window,
+                                    EShellBackend *shell_backend)
+{
+	EShell *shell = E_SHELL (application);
+	EMailBackend *backend;
+	EMailSession *session;
+	EHTMLEditor *editor = NULL;
+	const gchar *backend_name;
+
+	backend = E_MAIL_BACKEND (shell_backend);
+	session = e_mail_backend_get_session (backend);
+
+	if (E_IS_MSG_COMPOSER (window))
+		editor = e_msg_composer_get_editor (E_MSG_COMPOSER (window));
+
+	if (E_IS_MAIL_SIGNATURE_EDITOR (window))
+		editor = e_mail_signature_editor_get_editor (
+			E_MAIL_SIGNATURE_EDITOR (window));
+
+	/* This applies to both the composer and signature editor. */
+	if (editor != NULL) {
+		EContentEditor *cnt_editor;
+		GSettings *settings;
+		gboolean use_html, use_preformatted;
+
+		cnt_editor = e_html_editor_get_content_editor (editor);
+
+		settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+		use_html = g_settings_get_boolean (settings, "composer-send-html");
+		use_preformatted = g_settings_get_boolean (settings, "composer-plain-text-starts-preformatted");
+
+		g_object_unref (settings);
+
+		e_content_editor_set_html_mode (cnt_editor, use_html);
+
+		if (use_preformatted) {
+			g_signal_connect (cnt_editor, "load-finished",
+				G_CALLBACK (set_preformatted_block_format_on_load_finished_cb), NULL);
+		}
+	}
+
+	if (E_IS_MSG_COMPOSER (window)) {
+		/* Start the mail backend if it isn't already.  This
+		 * may be necessary when opening a new composer window
+		 * from a shell view other than mail. */
+		e_shell_backend_start (shell_backend);
+
+		/* Integrate the new composer into the mail module. */
+		em_configure_new_composer (
+			E_MSG_COMPOSER (window), session);
+		return;
+	}
+
+	if (!E_IS_SHELL_WINDOW (window))
+		return;
+
+	backend_name = E_SHELL_BACKEND_GET_CLASS (shell_backend)->name;
+
+	e_shell_window_register_new_item_actions (
+		E_SHELL_WINDOW (window), backend_name,
+		item_entries, G_N_ELEMENTS (item_entries));
+
+	e_shell_window_register_new_source_actions (
+		E_SHELL_WINDOW (window), backend_name,
+		source_entries, G_N_ELEMENTS (source_entries));
+
+	g_signal_connect_swapped (
+		shell, "event::mail-icon",
+		G_CALLBACK (mail_shell_backend_mail_icon_cb), window);
+
+	g_object_weak_ref (
+		G_OBJECT (window), (GWeakNotify)
+		mail_shell_backend_window_weak_notify_cb, shell);
+}
+
+static void
+mail_shell_backend_disconnect_done_cb (GObject *source_object,
+                                       GAsyncResult *result,
+                                       gpointer user_data)
+{
+	CamelService *service;
+	EActivity *activity;
+	EAlertSink *alert_sink;
+	GError *error = NULL;
+
+	service = CAMEL_SERVICE (source_object);
+	activity = E_ACTIVITY (user_data);
+
+	alert_sink = e_activity_get_alert_sink (activity);
+
+	camel_service_disconnect_finish (service, result, &error);
+
+	if (e_activity_handle_cancellation (activity, error)) {
+		g_error_free (error);
+
+	} else if (error != NULL) {
+		e_alert_submit (
+			alert_sink,
+			"mail:disconnect",
+			camel_service_get_display_name (service),
+			error->message, NULL);
+		g_error_free (error);
+
+	} else {
+		e_activity_set_state (activity, E_ACTIVITY_COMPLETED);
+	}
+
+	g_object_unref (activity);
+}
+
+static void
+mail_shell_backend_changes_committed_cb (EMailConfigWindow *window,
+                                         EMailShellBackend *mail_shell_backend)
+{
+	EMailSession *session;
+	EShell *shell;
+	EShellBackend *shell_backend;
+	ESource *original_source;
+	CamelService *service;
+	EActivity *activity;
+	GCancellable *cancellable;
+	GList *list, *link;
+	const gchar *uid;
+
+	session = e_mail_config_window_get_session (window);
+	original_source = e_mail_config_window_get_original_source (window);
+
+	uid = e_source_get_uid (original_source);
+	service = camel_session_ref_service (CAMEL_SESSION (session), uid);
+	g_return_if_fail (service != NULL);
+
+	shell_backend = E_SHELL_BACKEND (mail_shell_backend);
+
+	shell = e_shell_backend_get_shell (shell_backend);
+	list = gtk_application_get_windows (GTK_APPLICATION (shell));
+
+	activity = e_activity_new ();
+
+	/* Find an EShellWindow to serve as an EAlertSink. */
+	for (link = list; link != NULL; link = g_list_next (link)) {
+		GtkWindow *appwindow = GTK_WINDOW (link->data);
+
+		if (E_IS_SHELL_WINDOW (appwindow)) {
+			EAlertSink *alert_sink = E_ALERT_SINK (appwindow);
+			e_activity_set_alert_sink (activity, alert_sink);
+			break;
+		}
+	}
+
+	cancellable = camel_operation_new ();
+	e_activity_set_cancellable (activity, cancellable);
+
+	e_shell_backend_add_activity (shell_backend, activity);
+
+	camel_service_disconnect (
+		service, TRUE, G_PRIORITY_DEFAULT, cancellable,
+		mail_shell_backend_disconnect_done_cb, activity);
+
+	g_object_unref (cancellable);
+
+	g_object_unref (service);
+}
+
+static gboolean
+network_monitor_gio_name_to_active_id (GBinding *binding,
+				       const GValue *from_value,
+				       GValue *to_value,
+				       gpointer user_data)
+{
+	const gchar *gio_name_value;
+
+	gio_name_value = g_value_get_string (from_value);
+
+	if (g_strcmp0 (gio_name_value, E_NETWORK_MONITOR_ALWAYS_ONLINE_NAME) == 0) {
+		g_value_set_string (to_value, gio_name_value);
+	} else {
+		ENetworkMonitor *network_monitor;
+		GSList *gio_names, *link;
+
+		network_monitor = E_NETWORK_MONITOR (e_network_monitor_get_default ());
+		gio_names = e_network_monitor_list_gio_names (network_monitor);
+		for (link = gio_names; link; link = g_slist_next (link)) {
+			const gchar *gio_name = link->data;
+
+			g_warn_if_fail (gio_name != NULL);
+
+			if (g_strcmp0 (gio_name_value, gio_name) == 0)
+				break;
+		}
+		g_slist_free_full (gio_names, g_free);
+
+		/* Stopped before checked all the gio_names, thus found a match */
+		if (link)
+			g_value_set_string (to_value, gio_name_value);
+		else
+			g_value_set_string (to_value, "default");
+	}
+
+	return TRUE;
+}
+
+static gchar *
+network_monitor_get_default_gio_name (void)
+{
+	GNetworkMonitor *default_monitor;
+	GIOExtensionPoint *pnt;
+	GList *extensions, *link;
+	GType default_type;
+
+	default_monitor = g_network_monitor_get_default ();
+
+	if (!default_monitor)
+		return NULL;
+
+	pnt = g_io_extension_point_lookup (G_NETWORK_MONITOR_EXTENSION_POINT_NAME);
+	if (!pnt)
+		return NULL;
+
+	default_type = G_OBJECT_TYPE (default_monitor);
+	extensions = g_io_extension_point_get_extensions (pnt);
+
+	for (link = extensions; link; link = g_list_next (link)) {
+		GIOExtension *ext = link->data;
+
+		if (default_type == g_io_extension_get_type (ext))
+			return g_strdup (g_io_extension_get_name (ext));
+	}
+
+	return NULL;
+}
+
+static GtkWidget *
+mail_shell_backend_create_network_page (EPreferencesWindow *window)
+{
+	EShell *shell;
+	ESourceRegistry *registry;
+	GtkBox *vbox, *hbox;
+	GtkWidget *widget, *label;
+	PangoAttrList *bold;
+	ENetworkMonitor *network_monitor;
+	GSList *gio_names, *link;
+	gchar *default_gio_name, *default_caption = NULL;
+
+	const gchar *known_gio_names[] = {
+		/* Translators: One of the known implementation names of the GNetworkMonitor. Either translate
+		    it to some user-friendly form, or keep it as is. */
+		NC_("NetworkMonitor", "base"),
+		/* Translators: One of the known implementation names of the GNetworkMonitor. Either translate
+		    it to some user-friendly form, or keep it as is. */
+		NC_("NetworkMonitor", "netlink"),
+		/* Translators: One of the known implementation names of the GNetworkMonitor. Either translate
+		    it to some user-friendly form, or keep it as is. */
+		NC_("NetworkMonitor", "networkmanager")
+	};
+
+	/* To quiet a gcc warning about unused variable */
+	known_gio_names[0] = known_gio_names[1];
+
+	shell = e_preferences_window_get_shell (window);
+	registry = e_shell_get_registry (shell);
+
+	bold = pango_attr_list_new ();
+	pango_attr_list_insert (bold, pango_attr_weight_new (PANGO_WEIGHT_BOLD));
+
+	vbox = GTK_BOX (gtk_box_new (GTK_ORIENTATION_VERTICAL, 4));
+	gtk_container_set_border_width (GTK_CONTAINER (vbox), 12);
+
+	widget = gtk_label_new (_("General"));
+	g_object_set (G_OBJECT (widget),
+		"hexpand", FALSE,
+		"halign", GTK_ALIGN_START,
+		"vexpand", FALSE,
+		"valign", GTK_ALIGN_START,
+		"attributes", bold,
+		NULL);
+	gtk_widget_show (widget);
+	gtk_box_pack_start (vbox, widget, FALSE, FALSE, 0);
+
+	pango_attr_list_unref (bold);
+
+	hbox = GTK_BOX (gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 4));
+	gtk_widget_set_margin_start (GTK_WIDGET (hbox), 12);
+
+	label = gtk_label_new_with_mnemonic (C_("NetworkMonitor", "Method to detect _online state:"));
+	gtk_box_pack_start (hbox, label, FALSE, FALSE, 0);
+
+	widget = gtk_combo_box_text_new ();
+	gtk_box_pack_start (hbox, widget, FALSE, FALSE, 0);
+
+	gtk_label_set_mnemonic_widget (GTK_LABEL (label), widget);
+
+	default_gio_name = network_monitor_get_default_gio_name ();
+	if (default_gio_name && *default_gio_name) {
+		/* Translators: The '%s' is replaced with the actual name of the GNetworkMonitor implementation */
+		default_caption = g_strdup_printf (C_("NetworkMonitor", "Default (%s)"), g_dpgettext2 (NULL, "NetworkMonitor", default_gio_name));
+	}
+
+	/* Always as the first */
+	gtk_combo_box_text_append (GTK_COMBO_BOX_TEXT (widget), "default", default_caption ? default_caption : C_("NetworkMonitor", "Default"));
+
+	g_free (default_gio_name);
+	g_free (default_caption);
+
+	network_monitor = E_NETWORK_MONITOR (e_network_monitor_get_default ());
+	gio_names = e_network_monitor_list_gio_names (network_monitor);
+	for (link = gio_names; link; link = g_slist_next (link)) {
+		const gchar *gio_name = link->data;
+
+		g_warn_if_fail (gio_name != NULL);
+
+		gtk_combo_box_text_append (GTK_COMBO_BOX_TEXT (widget), gio_name, g_dpgettext2 (NULL, "NetworkMonitor", gio_name));
+	}
+	g_slist_free_full (gio_names, g_free);
+
+	/* Always as the last */
+	gtk_combo_box_text_append (GTK_COMBO_BOX_TEXT (widget), E_NETWORK_MONITOR_ALWAYS_ONLINE_NAME, C_("NetworkMonitor", "Always Online"));
+
+	e_binding_bind_property_full (
+		network_monitor, "gio-name",
+		widget, "active-id",
+		G_BINDING_BIDIRECTIONAL | G_BINDING_SYNC_CREATE,
+		network_monitor_gio_name_to_active_id,
+		NULL,
+		NULL, NULL);
+
+	gtk_widget_show_all (GTK_WIDGET (hbox));
+	gtk_box_pack_start (vbox, GTK_WIDGET (hbox), FALSE, FALSE, 0);
+
+	widget = e_proxy_preferences_new (registry);
+	gtk_widget_show (widget);
+	gtk_box_pack_start (vbox, widget, TRUE, TRUE, 0);
+
+	return GTK_WIDGET (vbox);
+}
+
+static void
+mail_shell_backend_constructed (GObject *object)
+{
+	EShell *shell;
+	EShellBackend *shell_backend;
+	EMailSession *mail_session;
+	CamelService *vstore;
+	GtkWidget *preferences_window;
+	GSettings *settings;
+
+	shell_backend = E_SHELL_BACKEND (object);
+	shell = e_shell_backend_get_shell (shell_backend);
+
+	/* Chain up to parent's constructed() method. */
+	G_OBJECT_CLASS (e_mail_shell_backend_parent_class)->constructed (object);
+
+	mail_shell_backend_init_importers ();
+
+	g_signal_connect (
+		shell, "handle-uri",
+		G_CALLBACK (mail_shell_backend_handle_uri_cb),
+		shell_backend);
+
+	g_signal_connect (
+		shell, "prepare-for-quit",
+		G_CALLBACK (mail_shell_backend_prepare_for_quit_cb),
+		shell_backend);
+
+	g_signal_connect (
+		shell, "window-added",
+		G_CALLBACK (mail_shell_backend_window_added_cb),
+		shell_backend);
+
+	/* Setup preference widget factories */
+	preferences_window = e_shell_get_preferences_window (shell);
+
+	e_preferences_window_add_page (
+		E_PREFERENCES_WINDOW (preferences_window),
+		"mail-accounts",
+		"preferences-mail-accounts",
+		_("Mail Accounts"),
+		"mail-account-management",
+		em_account_prefs_new,
+		100);
+
+	e_preferences_window_add_page (
+		E_PREFERENCES_WINDOW (preferences_window),
+		"mail",
+		"preferences-mail",
+		_("Mail Preferences"),
+		"index#mail-basic",
+		em_mailer_prefs_new,
+		300);
+
+	e_preferences_window_add_page (
+		E_PREFERENCES_WINDOW (preferences_window),
+		"composer",
+		"preferences-composer",
+		_("Composer Preferences"),
+		"index#mail-composing",
+		em_composer_prefs_new,
+		400);
+
+	e_preferences_window_add_page (
+		E_PREFERENCES_WINDOW (preferences_window),
+		"system-network-proxy",
+		"preferences-system-network-proxy",
+		_("Network Preferences"),
+		NULL,
+		mail_shell_backend_create_network_page,
+		500);
+
+	mail_session = e_mail_backend_get_session (E_MAIL_BACKEND (object));
+	vstore = camel_session_ref_service (
+		CAMEL_SESSION (mail_session), E_MAIL_SESSION_VFOLDER_UID);
+	g_return_if_fail (vstore != NULL);
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	g_settings_bind (
+		settings, "enable-unmatched",
+		vstore, "unmatched-enabled",
+		G_SETTINGS_BIND_DEFAULT);
+
+	g_object_unref (settings);
+
+	g_object_unref (vstore);
+}
+
+static void
+mail_shell_backend_start (EShellBackend *shell_backend)
+{
+	EMailShellBackendPrivate *priv;
+	EMailBackend *backend;
+	EMailSession *session;
+	EMailAccountStore *account_store;
+	GError *error = NULL;
+
+	priv = E_MAIL_SHELL_BACKEND_GET_PRIVATE (shell_backend);
+
+	backend = E_MAIL_BACKEND (shell_backend);
+	session = e_mail_backend_get_session (backend);
+	account_store = e_mail_ui_session_get_account_store (
+		E_MAIL_UI_SESSION (session));
+
+	/* XXX Should we be calling this unconditionally? */
+	vfolder_load_storage (session);
+
+	if (!e_mail_account_store_load_sort_order (account_store, &error)) {
+		g_warning ("%s: %s", G_STRFUNC, error->message);
+		g_error_free (error);
+	}
+
+	if (g_getenv ("CAMEL_FLUSH_CHANGES") != NULL) {
+		priv->mail_sync_source_id = e_named_timeout_add_seconds (
+			mail_config_get_sync_timeout (),
+			mail_shell_backend_mail_sync,
+			shell_backend);
+	}
+}
+
+static GtkWidget *
+mail_shell_backend_new_account_default (EMailShellBackend *mail_shell_backend,
+					GtkWindow *parent)
+{
+	GtkWidget *assistant;
+	EMailBackend *backend;
+	EMailSession *session;
+
+	g_return_val_if_fail (E_IS_MAIL_SHELL_BACKEND (mail_shell_backend), NULL);
+
+	assistant = mail_shell_backend->priv->assistant;
+
+	if (assistant != NULL) {
+		gtk_window_present (GTK_WINDOW (assistant));
+		return assistant;
+	}
+
+	backend = E_MAIL_BACKEND (mail_shell_backend);
+	session = e_mail_backend_get_session (backend);
+
+	if (assistant == NULL)
+		assistant = e_mail_config_assistant_new (session);
+
+	gtk_window_set_transient_for (GTK_WINDOW (assistant), parent);
+	gtk_widget_show (assistant);
+
+	mail_shell_backend->priv->assistant = assistant;
+
+	g_object_add_weak_pointer (
+		G_OBJECT (mail_shell_backend->priv->assistant),
+		&mail_shell_backend->priv->assistant);
+
+	return assistant;
+}
+
+static void
+mail_shell_backend_edit_account_default (EMailShellBackend *mail_shell_backend,
+					 GtkWindow *parent,
+					 ESource *mail_account)
+{
+	EMailShellBackendPrivate *priv;
+	EMailBackend *backend;
+	EMailSession *session;
+
+	g_return_if_fail (E_IS_MAIL_SHELL_BACKEND (mail_shell_backend));
+	g_return_if_fail (E_IS_SOURCE (mail_account));
+
+	priv = mail_shell_backend->priv;
+
+	backend = E_MAIL_BACKEND (mail_shell_backend);
+	session = e_mail_backend_get_session (backend);
+
+	if (priv->editor != NULL) {
+		gtk_window_present (GTK_WINDOW (priv->editor));
+		return;
+	}
+
+	priv->editor = e_mail_config_window_new (session, mail_account);
+	gtk_window_set_transient_for (GTK_WINDOW (priv->editor), parent);
+	g_object_add_weak_pointer (G_OBJECT (priv->editor), &priv->editor);
+
+	g_signal_connect (
+		priv->editor, "changes-committed",
+		G_CALLBACK (mail_shell_backend_changes_committed_cb),
+		mail_shell_backend);
+
+	gtk_widget_show (priv->editor);
+}
+
+static gboolean
+mail_shell_backend_delete_junk_policy_decision (EMailBackend *backend)
+{
+	GSettings *settings;
+	gboolean delete_junk;
+	gint empty_date = 0;
+	gint empty_days = 0;
+	gint now;
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	now = time (NULL) / 60 / 60 / 24;
+
+	delete_junk = g_settings_get_boolean (settings, "junk-empty-on-exit");
+
+	if (delete_junk) {
+		empty_days = g_settings_get_int (
+			settings, "junk-empty-on-exit-days");
+		empty_date = g_settings_get_int (
+			settings, "junk-empty-date");
+	}
+
+	delete_junk = delete_junk && (
+		(empty_days == 0) ||
+		(empty_days > 0 && empty_date + empty_days <= now));
+
+	if (delete_junk)
+		g_settings_set_int (settings, "junk-empty-date", now);
+
+	g_object_unref (settings);
+
+	return delete_junk;
+}
+
+static gboolean
+mail_shell_backend_empty_trash_policy_decision (EMailBackend *backend)
+{
+	GSettings *settings;
+	gboolean empty_trash;
+	gint empty_date = 0;
+	gint empty_days = 0;
+	gint now;
+
+	settings = e_util_ref_settings ("org.gnome.evolution.mail");
+
+	now = time (NULL) / 60 / 60 / 24;
+
+	empty_trash = g_settings_get_boolean (settings, "trash-empty-on-exit");
+
+	if (empty_trash) {
+		empty_days = g_settings_get_int (
+			settings, "trash-empty-on-exit-days");
+		empty_date = g_settings_get_int (
+			settings, "trash-empty-date");
+	}
+
+	empty_trash = empty_trash && (
+		(empty_days == 0) ||
+		(empty_days > 0 && empty_date + empty_days <= now));
+
+	if (empty_trash)
+		g_settings_set_int (settings, "trash-empty-date", now);
+
+	g_object_unref (settings);
+
+	return empty_trash;
+}
+
+static void
+mail_shell_backend_dispose (GObject *object)
+{
+	EMailShellBackendPrivate *priv;
+
+	priv = E_MAIL_SHELL_BACKEND (object)->priv;
+
+	if (priv->assistant != NULL) {
+		g_object_remove_weak_pointer (
+			G_OBJECT (priv->assistant), &priv->assistant);
+		priv->assistant = NULL;
+	}
+
+	if (priv->editor != NULL) {
+		g_object_remove_weak_pointer (
+			G_OBJECT (priv->editor), &priv->editor);
+		priv->editor = NULL;
+	}
+
+	/* Chain up to parent's dispose() method. */
+	G_OBJECT_CLASS (e_mail_shell_backend_parent_class)->dispose (object);
+}
+
+static void
+e_mail_shell_backend_class_init (EMailShellBackendClass *class)
+{
+	GObjectClass *object_class;
+	EShellBackendClass *shell_backend_class;
+	EMailBackendClass *mail_backend_class;
+
+	g_type_class_add_private (class, sizeof (EMailShellBackendPrivate));
+
+	object_class = G_OBJECT_CLASS (class);
+	object_class->constructed = mail_shell_backend_constructed;
+	object_class->dispose = mail_shell_backend_dispose;
+
+	shell_backend_class = E_SHELL_BACKEND_CLASS (class);
+	shell_backend_class->shell_view_type = E_TYPE_MAIL_SHELL_VIEW;
+	shell_backend_class->name = BACKEND_NAME;
+	shell_backend_class->aliases = "";
+	shell_backend_class->schemes = "mailto:email";
+	shell_backend_class->sort_order = 200;
+	shell_backend_class->preferences_page = "mail-accounts";
+	shell_backend_class->start = mail_shell_backend_start;
+
+	mail_backend_class = E_MAIL_BACKEND_CLASS (class);
+	mail_backend_class->delete_junk_policy_decision =
+		mail_shell_backend_delete_junk_policy_decision;
+	mail_backend_class->empty_trash_policy_decision =
+		mail_shell_backend_empty_trash_policy_decision;
+
+	class->new_account = mail_shell_backend_new_account_default;
+	class->edit_account = mail_shell_backend_edit_account_default;
+
+	/**
+	 * EMailShellBackend::new-account:
+	 * @parent: a #GtkWindow parent for the editor
+	 *
+	 * Opens wizard to create a new mail account.
+	 *
+	 * Returns: The new mail account assistant widget
+	 *
+	 * Since: 3.26
+	 **/
+	signals[NEW_ACCOUNT] = g_signal_new (
+		"new-account",
+		G_TYPE_FROM_CLASS (class),
+		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+		G_STRUCT_OFFSET (EMailShellBackendClass, new_account),
+		NULL, NULL,
+		NULL,
+		GTK_TYPE_WIDGET, 1,
+		GTK_TYPE_WINDOW);
+
+	/**
+	 * EMailShellBackend::edit-account:
+	 * @parent: a #GtkWindow parent for the editor
+	 * @mail_account: an #ESource for the mail account
+	 *
+	 * Edits account represented by the @source.
+	 *
+	 * Since: 3.26
+	 **/
+	signals[EDIT_ACCOUNT] = g_signal_new (
+		"edit-account",
+		G_TYPE_FROM_CLASS (class),
+		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+		G_STRUCT_OFFSET (EMailShellBackendClass, edit_account),
+		NULL, NULL,
+		NULL,
+		G_TYPE_NONE, 2,
+		GTK_TYPE_WINDOW,
+		E_TYPE_SOURCE);
+}
+
+static void
+e_mail_shell_backend_class_finalize (EMailShellBackendClass *class)
+{
+}
+
+static void
+e_mail_shell_backend_init (EMailShellBackend *mail_shell_backend)
+{
+	mail_shell_backend->priv =
+		E_MAIL_SHELL_BACKEND_GET_PRIVATE (mail_shell_backend);
+}
+
+void
+e_mail_shell_backend_type_register (GTypeModule *type_module)
+{
+	/* XXX G_DEFINE_DYNAMIC_TYPE declares a static type registration
+	 *     function, so we have to wrap it with a public function in
+	 *     order to register types from a separate compilation unit. */
+	e_mail_shell_backend_register_type (type_module);
+}
+
+GtkWidget *
+e_mail_shell_backend_new_account (EMailShellBackend *mail_shell_backend,
+				  GtkWindow *parent)
+{
+	GtkWidget *assistant = NULL;
+
+	g_return_val_if_fail (mail_shell_backend != NULL, NULL);
+	g_return_val_if_fail (E_IS_MAIL_SHELL_BACKEND (mail_shell_backend), NULL);
+
+	g_signal_emit (mail_shell_backend, signals[NEW_ACCOUNT], 0, parent, &assistant);
+
+	return assistant;
+}
+
+void
+e_mail_shell_backend_edit_account (EMailShellBackend *mail_shell_backend,
+				   GtkWindow *parent,
+				   ESource *mail_account)
+{
+	g_return_if_fail (E_IS_MAIL_SHELL_BACKEND (mail_shell_backend));
+	g_return_if_fail (E_IS_SOURCE (mail_account));
+
+	g_signal_emit (mail_shell_backend, signals[EDIT_ACCOUNT], 0, parent, mail_account);
+}
+
+/******************* Code below here belongs elsewhere. *******************/
+
+static GSList *
+mail_labels_get_filter_options (gboolean include_none)
+{
+	EShell *shell;
+	EShellBackend *shell_backend;
+	EMailBackend *backend;
+	EMailSession *session;
+	EMailLabelListStore *label_store;
+	GtkTreeModel *model;
+	GtkTreeIter iter;
+	GSList *list = NULL;
+	gboolean valid;
+
+	shell = e_shell_get_default ();
+	shell_backend = e_shell_get_backend_by_name (shell, "mail");
+
+	backend = E_MAIL_BACKEND (shell_backend);
+	session = e_mail_backend_get_session (backend);
+	label_store = e_mail_ui_session_get_label_store (
+		E_MAIL_UI_SESSION (session));
+
+	if (include_none) {
+		struct _filter_option *option;
+
+		option = g_new0 (struct _filter_option, 1);
+		/* Translators: The first item in the list, to be
+		 * able to set rule: [Label] [is/is-not] [None] */
+		option->title = g_strdup (C_("label", "None"));
+		option->value = g_strdup ("");
+		list = g_slist_prepend (list, option);
+	}
+
+	model = GTK_TREE_MODEL (label_store);
+	valid = gtk_tree_model_get_iter_first (model, &iter);
+
+	while (valid) {
+		struct _filter_option *option;
+		gchar *name, *tag;
+
+		name = e_mail_label_list_store_get_name (label_store, &iter);
+		tag = e_mail_label_list_store_get_tag (label_store, &iter);
+
+		if (g_str_has_prefix (tag, "$Label")) {
+			gchar *tmp = tag;
+
+			tag = g_strdup (tag + 6);
+
+			g_free (tmp);
+		}
+
+		option = g_new0 (struct _filter_option, 1);
+		option->title = e_str_without_underscores (name);
+		option->value = tag;  /* takes ownership */
+		list = g_slist_prepend (list, option);
+
+		g_free (name);
+
+		valid = gtk_tree_model_iter_next (model, &iter);
+	}
+
+	return g_slist_reverse (list);
+}
+
+GSList *
+e_mail_labels_get_filter_options (void)
+{
+	return mail_labels_get_filter_options (TRUE);
+}
+
+GSList *
+e_mail_labels_get_filter_options_without_none (void)
+{
+	return mail_labels_get_filter_options (FALSE);
+}
+
+static const gchar *
+get_filter_option_value (EFilterPart *part,
+                         const gchar *name)
+{
+	EFilterElement *elem;
+	EFilterOption *opt;
+
+	g_return_val_if_fail (part != NULL, NULL);
+	g_return_val_if_fail (name != NULL, NULL);
+
+	elem = e_filter_part_find_element (part, name);
+	g_return_val_if_fail (elem != NULL, NULL);
+	g_return_val_if_fail (E_IS_FILTER_OPTION (elem), NULL);
+
+	opt = E_FILTER_OPTION (elem);
+	return e_filter_option_get_current (opt);
+}
+
+static void
+append_one_label_expr (GString *out,
+                       const gchar *versus)
+{
+	GString *encoded;
+
+	g_return_if_fail (out != NULL);
+	g_return_if_fail (versus != NULL);
+
+	encoded = g_string_new ("");
+	camel_sexp_encode_string (encoded, versus);
+
+	g_string_append_printf (
+		out,
+		" (= (user-tag \"label\") %s)"
+		" (user-flag (+ \"$Label\" %s))"
+		" (user-flag %s)",
+		encoded->str, encoded->str, encoded->str);
+
+	g_string_free (encoded, TRUE);
+}
+
+void
+e_mail_labels_get_filter_code (EFilterElement *element,
+                               GString *out,
+                               EFilterPart *part)
+{
+	const gchar *label_type, *versus;
+	gboolean is_not;
+
+	label_type = get_filter_option_value (part, "label-type");
+	versus = get_filter_option_value (part, "versus");
+
+	g_return_if_fail (label_type != NULL);
+	g_return_if_fail (versus != NULL);
+
+	is_not = g_str_equal (label_type, "is-not");
+
+	if (!g_str_equal (label_type, "is") && !is_not) {
+		g_warning (
+			"%s: Unknown label-type: '%s'",
+			G_STRFUNC, label_type);
+		return;
+	}
+
+	/* the 'None' item has 'is-not' inverted */
+	if (!*versus)
+		is_not = !is_not;
+
+	g_string_append (out, " (match-all (");
+	if (is_not)
+		g_string_append (out, " not (");
+	g_string_append (out, "or");
+
+	/* the 'None' item; "is None" means "has not set any label" */
+	if (!*versus) {
+		EShell *shell;
+		EShellBackend *shell_backend;
+		EMailBackend *backend;
+		EMailSession *session;
+		EMailLabelListStore *label_store;
+		GtkTreeModel *model;
+		GtkTreeIter iter;
+		gboolean valid;
+
+		shell = e_shell_get_default ();
+		shell_backend = e_shell_get_backend_by_name (shell, "mail");
+
+		backend = E_MAIL_BACKEND (shell_backend);
+		session = e_mail_backend_get_session (backend);
+		label_store = e_mail_ui_session_get_label_store (
+			E_MAIL_UI_SESSION (session));
+
+		model = GTK_TREE_MODEL (label_store);
+		valid = gtk_tree_model_get_iter_first (model, &iter);
+
+		while (valid) {
+			gchar *tag;
+
+			tag = e_mail_label_list_store_get_tag (
+				label_store, &iter);
+
+			if (g_str_has_prefix (tag, "$Label")) {
+				gchar *tmp = tag;
+
+				tag = g_strdup (tag + 6);
+
+				g_free (tmp);
+			}
+
+			append_one_label_expr (out, tag);
+
+			g_free (tag);
+
+			valid = gtk_tree_model_iter_next (model, &iter);
+		}
+	} else {
+		append_one_label_expr (out, versus);
+	}
+
+	if (is_not)
+		g_string_append_c (out, ')');
+	g_string_append (out, " ))");
+}
+
diff -urN a/src/modules/mail/e-mail-shell-view-actions.c b/src/modules/mail/e-mail-shell-view-actions.c
--- a/src/modules/mail/e-mail-shell-view-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/mail/e-mail-shell-view-actions.c	2022-01-08 18:47:17.618211219 -0800
@@ -1634,14 +1634,14 @@
 	{ "mail-folder-expunge",
 	  NULL,
 	  N_("E_xpunge"),
-	  "<Control>e",
+	  "<Super>e",
 	  N_("Permanently remove all deleted messages from this folder"),
 	  G_CALLBACK (action_mail_folder_expunge_cb) },
 
 	{ "mail-folder-mark-all-as-read",
 	  "mail-mark-read",
 	  N_("Mar_k All Messages as Read"),
-	  "<Control>slash",
+	  "<Super>slash",
 	  N_("Mark all messages in the folder as read"),
 	  G_CALLBACK (action_mail_folder_mark_all_as_read_cb) },
 
@@ -1684,14 +1684,14 @@
 	{ "mail-folder-select-thread",
 	  NULL,
 	  N_("Select Message _Thread"),
-	  "<Control>h",
+	  "<Super>h",
 	  N_("Select all messages in the same thread as the selected message"),
 	  G_CALLBACK (action_mail_folder_select_thread_cb) },
 
 	{ "mail-folder-select-subthread",
 	  NULL,
 	  N_("Select Message S_ubthread"),
-	  "<Shift><Control>h",
+	  "<Shift><Super>h",
 	  N_("Select all replies to the currently selected message"),
 	  G_CALLBACK (action_mail_folder_select_subthread_cb) },
 
@@ -1712,7 +1712,7 @@
 	{ "mail-goto-folder",
 	  NULL,
 	  N_("Go to _Folder"),
-	  "<Control>g",
+	  "<Super>g",
 	  N_("Opens a dialog to select a folder to go to"),
 	  G_CALLBACK (action_mail_goto_folder_cb) },
 
@@ -1789,7 +1789,7 @@
 	{ "mail-threads-collapse-all",
 	  NULL,
 	  N_("Collapse All _Threads"),
-	  "<Shift><Control>b",
+	  "<Shift><Super>b",
 	  N_("Collapse all message threads"),
 	  G_CALLBACK (action_mail_threads_collapse_all_cb) },
 
@@ -1916,7 +1916,7 @@
 	{ "mail-preview",
 	  NULL,
 	  N_("Show Message _Preview"),
-	  "<Control>m",
+	  "<Super>m",
 	  N_("Show message preview pane"),
 	  NULL,  /* Handled by property bindings */
 	  TRUE },
@@ -1948,7 +1948,7 @@
 	{ "mail-threads-group-by",
 	  NULL,
 	  N_("_Group By Threads"),
-	  "<Control>t",
+	  "<Super>t",
 	  N_("Threaded message list"),
 	  NULL,  /* Handled by property bindings */
 	  FALSE },
diff -urN a/src/modules/webkit-inspector/evolution-webkit-inspector.c b/src/modules/webkit-inspector/evolution-webkit-inspector.c
--- a/src/modules/webkit-inspector/evolution-webkit-inspector.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/modules/webkit-inspector/evolution-webkit-inspector.c	2022-01-08 18:47:17.618211219 -0800
@@ -31,7 +31,7 @@
 	(G_TYPE_CHECK_INSTANCE_CAST \
 	((obj), E_TYPE_WEBKIT_INSPECTOR, EWebKitInspector))
 
-/* <Control>+<Shift>+I or <Control>+<Shift>+D */
+/* <Super>+<Shift>+I or <Super>+<Shift>+D */
 #define WEBKIT_INSPECTOR_MOD  (GDK_CONTROL_MASK | GDK_SHIFT_MASK)
 #define WEBKIT_INSPECTOR_KEY1  (GDK_KEY_I)
 #define WEBKIT_INSPECTOR_KEY2  (GDK_KEY_D)
diff -urN a/src/plugins/external-editor/external-editor.c b/src/plugins/external-editor/external-editor.c
--- a/src/plugins/external-editor/external-editor.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/plugins/external-editor/external-editor.c	2022-01-08 18:47:17.618211219 -0800
@@ -487,7 +487,7 @@
 	{ "ExternalEditor",
 	  NULL,
 	  N_("Compose in External Editor"),
-	  "<Shift><Control>e",
+	  "<Shift><Super>e",
 	  N_("Compose in External Editor"),
 	  G_CALLBACK (launch_editor) }
 };
diff -urN a/src/plugins/templates/templates.c b/src/plugins/templates/templates.c
--- a/src/plugins/templates/templates.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/plugins/templates/templates.c	2022-01-08 18:47:17.618211219 -0800
@@ -906,7 +906,7 @@
 	{ "template",
 	  "document-save",
 	  N_("Save as _Template"),
-	  "<Shift><Control>t",
+	  "<Shift><Super>t",
 	  N_("Save as Template"),
 	  G_CALLBACK (action_template_cb) }
 };
diff -urN a/src/shell/e-shell-window-actions.c b/src/shell/e-shell-window-actions.c
--- a/src/shell/e-shell-window-actions.c	2021-12-02 23:23:53.000000000 -0800
+++ b/src/shell/e-shell-window-actions.c	2022-01-08 18:47:17.618211219 -0800
@@ -917,21 +917,21 @@
 	{ "close",
 	  "window-close",
 	  N_("_Close Window"),
-	  "<Control>w",
+	  "<Super>w",
 	  N_("Close this window"),
 	  G_CALLBACK (action_close_cb) },
 
 	{ "close-window-menu",
 	  "window-close",
 	  N_("_Close"),
-	  "<Control>w",
+	  "<Super>w",
 	  N_("Close this window"),
 	  G_CALLBACK (action_close_cb) },
 
 	{ "close-window",
 	  "window-close",
 	  N_("_Close Window"),
-	  "<Control>w",
+	  "<Super>w",
 	  N_("Close this window"),
 	  G_CALLBACK (action_close_cb) },
 
@@ -945,14 +945,14 @@
 	{ "copy-clipboard",
 	  "edit-copy",
 	  N_("_Copy"),
-	  "<Control>c",
+	  "<Super>c",
 	  N_("Copy the selection"),
 	  NULL },  /* Handled by EFocusTracker */
 
 	{ "cut-clipboard",
 	  "edit-cut",
 	  N_("Cu_t"),
-	  "<Control>x",
+	  "<Super>x",
 	  N_("Cut the selection"),
 	  NULL },  /* Handled by EFocusTracker */
 
@@ -973,14 +973,14 @@
 	{ "new-window",
 	  "window-new",
 	  N_("New _Window"),
-	  "<Control><Shift>w",
+	  "<Super><Shift>w",
 	  N_("Create a new window displaying this view"),
 	  G_CALLBACK (action_new_window_cb) },
 
 	{ "paste-clipboard",
 	  "edit-paste",
 	  N_("_Paste"),
-	  "<Control>v",
+	  "<Super>v",
 	  N_("Paste the clipboard"),
 	  NULL },  /* Handled by EFocusTracker */
 
@@ -994,14 +994,14 @@
 	{ "preferences",
 	  "preferences-system",
 	  N_("_Preferences"),
-	  "<Control><Shift>s",
+	  "<Super><Shift>s",
 	  N_("Configure Evolution"),
 	  G_CALLBACK (action_preferences_cb) },
 
 	{ "quit",
 	  "application-exit",
 	  N_("_Quit"),
-	  "<Control>q",
+	  "<Super>q",
 	  N_("Exit the program"),
 	  G_CALLBACK (action_quit_cb) },
 
@@ -1022,7 +1022,7 @@
 	{ "search-clear",
 	  "edit-clear",
 	  N_("_Clear"),
-	  "<Control><Shift>q",
+	  "<Super><Shift>q",
 	  N_("Clear the current search parameters"),
 	  G_CALLBACK (action_search_clear_cb) },
 
@@ -1036,7 +1036,7 @@
 	{ "search-options",
 	  "edit-find",
 	  N_("_Find"),
-	  "<Control>f",
+	  "<Super>f",
 	  N_("Click here to change the search type"),
 	  G_CALLBACK (action_search_options_cb) },
 
@@ -1057,14 +1057,14 @@
 	{ "select-all",
 	  "edit-select-all",
 	  N_("Select _All"),
-	  "<Control>a",
+	  "<Super>a",
 	  N_("Select all text"),
 	  NULL },  /* Handled by EFocusTracker */
 
 	{ "shortcuts",
 	  NULL,
 	  N_("_Keyboard Shortcuts"),
-	  "<Control><Shift>question",
+	  "<Super><Shift>question",
 	  N_("Show keyboard shortcuts"),
 	  G_CALLBACK (action_shortcuts_cb) },
 
@@ -1713,7 +1713,7 @@
 
 		/* The first nine views have accelerators Ctrl+(1-9). */
 		if (ii < 10)
-			accelerator = g_strdup_printf ("<Control>%d", ii);
+			accelerator = g_strdup_printf ("<Super>%d", ii);
 		else
 			accelerator = g_strdup ("");
 
